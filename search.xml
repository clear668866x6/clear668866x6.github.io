<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024整理</title>
    <url>/2025/01/01/2024%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="1810C-Make-It-Permutation"><a href="#1810C-Make-It-Permutation" class="headerlink" title="1810C-Make It Permutation"></a><a href="https://codeforces.com/contest/1810/problem/C">1810C-Make It Permutation</a></h1><ul>
<li><p>题意：给定一个长为 n 的序列 a，你可以进行以下两个操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 删除 a 中的任意一个数字，花费为 c。</span><br><span class="line">2. 往 a 的任意位置插入一个数字，花费为 d。</span><br></pre></td></tr></table></figure>
<p>求最后得到一个任意长度的排列的最小花费。</p>
</li>
<li><p>思路：重复的要删掉，缺少的要补上，因此可以先对 $a$ 进行排序，去重。我们可以依次遍历整个数组，对于每个元素 $a_i$，构造一个 $[1,a_i]$ 的排列需要的花费是 $c\times(n-i)+d\times(a_i-i)$，取其中的最小值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">w</span>(n);</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=n*c+d;</span><br><span class="line">    <span class="built_in">sort</span>(w.<span class="built_in">begin</span>(),w.<span class="built_in">end</span>());</span><br><span class="line">    w.<span class="built_in">erase</span>(<span class="built_in">unique</span>(w.<span class="built_in">begin</span>(),w.<span class="built_in">end</span>()),w.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m=w.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,(n-i<span class="number">-1</span>)*c+(w[i]-i<span class="number">-1</span>)*d);<span class="comment">//排列排序之后都跟下标有关系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1381A2-Prefix-Flip-Hard-Version"><a href="#1381A2-Prefix-Flip-Hard-Version" class="headerlink" title="1381A2-Prefix Flip (Hard Version)"></a><a href="https://codeforces.com/contest/1381/problem/A2">1381A2-Prefix Flip (Hard Version)</a></h1><ul>
<li>题意：给定两个二进制字符串 $a$ 和 $b$ ，通过不超过 $2n$ 次操作，将字符串 $a$ 变成字符串 $b$。每一次操作将字符串 $a$ 的前 $p$ 个字符中 $0$ 变成 $1$，$1$ 变成 $0$，并将前 $p$ 个字符反转。</li>
<li>思路：如果每一个字符串只有 $1$ 或者 $0$ 那么只需要一次操作即可，所以，接下来的任务就是如何将每一个字符串变成只有一个字符的字符串这个可以从前面开始遍历，如果这个位置与后一个位置不同，那么就对这一个位置之前的进行操作，一直到最后就可以了。举个例子：<br>$01010→11010→00010→11110→00000$，而且，我们经过上面的操作之后，每一个字符串的字符与原字符串最后一个字符相同，所以我们就不需要在数组中修改了，这样就能减少时间复杂度。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;a,b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=s[i<span class="number">+1</span>])&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[i]!=t[i<span class="number">+1</span>])&#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[n<span class="number">-1</span>]!=t[n<span class="number">-1</span>])&#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>())&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:a)cout&lt;&lt;c&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:b)cout&lt;&lt;c&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大启发，转化成全部相同的数最优</p>
<h1 id="1684D-Traps"><a href="#1684D-Traps" class="headerlink" title="1684D Traps"></a><a href="https://codeforces.com/contest/1684/problem/D">1684D Traps</a></h1></blockquote>
</li>
<li>题意： 你的面前有 $n$ 个陷阱，第 $i(i≤n)$ 会对你造成 $a_i$ 点伤害。你可以选择跳过 $k$ 个陷阱来避免伤害，但代价是此后的每一个陷阱的伤害都加 $1$。</li>
<li>思路： 尽可能的通过 $k$ 次跳过陷阱的机会减小受到的伤害，对于每个陷阱 $ x $，跳过它可以直接减小的伤害为 $ a_x $，不过以后的每个没有被跳过的陷阱（共 $ n-x $ 个）所造成的伤害都要增加 $ 1 $ 点，所以跳过陷阱 $ x $ 能减少的伤害为 $ a_x -n+x $ ，然后从大到小排序，把减少伤害大的放在前面这样更优。 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,k;</span><br><span class="line">int w[N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int s=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(k==n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;0\n&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;a;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        w[i]=(w[i]-n+i);</span><br><span class="line">        a.push_back(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a.rbegin(),a.rend());</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;k;i++)s-=a[i];</span><br><span class="line"></span><br><span class="line">    ans=s-k*(k-1)/2;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把最大的变化值放在最前面</p>
<h1 id="739A-Alyona-and-mex"><a href="#739A-Alyona-and-mex" class="headerlink" title="739A Alyona and mex"></a><a href="https://codeforces.com/contest/739/problem/A">739A Alyona and mex</a></h1></blockquote>
<ul>
<li>题意：你有 m 个区间，要求构造一个长度为 n 的序列使得这 m 个区间中 mex 最小的最大（mex 定义为一个区间内没有出现过的最小自然数）。</li>
<li>思路：易知，$mex$ 的最小值与数列的长度有关，每个区间有 $r-l+1$ 个数，很明显，要满足题意，需要寻找每个序列长度的最小值即可，即 $mex= \min(r_i-l_i+1,mex)$，构造序列时循环输出 $0$ 到 $mex-1$。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m;</span><br><span class="line">int l[N],r[N];</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)&#123;</span><br><span class="line">        ans=min(ans,r[i]-l[i]+1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        cout&lt;&lt;i%ans&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>要让每个区间mex最大值最小，那么此时我们就放$r-l+1$ 即可。</p>
</blockquote>
<h1 id="93A-Frames"><a href="#93A-Frames" class="headerlink" title="93A-    Frames"></a><a href="https://codeforces.com/contest/93/problem/A">93A-    Frames</a></h1><ul>
<li>题意：给出 $n$ 个数，一行 $m$ 个，一共排成 $\left\lceil\dfrac{n}{m}\right\rceil$ 行。想给出连续的一些数字 $a \sim b$，求最少用几个矩形方框把它们都框起来。（可以参照Windows的文件管理器的文件夹）</li>
<li>思路：就简单的分类讨论，答案肯定也就只有 <code>1,2,3</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    int xa=(a-1)/m+1;</span><br><span class="line">    int ya=(a-1)%m+1;</span><br><span class="line">    int xb=(b-1)/m+1;</span><br><span class="line">    int yb=(b-1)%m+1;</span><br><span class="line"></span><br><span class="line">    if(xa==xb||(ya==1&amp;&amp;yb==m)||(ya==1&amp;&amp;b==n))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;1&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ya==1||yb==m||xb-xa==1||ya-yb==1||b==n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;2&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;3&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>神奇的分类讨论</p>
</blockquote>
</li>
</ul>
<h1 id="288B-Polo-the-Penguin-and-Houses"><a href="#288B-Polo-the-Penguin-and-Houses" class="headerlink" title="288B-Polo the Penguin and Houses"></a><a href="https://codeforces.com/contest/288/problem/B">288B-Polo the Penguin and Houses</a></h1><ul>
<li>题意：题目给你 $n$ 个点，有给你一个正整数 $k$。使得 $1$∼$k$ 任意一点都可以到达 $1$。$k+1$∼$n$ 的点都不能到 $1$。求满足这种情况的方案数对 $10^9+7$ 取模。</li>
<li>思路：首先手动模拟一下 $1 \rightarrow k$ 的情况。</li>
</ul>
<p>Ⅰ $k=1$,一种方案</p>
<script type="math/tex; mode=display">1→1</script><p>Ⅱ $k=2$，两种方案 </p>
<script type="math/tex; mode=display">1→1,2→1</script><script type="math/tex; mode=display">1→2,2→1</script><p> Ⅲ $k=3$$，九种方案 </p>
<script type="math/tex; mode=display">1→1,2→1,3→1</script><script type="math/tex; mode=display">1→1,2→1,3→2</script><script type="math/tex; mode=display">1→1,2→3,3→1</script><script type="math/tex; mode=display">1→2,2→1,3→1</script><script type="math/tex; mode=display">1→2,2→3,3→1</script><script type="math/tex; mode=display">1→2,2→1,3→2</script><script type="math/tex; mode=display">1→3,2→1,3→1</script><script type="math/tex; mode=display">1→3,2→1,3→2</script><script type="math/tex; mode=display">1→3,2→3,3→1</script><p> 找规律可知，方案数为$k^{k-1}$。<br>然后从 $k+1\rightarrow n$ ，因为任何一点都无法到达 $1$，那么对于每一个数都可以连向 $k+1\rightarrow n$ 的任何一个数，那么种类数也就是 $(n-k)^{n-k}$。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;qmi(m,m-1)%mod*qmi(n-m,n-m)%mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>很好的组合数学，震撼到我了，因为 $1\rightarrow k$ 是可以到达 $1$ 的，所以除 $1$ 以外其他点可以跟 $1 \rightarrow k$ 的任意一个点连接，然后就是剩下的 $k+1 \rightarrow n$ 这些不能跟 $1$ 连，那么就自己连自己，方案数是：$(n-k)^{n-k}$。</p>
</blockquote>
<h1 id="314A-Sereja-and-Contest"><a href="#314A-Sereja-and-Contest" class="headerlink" title="314A-Sereja and Contest"></a><a href="https://codeforces.com/contest/314/problem/A">314A-Sereja and Contest</a></h1><ul>
<li><p>题意：有 $n$ 个人参加了比赛，评分分别为 $a<em>1$，$a_2$，$…$ ，$a_n$ ，这个网站的评分是根据: $d_i=\sum\limits</em>{j=1}^{i-1}(a_j \cdot (j-1)-(n-i) \cdot a_i)$ 计算的。比赛结束后，评分为 $k$ 的将取消评分，并重新更新排行榜。   </p>
</li>
<li><p>思路：其实只用从头到尾进行删除，删除可能改变表中数据，问最后谁会被取消评分。最后更新排行榜，输出参与者的原始编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,k;</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int x=0,rating=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int p;</span><br><span class="line">        cin&gt;&gt;p;</span><br><span class="line">        rating++;</span><br><span class="line">        if(x-(i-1)*(n-i)*p&lt;k)&#123;</span><br><span class="line">            cout&lt;&lt;rating&lt;&lt;endl;</span><br><span class="line">            n--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            x+=p*(i-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给了你公式，叫你模拟一遍，我们就观察公式的特点即可：就比如这道题我们可以把 $d_i$ 前面的那个和提出来，设为 $x_i$，一旦发现 $d_i&lt;k$ 我们就让 $n$ 减小即可。</p>
<h1 id="1975D-Paint-the-Tree"><a href="#1975D-Paint-the-Tree" class="headerlink" title="1975D-Paint the Tree"></a><a href="https://codeforces.com/problemset/problem/1975/D">1975D-Paint the Tree</a></h1></blockquote>
</li>
<li><p>题意：给你一棵白色的树，只有 $a$ 为红色，$b$ 为蓝色，树上有两个棋子 $P_A,P_B$ 分别在节点 $a,b$ 上，在每一单位时间内，进行以下操作：</p>
</li>
<li><ul>
<li>将 $P_A$ 移动到相邻节点 $a’$，若 $a’$ 为白色，则将 $a’$ 变为红色；</li>
</ul>
</li>
<li><ul>
<li>将 $P_B$ 移动到相邻节点 $b’$，若 $b’$ 为红色，则将 $b’$ 变为蓝色。</li>
</ul>
</li>
</ul>
<p>求将整棵树染成蓝色的最短时间。</p>
<ul>
<li><p>思路：我们可以很容易想到把 $P_A$ 和 $P_B$ 集合到一个点，然后一起移动。假设这个集合的点为 $r$。接下来的问题转化成：一个棋子从 $r$ 出发，最少走几步能遍历完所有点。此时我们以 $r$ 为根，由于每条边要走 $2$ 次，即 $2(n-1)$，但是我们可以让棋子走到深度最深的叶子节点后停止，即答案为 $2(n−1)−maxdep_i$ 但是有可能 $P_A$ 和 $P_B$ 不能移动到一个点，该情况发生当且仅当 $a,b$ 路径上边的数量为奇数。不难发现我们可以让这个集合点在靠近 $a$ 的中点处。也就是此时我们要找 $r$，此时这个 $r$ 满足：$r$ 在 $a,b$ 路径上，因为 $a$ 是根，所以该条件即 $r$ 是 $b$ 的父亲，而且 $dep_r=⌈dep_b /2⌉$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;g(n+1);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;dep(n+1,0),f(n+1,0);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        g[b].emplace_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function&lt;void(int,int)&gt; dfs=[&amp;](int u,int fa)&#123;</span><br><span class="line">        dep[u]=dep[fa]+1;</span><br><span class="line">        f[u]=fa;</span><br><span class="line">        for(auto j:g[u])&#123;</span><br><span class="line">            if(j==fa)continue;</span><br><span class="line">            dfs(j,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    dfs(a,0);</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    if(a==b)&#123;</span><br><span class="line">        ans+=2*(n-1)-*max_element(dep.begin()+1,dep.end());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int p=b;</span><br><span class="line"></span><br><span class="line">        while(dep[p]!=(dep[b]+1)/2)p=f[p],ans++;</span><br><span class="line"></span><br><span class="line">        dfs(p,0);</span><br><span class="line">        </span><br><span class="line">        ans+=2*(n-1)-*max_element(dep.begin()+1,dep.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans+1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非常好的一道贪心+树形结构的题目（$P_a 、P_b$ 最好合并），一个指针遍历完整棵树的步数是 $2n-1$，并且我们是走到最深的节点停止（这样能节省步骤）。</p>
</blockquote>
</li>
<li><p><a href="https://codeforces.com/contest/229/problem/A">229A-Shifts</a> </p>
</li>
<li><p>题意：给您一个 $n×m$ 的矩阵，里面有 $0$ 或 $1$。您可以向左或向右移动一行（最后一个数会到最左（右）），问：最少要多少次操作才能够使某一列全部为 $1$？</p>
</li>
<li><p>思路：对于这种循环移动问题，很经常用扩展数组法（也就是开两倍的数组）。但这道题既有往左移也有往右移，因此可以开三倍的数组。又因为 $n,m$ 都比较小，因此可以考虑二分来找离 $i$ 最近的 $1$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dlc(int l,int r,int x,int k)&#123;</span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(g[k][mid]&gt;=x)r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return g[k][r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int tyb(int l,int r,int x,int k)&#123;</span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(g[k][mid]&lt;=x)l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return g[k][l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        bool f=false;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            if(s[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                f=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!f)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            if(s[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                g[i][++cnt[i]]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int pp=cnt[i];</span><br><span class="line">        //左移右移得扩大2倍数</span><br><span class="line">        for(int j=1;j&lt;=pp;j++)&#123;</span><br><span class="line">            g[i][++cnt[i]]=g[i][j]+m;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=pp;j++)&#123;</span><br><span class="line">            g[i][++cnt[i]]=g[i][j]+m+m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int ss=0;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            ss+=min(dlc(0,cnt[j],i+m,j)-i-m,m+i-tyb(0,cnt[j],i+m,j));//dlc左移，tyb右移</span><br><span class="line">        &#125;</span><br><span class="line">        // cout&lt;&lt;ss&lt;&lt;endl;</span><br><span class="line">        ans=min(ans,ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的一道循环左移和右移的题目，这种题目的策略是把数组复制2次，然后操作都在中间的地方进行；这道题还得用二分，左移的时候寻找 大于等于 x 的最小的数，右移的时候寻找小于等于 x 最大的数。</p>
</blockquote>
</li>
</ul>
<h1 id="1500A-Going-Home"><a href="#1500A-Going-Home" class="headerlink" title="1500A-Going Home"></a><a href="https://codeforces.com/contest/1500/problem/A">1500A-Going Home</a></h1><ul>
<li>题意：给定 $n$ 个正整数 $a_1, a_2\cdots, a_n$，求出任意一组 $x\neq y\neq z\neq w$ 使得 $a_x+a_y=a_z+a_w$。</li>
<li>思路：可以直接试试暴力，也就是枚举 $x,y$。因为本道题是这样的 $a_i\le 2.5\times 10^6$，而 $n\le2\times 10^5$，所以说明如果 $n$ 越大，根据<strong>鸽巢原理</strong>，肯定就会越多成对的，因此时间复杂度是 $O(\min(n^2,n+C))$<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            int s=w[i]+w[j];</span><br><span class="line">            if(S[s].x==0||S[s].y==0)&#123;</span><br><span class="line">                S[s]=&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            if(S[s].x!=i&amp;&amp;S[s].y!=j&amp;&amp;S[s].x!=j&amp;&amp;S[s].y!=i)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;S[s].x&lt;&lt;&#x27; &#x27;&lt;&lt;S[s].y&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以直接试试暴力，因为 $2s$ ，有的时候是跑不满的，因为本道题是这样的 $a_i\le 5\times 10^6$，而 $n\le2\times 10^5$，所以说明如果 $n$ 越大，根据<strong>鸽巢原理</strong>，肯定就会越多成对的，因此时间复杂度是 $O(\min(n^2,n+C))$，其中 $C$ 是 $a_i+a_j$ 的值域。注意不能用 map，因为用 map 的话会多一个常数 $\log n$。</p>
</blockquote>
</li>
</ul>
<h1 id="833B-The-Bakery-dp-线段树-贡献法优化"><a href="#833B-The-Bakery-dp-线段树-贡献法优化" class="headerlink" title="833B-The Bakery dp+线段树+贡献法优化"></a><a href="https://codeforces.com/problemset/problem/833/B">833B-The Bakery</a> dp+线段树+贡献法优化</h1><ul>
<li>题意：将一个长度为 $n$ 的序列分为 $k$ 段，使得总价值最大。其中一段区间的价值表示为区间内不同数字的个数。</li>
<li>思路：很容易想到dp，$f<em>{i,j}$ 表示已经遍历好了前 $i$ 个数且序列已经分为了 $j$ 段的最大总价值，$cnt</em>{i,j}$ 表示$i \rightarrow j$ 之间不同的颜色数。$dp[i][j]=\max(dp[k][j-1]+cnt[k+1][i]),i−1≤k≤j−1$，如果直接去暴力做的话，时间复杂度是 $O(n^3k)$ 的，因此得考虑优化，我们发现，如果我们把 dp 方程直接放到线段树中去查询（因为dp方程中的 $i$ 是在一个区间内变动的），那么可以降低到 $O(n^2lognk)$，那怎么维护 $cnt$ 数组呢？我们可以记录 $a<em>i$ 上一次出现的位置 $pos</em>{a<em>i}$，则 $a_i$ 在区间 $[pos</em>{a_i}+1,i-1]$ 的贡献都是 $1$。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,k;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int l,r,v,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;2];</span><br><span class="line">int w[N];</span><br><span class="line">int f[110][N];</span><br><span class="line">int pos[N];</span><br><span class="line">int pre[N];</span><br><span class="line"></span><br><span class="line">void pushup(int u)&#123;</span><br><span class="line">    tr[u].v=max(tr[u&lt;&lt;1].v,tr[u&lt;&lt;1|1].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int u,int x)&#123;</span><br><span class="line">    tr[u].v+=x;</span><br><span class="line">    tr[u].tag+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pushdown(int u)&#123;</span><br><span class="line">    if(tr[u].tag)&#123;</span><br><span class="line">        add(u&lt;&lt;1,tr[u].tag),add(u&lt;&lt;1|1,tr[u].tag);</span><br><span class="line">        tr[u].tag=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int u,int l,int r,int now)&#123;</span><br><span class="line">    tr[u]=&#123;l,r,0,0&#125;;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        tr[u].v=f[now][l-1];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">    build(u&lt;&lt;1,l,mid,now),build(u&lt;&lt;1|1,mid+1,r,now);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(int u,int l,int r,int x)&#123;</span><br><span class="line">    if(tr[u].l&gt;r||tr[u].r&lt;l)return;</span><br><span class="line">    if(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].v+=x;</span><br><span class="line">        tr[u].tag+=x;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pushdown(u);</span><br><span class="line">    update(u&lt;&lt;1,l,r,x);</span><br><span class="line">    update(u&lt;&lt;1|1,l,r,x);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int u,int l,int r)&#123;</span><br><span class="line">    if(tr[u].l&gt;r||tr[u].r&lt;l)return 0;</span><br><span class="line">    if(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)return tr[u].v;</span><br><span class="line"></span><br><span class="line">    pushdown(u);</span><br><span class="line">    return max(query(u&lt;&lt;1,l,r),query(u&lt;&lt;1|1,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        pre[i]=pos[w[i]]+1,pos[w[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">        memset(tr,0,sizeof tr);</span><br><span class="line">        build(1,1,n,i-1);</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            update(1,pre[j],j,1);</span><br><span class="line">            f[i][j]=query(1,1,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[k][n]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一段区间的价值表示为区间内不同数字的个数居然可以这么写 <code>pre[i]=pos[t]+1,pos[t]=i</code></p>
</blockquote>
</li>
</ul>
<h1 id="P8183-USACO22FEB-Sleeping-in-Class-B-因数"><a href="#P8183-USACO22FEB-Sleeping-in-Class-B-因数" class="headerlink" title="P8183 [USACO22FEB] Sleeping in Class B 因数"></a><a href="https://www.luogu.com.cn/problem/P8183">P8183 [USACO22FEB] Sleeping in Class B</a> 因数</h1><ul>
<li>题意：每次合并两个相邻的数，问进行的最少修改次数，以使所有数字相等。</li>
<li>思路：因为你每次合并两个数字的时候，数组的总和是不会发生变化的，那么最后要让所有数字相等，肯定是和的因数，因此我们只需要枚举和的因数就可以了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    s=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],s+=w[i];</span><br><span class="line"></span><br><span class="line">    //和为定值，可以考虑它的因数</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        if(s%i==0)&#123;</span><br><span class="line">            int cur=0;</span><br><span class="line">            bool f=false;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                cur+=w[j];</span><br><span class="line">                if(cur&gt;s/i)&#123;</span><br><span class="line">                    f=true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur==s/i)&#123;</span><br><span class="line">                    cur=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!f)&#123;</span><br><span class="line">                cout&lt;&lt;(n-i)&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一道和为定值的操作问题的好题，对于和为定值，叫我们求方案数最少，我们可以考虑和的因数（对于分段的问题）</p>
</blockquote>
</li>
</ul>
<h1 id="P8474-「GLR-R3」立春-逆序对"><a href="#P8474-「GLR-R3」立春-逆序对" class="headerlink" title="P8474 「GLR-R3」立春 逆序对"></a><a href="https://www.luogu.com.cn/problem/P8474">P8474 「GLR-R3」立春</a> 逆序对</h1><ul>
<li>题意：<br>设 $\sigma$ 为任意一个长度为 $n$ 的排列，$\tau(\sigma)$ 表示其中的逆序对个数，求出</li>
</ul>
<script type="math/tex; mode=display">
\sum_\sigma 2^{\tau(\sigma)}</script><p>对 $(10^9+7)$ 取模的结果。</p>
<ul>
<li>思路：假设我们已经知道长度为 $n-1$ 的排列的答案，记为 $a<em>{n-1}$，对于长度为 $n$ 的排列，我们可以考虑第一个数字的位置。第一个数字可以是 $1$ 到 $n$ 中的任何一个。此时，如果第一个数字是 $k$ 的话，那么它会与后面的 $n-1$ 个数字中的 $k-1$ 个数字形成逆序对，因此第一个数字是 $k$ 时，贡献的逆序对数是 $k-1$，对应的 $2^{\tau(\sigma)}$ 就是 $2^{k-1}\times a</em>{n-1}$，最后将所有的 $k$ 的情况累加起来，得到 $a<em>n=(2^0+2^1+…+2^{n-1})\times a</em>{n-1}$。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int t=1,ans=1;</span><br><span class="line"></span><br><span class="line">    while(n--)&#123; </span><br><span class="line">        t=(t*2)%mod;</span><br><span class="line">        int tmp=(t-1+mod)%mod;</span><br><span class="line">        ans=(ans*tmp)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>结论：对于逆序对的题目，要求任意排列的逆序对的总数，可以值考虑第一位数的值即可。</strong></p>
<h1 id="P8685-蓝桥杯-2019-省-A-外卖店优先级"><a href="#P8685-蓝桥杯-2019-省-A-外卖店优先级" class="headerlink" title="P8685 [蓝桥杯 2019 省 A] 外卖店优先级"></a><a href="https://www.luogu.com.cn/problem/P8685">P8685 [蓝桥杯 2019 省 A] 外卖店优先级</a></h1></blockquote>
</li>
<li>题意：经过 $1$ 个时间单位，若外卖店没订单，优先级减 $1$，否则每接 $1$ 单优先级加 $2$。如果某家外卖店某时刻优先级大于 $5$，则会被系统加入优先缓存中。如果优先级小于等于 $3$，则会被清除出优先缓存。</li>
<li>思路：以每个外卖站点为对象，然后建立小顶堆，在进行判断之前，要先判断此时是否不符合优先缓存，这里一定要先更新判断，然后再加上订单再判断一下是否在优先缓存里。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m,t;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q[N];</span><br><span class="line">bool vis[N];</span><br><span class="line"></span><br><span class="line">void check(int i,int p)&#123;</span><br><span class="line">    if(p&gt;5)vis[i]=1;</span><br><span class="line">    if(p&lt;=3)vis[i]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        q[b].push(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int cur=0,last=0;</span><br><span class="line"></span><br><span class="line">        while(q[i].size())&#123;</span><br><span class="line">            int now=q[i].top();</span><br><span class="line">            q[i].pop();</span><br><span class="line"></span><br><span class="line">            if(!last||last==now)last=now;</span><br><span class="line">            else cur+=(last-now+1),last=now,cur=max(cur,0ll);</span><br><span class="line"></span><br><span class="line">            check(i,cur),cur+=2,check(i,cur);</span><br><span class="line"></span><br><span class="line">            if(!q[i].size())&#123;</span><br><span class="line">                cur+=(now-t);</span><br><span class="line">                check(i,cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>模拟题，一般都以要求的对象出发，如本道题我们可以以外卖站点出发来做，这样能减少思维量。</p>
</blockquote>
<h1 id="P8725-蓝桥杯-2020-省-AB3-画中漂流"><a href="#P8725-蓝桥杯-2020-省-AB3-画中漂流" class="headerlink" title="P8725 [蓝桥杯 2020 省 AB3] 画中漂流"></a><a href="https://www.luogu.com.cn/problem/P8725">P8725 [蓝桥杯 2020 省 AB3] 画中漂流</a></h1><ul>
<li>题意：你下游 $d$ 米处是峡谷，你的体力是 $m$，每向前划一米就要耗费一点体力，水速是一米每秒，你要保证在 $t$ 秒内你要花完所有体力，并且不能掉入峡谷，求方案个数。</li>
<li>思路：因为 $d,m,t$ 都比较小，此时就可以考虑dp，然后我们发现，这很像是 $01$ 背包问题，因为体力可以看作是背包容量，每一秒就是物品的选择。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;d&gt;&gt;t&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    f[0][m]=1;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=t;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            int len=d+(m-j)-(i-(m-j));</span><br><span class="line">            if(len&gt;0)&#123;</span><br><span class="line">                f[i][j]=(f[i-1][j]+f[i-1][j+1])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$d$ 如果本道题使用背包来做的话，会出现 $d$ 不确定的情况。因此得按时间和体力两个变量来确定距离（因为距离可以通过二者求出来的）</p>
</blockquote>
</li>
</ul>
<h1 id="Problem-339-D"><a href="#Problem-339-D" class="headerlink" title="Problem 339 D"></a><a href="https://codeforces.com/problemset/problem/339/D">Problem 339 D</a></h1><ul>
<li>题意：给出一个长度为 $2^n$ 的序列 $a$，并进行 $n$ 次更新操作。</li>
<li><ul>
<li>在第奇数次操作时，将每两个相邻的数 按位或，并将这些得到的值组成的序列代替序列 $a$。</li>
</ul>
</li>
<li><ul>
<li>在第偶数数次操作时，将每两个相邻的数 按位异或，并将这些得到的值组成的序列代替序列 $a$。</li>
</ul>
</li>
</ul>
<p>在 $n$ 次操作后，$a$ 序列中只剩下了一个数，我们称这个数为序列 $a$ 的键值。并且给出 $m$ 个询问，每次询问包含两个数 $p,b$，表示求当 $a_p=b$ （其他数不变）时序列 $a$ 的键值。</p>
<ul>
<li>思路：这个有直接给你公式，此时要查询我们直接用线段树就可以了。此时线段树维护深度 $d$，$d\%2=1$ 时或，$0$ 时异或。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct E&#123;</span><br><span class="line">    int l,r,v,step;</span><br><span class="line">&#125;tr[N&lt;&lt;2];</span><br><span class="line">int n,m;</span><br><span class="line">int w[N];</span><br><span class="line"></span><br><span class="line">void pushup(int u)&#123;</span><br><span class="line">    if(tr[u].step&amp;1)tr[u].v=tr[u&lt;&lt;1].v|tr[u&lt;&lt;1|1].v;</span><br><span class="line">    else tr[u].v=tr[u&lt;&lt;1].v^tr[u&lt;&lt;1|1].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int u,int l,int r,int step)&#123;</span><br><span class="line">    tr[u]=&#123;l,r,0,step&#125;;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        tr[u].v=w[l];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">    build(u&lt;&lt;1,l,mid,step-1),build(u&lt;&lt;1|1,mid+1,r,step-1);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(int u,int p,int x)&#123;</span><br><span class="line">    if(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].v=x;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=tr[u].l+tr[u].r&gt;&gt;1;</span><br><span class="line">    if(p&lt;=mid)update(u&lt;&lt;1,p,x);</span><br><span class="line">    else update(u&lt;&lt;1|1,p,x);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int len=(1ll&lt;&lt;n);</span><br><span class="line">    for(int i=1;i&lt;=len;i++)cin&gt;&gt;w[i];</span><br><span class="line">    build(1,1,len,n);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        update(1,x,y);</span><br><span class="line">        cout&lt;&lt;tr[1].v&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于有通式，而且是单点修改然后查询的话，我们可以用线段树进行操作。（代码453）</p>
</blockquote>
</li>
</ul>
<h1 id="P2072-宗教问题"><a href="#P2072-宗教问题" class="headerlink" title="P2072 宗教问题"></a><a href="https://www.luogu.com.cn/problem/P2072">P2072 宗教问题</a></h1><ul>
<li>题意：现在要按顺序把这N个教徒分成一些集体，每个集体的危险值定义为这个集体中的宗教种数，且一个集体的宗教种类不能超过K种。问： 1.这N个教徒至少要分为几个集体，2.这些集体的危险值总和至少为多少。</li>
<li>思路：由于这里的 $n\le 1000$，然后这道题又是集合的分段问题，可以考虑dp，其实可以更深入考虑就是一个区间dp，$f<em>{i,j}$ 表示在区间 $[i,j]$ 的集体数，$g</em>{i,j}$ 表示在区间 $[i,j]$ 的最小危险数。状态转移：$f<em>{i,j}=\min(f</em>{i,v}+1)，g<em>{i,j}=\min(g</em>{i,v}+val)，u[v+1][j]&lt;=k$， 其中 $u$ 可以预处理，它算的是区间 $[i,j]$ 有多少个不同的宗教数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m,k;</span><br><span class="line">int w[N];</span><br><span class="line">int f[N][N],g[N][N];</span><br><span class="line">bool b[N];</span><br><span class="line">int u[N][N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int l=0;</span><br><span class="line">        for(int j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            if(!b[w[j]])&#123;</span><br><span class="line">                l++,b[w[j]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            u[i][j]=l,f[i][j]=g[i][j]=1e18;</span><br><span class="line">        &#125;        </span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            b[j]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i]=g[i][i]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int l=1;l&lt;=n-1;l++)&#123;</span><br><span class="line">        for(int r=l+1;r&lt;=n;r++)&#123;</span><br><span class="line">            if(u[l][r]&lt;=k)g[l][r]=min(g[l][r],u[l][r]);</span><br><span class="line">            if(u[l][r]&lt;=k)f[l][r]=min(f[l][r],1ll);</span><br><span class="line">            for(int v=l;v&lt;=r;v++)&#123;</span><br><span class="line">                if(u[v+1][r]&lt;=k)&#123;</span><br><span class="line">                    g[l][r]=min(g[l][r],g[l][v]+u[v+1][r]);</span><br><span class="line">                    f[l][r]=min(f[l][r],f[l][v]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[1][n]&lt;&lt;endl&lt;&lt;g[1][n]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的区间dp，非常特殊的区间dp，此时的区间dp是用来解决分段问题。分段问题可以考虑二分、贪心、区间dp等。</p>
</blockquote>
</li>
</ul>
<h1 id="P3848-TJOI2007-跳棋"><a href="#P3848-TJOI2007-跳棋" class="headerlink" title="P3848 [TJOI2007] 跳棋"></a><a href="https://www.luogu.com.cn/problem/P3848">P3848 [TJOI2007] 跳棋</a></h1><ul>
<li>题意：给你一个 $n×n$ 的跳棋棋盘和一个棋子位置。格子为 $0$ 被认为是可以到达的，格子为 $1$ 的则不能，而棋子只能上下左右 $4$ 个方向跳。 能到达的两个格子间不能相邻，即起点和终点最少要隔一格。显然，跳过的格子不能再跳。求最远跳跃总距离。</li>
<li>思路：因为 $n\le 100$，因此可以考虑 dfs。此时需要注意的就是它会一直朝着一个方向走很多步才会到 $0$ 的格子。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,x,y;</span><br><span class="line">int ans;</span><br><span class="line">int w[N][N];</span><br><span class="line">bool vis[N][N];</span><br><span class="line">int dx[]=&#123;-1,0,1,0&#125;,dy[]=&#123;0,1,0,-1&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y,int step)&#123;</span><br><span class="line">    vis[x][y]=true;</span><br><span class="line">    ans=max(ans,step);</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;   </span><br><span class="line">        int tx=x,ty=y,s=0;</span><br><span class="line">        while(tx+dx[i]&gt;0&amp;&amp;tx+dx[i]&lt;=n&amp;&amp;ty+dy[i]&gt;0&amp;&amp;dy[i]+ty&lt;=n)&#123;</span><br><span class="line">            tx+=dx[i];</span><br><span class="line">            ty+=dy[i];</span><br><span class="line">            s++;</span><br><span class="line">            if(!w[tx][ty])break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tx&lt;1||ty&lt;1||tx&gt;n||ty&gt;n||s==1||vis[tx][ty]||w[tx][ty]==1)continue;</span><br><span class="line">        vis[tx][ty]=1;</span><br><span class="line">        dfs(tx,ty,step+s);</span><br><span class="line">        vis[tx][ty]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(x,y,0);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一次性跳到有 $0$ 的地方。</p>
</blockquote>
</li>
</ul>
<h1 id="P1632-点的移动"><a href="#P1632-点的移动" class="headerlink" title="P1632 点的移动"></a><a href="https://www.luogu.com.cn/problem/P1632">P1632 点的移动</a></h1><ul>
<li><p>题意：平面上有 $N$ 个整数坐标点。如果将点 $(x_0,y_0)$ 移动到 $(x_1,y_1)$，则需要的代价为 $|x_0-x_1|+|y_0-y_1|$。求使得 $K(K=1, \cdots ,N)$ 个点在同一位置上最少需要的代价。</p>
</li>
<li><p>思路：我们得知道：给定一个序列 $a$，求一个数 $x$ 使得 $∑∣a_i−x∣$ 最小，那么这个数是序列 $a$ 的中位数，因此我们得维护中位数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].x&gt;&gt;w[i].y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;ans(n+1,1e18);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int p=1;p&lt;=n;p++)&#123;</span><br><span class="line">                a[p]=abs(w[p].x-w[i].x)+abs(w[p].y-w[j].y);</span><br><span class="line">                //至少有一个点在某个方向上不移动是最优的</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sort(a+1,a+1+n);</span><br><span class="line"></span><br><span class="line">            for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                a[i]+=a[i-1];</span><br><span class="line">                ans[i]=min(ans[i],a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中位数问题，得知道的就是把这些数因为 $ansx$ 如果是序列 $x$ 里的数，则<strong>至少</strong>有 $1$ 个点在水平方向上不需要移动。同理，ansy如果是序列y里的数，则<strong>至少</strong>有1个点在竖直方向上不需要移动。用这样的方法可以使代价最小。为什么呢？因为在曼哈顿距离中，<strong>中位数的坐标相当于两个点的坐标延展的交点</strong>。可见图:<img src="https://cdn.luogu.com.cn/upload/pic/32080.png" alt=""> </p>
<p>也就是优点1和优点2是等价的。</p>
</blockquote>
</li>
</ul>
<h1 id="gym103428G-Shinyruo-and-KFC"><a href="#gym103428G-Shinyruo-and-KFC" class="headerlink" title="gym103428G-Shinyruo and KFC"></a><a href="https://codeforces.com/gym/103428/problem/G">gym103428G-Shinyruo and KFC</a></h1><ul>
<li><p>题意：有 $n$ 种东西，第 $i$ 种有 $a_i$​ 个。有若干个相同的袋子，袋子里可以随便放物品，但是不能存在一个袋子里有两个或以上同一种物品的情况。<br>对于 $k=1,2,3…,m$，求当有 $k$ 个袋子，放物品的方案数。</p>
</li>
<li><p>思路：根据高中组合学知识，可以很容易推出答案是：$\Pi<em>{i=1}^{n} C</em>{i}^{a[j]}$，如果直接算的话，肯定会超时，因此我们得优化，我们可以考虑相同的直接用快速幂优化掉，因此我们用 $c$ 数组装个数，然后 $a$ 数组重新放去重后的数值。即把组合数算出来的相同的式子合并成指数式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        c[w[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=(int)(1e5);i++)&#123;</span><br><span class="line">        if(c[i])&#123;</span><br><span class="line">            w[++cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int res=1;</span><br><span class="line">        for(int j=1;j&lt;=cnt;j++)&#123;</span><br><span class="line">            res=(res*qmi(C(i,w[j]),c[w[j]]))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>组合数的好题，因为我们可以直接推出答案是 $\Pi<em>{i=1}^{n} C</em>{i}^{a[j]}$ ，肯定会超时，因此我们得优化，我们可以考虑相同的直接用快速幂优化掉，因此我们用 $c$ 数组装个数，然后 $a$ 数组重新放去重后的数值。</p>
</blockquote>
</li>
</ul>
<h1 id="gym103447I-Power-and-Zero"><a href="#gym103447I-Power-and-Zero" class="headerlink" title="gym103447I-Power and Zero "></a><a href="https://codeforces.com/gym/103447/problem/I">gym103447I-Power and Zero </a></h1><p>位运算好题，我们看到 $2^{i-1}$ 就得想到转化成二进制，但我想到二进制我就不知道怎么做了。</p>
<ul>
<li>题意：给定序列 $A<em>1,A_2 ​ ,⋯,A_n$ ​ ，其元素都是正整数。你需要进行一些操作使得序列中的所有元素都变为零。对于每次操作，你可以指定一个任意长度的序列 $𝐵_1 , 𝐵_2 , ⋯ , 𝐵</em>𝑚 ( 𝐵<em>𝑖 ∈ { 1 , 2 , ⋯ , 𝑛 } )$ ，并分别将 $𝐴</em>{𝐵_𝑖 }$​ 减少 $2^{𝑖− 1}$ 。特别地，给定序列中的一个元素可以在一次操作中被多次减少。确定将给定序列全部变为零所需的最小操作次数。</li>
<li>思路：对于每个操作都是减去 $2^{i-1}$，也就是 <code>1 2 4 8</code>，那么这个就可以想到二进制。可以发现将 $A_n$ 分别求出来每个数的二进制位为 $1$ 的数量每次操作等价为消除下标从 $0$ 开始的连续的 $1$。因此，问题等价为至少多少次操作将这些二进制的 $1$ 消除掉。问题也等价为：将二进制存起来，从高位向低位变成一个不下降序列，此时最低位次数即所需次数。注意： 而为了使得操作次数最少，就要二进制数 $1$ 的个数最少。那么从后往前遍历，如果发现当前位置大于前一个位置了，就匀到前一个位置些（匀出的个数*=2），以保证前一个位置个数 &gt;= 当前位置个数。<a href="https://www.cnblogs.com/kingwz/p/16691149.html#i-power-and-modulo-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%9D%E7%BB%B4%E4%BA%8C%E5%88%86">参考解题</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;bit(65,0);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        for(int j=0;j&lt;=63;j++)&#123;</span><br><span class="line">            if((w[i]&gt;&gt;j)&amp;1)&#123;</span><br><span class="line">                bit[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto check=[&amp;]()&#123;</span><br><span class="line">        for(int i=0;i&lt;=63;i++)&#123;</span><br><span class="line">            if(bit[i]&lt;bit[i+1])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    while(!check())&#123;</span><br><span class="line">        for(int i=63;i&gt;=1;i--)&#123;</span><br><span class="line">            if(bit[i]&gt;bit[i-1])&#123;</span><br><span class="line">                bit[i]--,bit[i-1]+=2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;bit[0]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>看了解题知道，这道题就是得把每一位分类，因为那个 $B$ 数组就是给定一个顺序。因为位数高的会被删掉，且操作次数不会比低位的多。直接暴力就可以过。位数越高的删掉肯定会比低位来的更优。 $cnt<em>0≥cnt_1≥⋯≥cnt</em>{32}$ 这种最优。</p>
</blockquote>
<h1 id="NC1004-tokitsukaze-and-Soldier"><a href="#NC1004-tokitsukaze-and-Soldier" class="headerlink" title="NC1004-tokitsukaze and Soldier"></a><a href="https://ac.nowcoder.com/acm/contest/22904/1004">NC1004-tokitsukaze and Soldier</a></h1><ul>
<li>题意：已知第 $i$ 个士兵的战力为 $v[i]$，团的战力是团内所有士兵的战力之和。但是这些士兵有特殊的要求：如果选了第 $i$ 个士兵，这个士兵希望团的人数不超过 $s[i]$。(如果不选第 $i$ 个士兵，就没有这个限制。)问：团的战力最大为多少。</li>
<li>思路：贪心策略：肯定是选越多士兵越好然后士兵的战斗力越强越好。因此我们可以先将士兵按照 $s$ 从大到小排序，然后按照这个顺序依次选取士兵，这样一来我们就能够选取更多的士兵。但是选取到后面的时候我们需要将剔除掉部分士兵，选择战力小的士兵依次剔除即可（这里用堆来实现）。（有点反悔贪心的感觉，因为这里是两个变量，很经常要反悔）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        w.push_back(&#123;y,x&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(w.begin(),w.end(),greater&lt;PII&gt;());</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    int ans=0,sum=0;</span><br><span class="line"></span><br><span class="line">    for(auto [s,v]:w)&#123;</span><br><span class="line">        q.push(v);</span><br><span class="line">        sum+=v;</span><br><span class="line">        while(q.size()&gt;s)&#123;</span><br><span class="line">            sum-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>贪心用堆实现的好题。</p>
</blockquote>
</li>
</ul>
<h1 id="C-Forsaken喜欢数论-HH"><a href="#C-Forsaken喜欢数论-HH" class="headerlink" title="C-Forsaken喜欢数论_HH"></a><a href="https://ac.nowcoder.com/acm/contest/95570/C">C-Forsaken喜欢数论_HH</a></h1><ul>
<li><p>题意： 对于任意一个数 $x$，$f(x)$ 会返回 $x$ 的最小质因子。如果这个数没有最小质因子，那么就返回 $0$。现在给定任意一个 $n$，问想知道 $∑_{i=1}^{n}f(i)$的值。</p>
</li>
<li><p>思路：这个就是最小的因数和，又因为<strong>线性筛本身即是用最小质因子筛质数，因此只需要在中间记录最小质因子即可</strong>。为了加速计算，我们可以在线性筛的时候把因数累加即可，<strong>这种性质可以使得我们可以线性求出积性函数的值</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init(int x)&#123;</span><br><span class="line">    for(int i=2;i&lt;=x;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            primes[cnt++]=i;</span><br><span class="line">            ans+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;i*primes[j]&lt;=x;j++)&#123;</span><br><span class="line">            vis[i*primes[j]]=true;</span><br><span class="line">            ans+=primes[j];</span><br><span class="line">            if(i%primes[j]==0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check(int x)&#123;</span><br><span class="line">    for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">        if(x%primes[i]==0)&#123;</span><br><span class="line">            return primes[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    init(n);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的求最小因数和，就是在线性筛的时候进行累加即可。</p>
</li>
</ul>
<h1 id="P9236-蓝桥杯-2023-省-A-异或和之和"><a href="#P9236-蓝桥杯-2023-省-A-异或和之和" class="headerlink" title="P9236 [蓝桥杯 2023 省 A] 异或和之和"></a><a href="https://www.luogu.com.cn/problem/P9236">P9236 [蓝桥杯 2023 省 A] 异或和之和</a></h1><ul>
<li>题意：算 <script type="math/tex">\sum_{l=1}^{n}\sum_{r=l}^{n}f(l,r)</script>其中 $f(l,r)=a<em>l\oplus a</em>{l+1}\oplus ….a_r$。</li>
<li>思路：类似 <a href="">1879D-Sum of XOR Functions</a> 这道题。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        pre[i]=pre[i-1]^x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=20;j&gt;=0;j--)&#123;</span><br><span class="line">            w[j][(pre[i]&gt;&gt;j)&amp;1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=20;i++)&#123;</span><br><span class="line">        ans+=w[i][0]*w[i][1]*(1ll&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种我们可以先前缀和优化下，但即便这样，还是会超时，因此我们把二进制拆位，算每个的贡献，对于每一个 $p<em>i$，我们将其按位拆分，并将结果存入计数数组 $w</em>{i,j}$ 中。其中 $i$ 表示第 $i$ 个二进制位，$j$ 表示这一位上为 $j$（只能为 $0$ 或 $1$），$w<em>{i,j}$ 表示在所有数中，第 $i$ 个二进制位上为 $j$ 的有 $w</em>{i,j}$ 个。由于这些数中必定两两异或，所以可以直接用乘法原理，求出该位最终为 $1$ 的个数，最后乘上该位的权值就可以了。所以最后的答案为：（公式中 $i$ 的范围上界到 $20$ 是因为题目中说 $A<em>i\le2^{20}$，最多只有 $21$ 个二进制位）$$\sum</em>{i=0}^{20}w<em>{i,0}\times w</em>{i,1}\times 2^i$$</p>
</blockquote>
</li>
</ul>
<h1 id="众数"><a href="#众数" class="headerlink" title="众数"></a><a href="https://www.luogu.com.cn/problem/P9460">众数</a></h1><ul>
<li>题意：给定一个长度为 $n$ 的序列 $a$，修改 $k$ 次，求其所有可能的众数的数量。</li>
<li>思路：这里有个贪心策略：我们每次可以把一个数替换为另外一个数。比如我们要把 $a$ 序列的众数变为 $q$，我们可以每次把序列 $a$ 中的众数中的一个改成 $q$。因而我们可以想到使用优先队列来维护，每次维护 $a$ 中每个数字出现最多的数量。当开始操作时，将这个数字改成想要的数字，所以这个数字的出现次数会减少 $1$。我们把原来的数字弹出优先队列，修改后再弹入优先队列。那么到最后，我们得到的优先队列的顶部元素就是：如果 $q$ 想成为众数，则它修改 $k$ 次后在 $a$ 中至少出现的次数，我们将这个次数称为 $x$，也就是它在修改前在 $a$ 中至少出现 $x−k$ 次。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;int&gt;q;</span><br><span class="line"></span><br><span class="line">    for(auto [a,b]:S)&#123;</span><br><span class="line">        q.push(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">        int t=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        q.push(t-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t=q.top()-k;</span><br><span class="line">    int m=q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    if(k&gt;=m)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;pigstd&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto [a,b]:S)&#123;</span><br><span class="line">        if(b&gt;=t)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>堆来维护每个数出现的个数，因为每一次改变我们肯定是把出现最多数的数减 $1$，然后我们直接执行 $k$ 次操作，最后看出现最多的个数是多少，如果比我们的 $k$ 小的话，说明可以变成很多数，因此答案是无限。反之的话，我们得到的优先队列的顶部元素就是如果 $q$ 想成为众数，则它修改 $k$ 次后在 $a$ 中至少出现的次数，我们将这个次数称为 $x$，也就是它在修改前在 $a$ 中至少出现 $x - k$ 次。</p>
</blockquote>
</li>
</ul>
<h1 id="USACO20JANBerry-Picking-S"><a href="#USACO20JANBerry-Picking-S" class="headerlink" title="USACO20JANBerry Picking S "></a><a href="https://www.luogu.com.cn/problem/P6002">USACO20JANBerry Picking S </a></h1><ul>
<li>题意：给定 $n$ 颗树，分别有 $a_i$ 个果子，求选出 $m$ 篮果子使得最少的 $m/2$ 篮最多，要求每篮的果子都必须来自同一棵树。</li>
<li>思路：题目要求的是求较小的 $K / 2 $ 的最大值。那么我们可以设较小的 $K / 2 $ 中最大的篮子装了 $v$ 个。在前 $K / 2$ 中，果子的数量就要尽可能地小，最小为 $v$。在后 $K / 2$ 中，果子的数量就要尽可能地大，最大也为 $v$。那么就可以直接先分前 $K / 2$ ，每个篮子 $v$ 个。如果分不了，就直接无解。再去计算后 $K / 2$ ，每个篮子 $v$ 个，剩下的篮子继续装当前剩下的中最大的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    k&gt;&gt;=1ll;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line">    //前k个篮子取小的，后面k个取大的</span><br><span class="line">    for(int i=1;;i++)&#123;</span><br><span class="line">        int t=0;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;// 计算采满i的篮子数</span><br><span class="line">            t+=w[j]/i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t&lt;k)break;</span><br><span class="line">        t=min(t-k,k);// 多出的篮子</span><br><span class="line"></span><br><span class="line">        sort(w+1,w+1+n,[&amp;](int a,int b)&#123;</span><br><span class="line">            return a%i&gt;b%i;// 按照剩下的数量排序</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int v=t*i;// 采满篮子的总量</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=min(n,k-t);j++)&#123;// 采够k个篮子</span><br><span class="line">            v+=w[j]%i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的贪心，题目说 $K/2$ 的要给她，因此我们取的时候前 $K/2$ 取少点，后面取多点。</p>
</blockquote>
</li>
</ul>
<h1 id="P5199-USACO19JAN-Mountain-View-S"><a href="#P5199-USACO19JAN-Mountain-View-S" class="headerlink" title="P5199 [USACO19JAN] Mountain View S"></a><a href="https://www.luogu.com.cn/problem/P5199">P5199 [USACO19JAN] Mountain View S</a></h1><ul>
<li>题意：给定 $n$ 个等腰直角三角形的直角顶点坐标，求能看见多少个直角三角形（即求被覆盖了多少三角形，然后用 $n$ 去减）。</li>
<li>思路：注意到等腰三角形，那么等腰三角形能覆盖到的范围是 $[x_i-y_i,x_i+y_i]$。此时需要注意的是，<strong>本道题可能会出现一个山峰完全覆盖掉另一个山峰</strong>，此时就不能更新答案。所有说肯定得先按左端点排个序，然后当左端点相同的时候，按右端点降序排列。</li>
</ul>
<blockquote>
<p>为什么是降序呢？</p>
<p>答：因为当左端点相同的时候，矮的会被高的覆盖掉。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct E&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator&lt;(const E&amp; t)const&#123;</span><br><span class="line">        if(l==t.l)return r&gt;t.r;</span><br><span class="line">        return l&lt;t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line">int x[N],y[N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">        e[i]=&#123;x[i]-y[i],x[i]+y[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(e+1,e+1+n);</span><br><span class="line"></span><br><span class="line">    int ans=0,last=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(last&lt;e[i].r)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            last=e[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意，本道题可能会出现一个山峰完全覆盖掉另一个山峰，此时就不能更新答案。所有说肯定得先按左端点排个序，然后当左端点相同的时候，按右端点降序排列。为什么是降序呢？因为当左端点相同的时候，矮的会被高的覆盖掉。</p>
</blockquote>
<h1 id="P2678-NOIP-2015-提高组-跳石头"><a href="#P2678-NOIP-2015-提高组-跳石头" class="headerlink" title="P2678 [NOIP 2015 提高组] 跳石头"></a><a href="https://www.luogu.com.cn/problem/P2678">P2678 [NOIP 2015 提高组] 跳石头</a></h1><ul>
<li>题意：给你 $n$ 个石头，此时你站在坐标为 $0$ 的位置。现在会移走 $m$ 个石头，问最短跳跃距离的最大值。</li>
<li>思路：很典型的二分答案。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool check(int x)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt=0,now=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(w[i]-w[now]&lt;x)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;else now=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnt&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;L&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    w[++n]=L+1;</span><br><span class="line"></span><br><span class="line">    int l=0,r=L+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>好的二分答案的题，因为得考虑后效性，也就是会出现相邻多项的时候仍不满足大于给定答案，此时就得一直删，但如果我们只考虑相邻两项的话，很可能会多删（因为很有可能出现的情况是：相邻两项很小，但之前已经被移除了，所以下次就不要再移除了）</p>
</blockquote>
</li>
</ul>
<h1 id="P4090-USACO17DEC-Greedy-Gift-Takers-P"><a href="#P4090-USACO17DEC-Greedy-Gift-Takers-P" class="headerlink" title="P4090 [USACO17DEC] Greedy Gift Takers P"></a><a href="https://www.luogu.com.cn/problem/P4090">P4090 [USACO17DEC] Greedy Gift Takers P</a></h1><ul>
<li>题意：给你一个队列，第一个牛插到从队尾数第 $c_i+1$ 的位置。求不动的牛有多少个。</li>
<li>思路：二分能动的奶牛的分界线（因为能动奶牛比较好维护），我们会发现在分界线以外的奶牛一定会动，即序列可以分成两段一段循环另一段是完全不动的。首先我们要查找的范围就是这个队列的长度，所以去循环就可以了。这里也是要特判一下，因为如果这头牛在队首的话，那它就一定是拿得到礼物的。接下来就把拿不到的牛算出来，即总数减拿得到的牛。每次查完一头牛的情况之后就从下一头牛开始枚举，这里枚举的是在二分循环之外的牛，如果一旦找到这个牛，那么不论循环多少次，它都拿不到礼物，直接排除，那么后面的牛就往前进一位。也就是某个数如果小于该循环的位置，那么它永远也拿不了礼物。注意：check函数里面的x是可以移动的奶牛。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=1;i&lt;x;i++)b[i]=w[i];</span><br><span class="line">    sort(b+1,b+x);</span><br><span class="line"></span><br><span class="line">    int lim=n-x;</span><br><span class="line">    //序列分成两段，一段是循环，一段是完全不动的</span><br><span class="line">    for(int i=1;i&lt;x;i++)&#123;</span><br><span class="line">        if(b[i]&gt;lim)&#123;//有排在外面的就轮不到它了</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        lim++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    int l=0,r=n+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;n-l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的二分题，这个二分答案是二分位置，也就是不满足条件的分界线。首先我们要查找的范围就是这个队列的长度，所以去循环就可以了。这里也是要特判一下，因为如果这头牛在队首的话，那它就一定是拿得到礼物的。接下来就把拿不到的牛算出来，即总数减拿得到的牛。每次查完一头牛的情况之后就从下一头牛开始枚举，这里枚举的是在二分循环之外的牛，如果一旦找到这个牛，那么不论循环多少次，它都拿不到礼物，直接排除，那么后面的牛就往前进一位。也就是某个数如果小于该循环的位置，那么它永远也拿不了礼物。</p>
</blockquote>
</li>
</ul>
<h1 id="括号序列匹配"><a href="#括号序列匹配" class="headerlink" title="括号序列匹配"></a><a href="https://codeforces.com/problemset/problem/380/C">括号序列匹配</a></h1><ul>
<li>题意：每次询问一个区间的最大合法括号子序列长度。</li>
<li>思路：一般遇到合法括号序列，很多时候可以直接转化：<strong>每个左括号视为 $1$，右括号视为 $−1$。合法的序列中每个前缀和不为负数，且以 $0$ 结束</strong>。所以对于一段前缀和，先考虑是否存在负数，如果存在，就去掉相应数量的右括号。不以 $0$ 结束，就去掉相应数量的左括号。因为题目要求最大值，那么我们删除的部分要最小，那么这部分可以直接用st表求最小值来维护。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int j=0;j&lt;=20;j++)&#123;</span><br><span class="line">        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;</span><br><span class="line">            if(!j)f[i][j]=w[i];</span><br><span class="line">            else f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ask(int l,int r)&#123;</span><br><span class="line">    int len=log(r-l+1);</span><br><span class="line"></span><br><span class="line">    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;q;</span><br><span class="line">    n=s.size();</span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;)w[i]=w[i-1]+1;</span><br><span class="line">        else w[i]=w[i-1]-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        int p=r-l+1;</span><br><span class="line">        int t=ask(l,r);</span><br><span class="line">        cout&lt;&lt;p-abs(w[r]-t)-abs(w[l-1]-t)&lt;&lt;endl;//一个是删左括号，一个是删右括号</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于括号序列，我们常用 $+1$ 来表示左括号，右括号则 $-1$，那么只要匹配好了答案就是 $0$，本道题要求我们求子序列，那么我们先对右括号进行操作，如果右括号多我们就删掉（此时右括号就得看 $l-1$ 内的左括号），然后如果左括号多我们就删掉左括号。</p>
</blockquote>
</li>
</ul>
<h1 id="CF448D-Multiplication-Table"><a href="#CF448D-Multiplication-Table" class="headerlink" title="CF448D Multiplication Table"></a><a href="https://codeforces.com/problemset/problem/448/D">CF448D Multiplication Table</a></h1><ul>
<li>题意：给出n,m,k，请输出在n*m的乘法表中第k小的数。</li>
<li>思路：求第 $k$ 小有时候可以考虑二分，即二分一个数，看这个数是不是第 $k$ 大的即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cnt+=min(m,x/i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnt&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int l=0,r=n*m+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的二分题，二分某个数，看某个数前面的数有没有 $k$ 个。</p>
</blockquote>
</li>
</ul>
<h1 id="Problem-1247D-Codeforces"><a href="#Problem-1247D-Codeforces" class="headerlink" title="Problem - 1247D - Codeforces"></a><a href="https://codeforces.com/problemset/problem/1247/D">Problem - 1247D - Codeforces</a></h1><ul>
<li>题意：找 $a_i\times a_j=x^k$ 的数量。</li>
<li>思路：它们的值是 $x^k$，那么对于能乘出他们的数来说，它们的质因子的质数个数必然是 $k$ 的倍数。此时把他们两个分解成 $P_1^{x_1}+P_1^{x_1}…$ 的形式，然后我们只需要分析指数即可。显然意味着每一个质因数的指数和要是 $k$ 的倍数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int t[N];</span><br><span class="line">int p;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    map&lt;vector&lt;PII&gt;,int&gt;S;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int t=w[i];</span><br><span class="line">        vector&lt;PII&gt;a,b;</span><br><span class="line">        for(int j=2;j&lt;=t/j;j++)&#123;</span><br><span class="line">            int s=0;</span><br><span class="line">            while(t%j==0)&#123;</span><br><span class="line">                s++;</span><br><span class="line">                t/=j;</span><br><span class="line">                s%=k;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!s)continue;</span><br><span class="line">            a.push_back(&#123;j,s&#125;);</span><br><span class="line">            b.push_back(&#123;j,k-s&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(t&gt;1)&#123;</span><br><span class="line">            a.push_back(&#123;t,1&#125;);</span><br><span class="line">            b.push_back(&#123;t,k-1&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=S[b];</span><br><span class="line">        S[a]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的最小分解定理的题目，你要让 $A\times B=x^k$ ，那么把他们两个分解成 $P_1^{x_1}+P_1^{x_1}…$ 的形式，然后我们只需要分析指数即可。显然意味着每一个质因数的指数和要是 $k$ 的倍数，所以我们用 <code>map&lt;vector&lt;PII&gt;,int&gt;</code> 来维护重复出现的次数。</p>
</blockquote>
</li>
</ul>
<h1 id="P8782-蓝桥杯-2022-省-B-X-进制减法"><a href="#P8782-蓝桥杯-2022-省-B-X-进制减法" class="headerlink" title="P8782 [蓝桥杯 2022 省 B] X 进制减法"></a><a href="https://www.luogu.com.cn/problem/P8782">P8782 [蓝桥杯 2022 省 B] X 进制减法</a></h1><ul>
<li>题意：给你 $2$ 个同一进制规则的 $X$ 进制数 $A,B$，但是其具体每一数位的进制还不确定，试求出 $A−B$ 的最小值。</li>
<li>思路：题目保证 $A≥B$，所以想要 $A−B$ 的值尽量小，每一位的权值也得尽量小，因为如果让 $B$ 变大，$A$ 就会比 $B$ 变大得更快，从而让 $A−B$ 的值变得更大。那么，如果想让每一位的权值尽量小，每一位的进制也得尽量小，因为每一位的权值是和它低的位的进制有关系的，把每一位的进制减小，那么它的高位的权值也会变小。所以本题的贪心策略就是每一位取最小的进制值。所以对应到代码就是 <code>max(a[i],b[i])+1</code>。</li>
</ul>
<blockquote>
<p>为什么是 <code>max(a[i],b[i])+1</code>？</p>
<p>答：因为进制数越小越好，因此只取它们两个的最大值即可。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;m1;</span><br><span class="line"></span><br><span class="line">    for(int i=m1;i&gt;=1;i--)cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;m2;</span><br><span class="line">    for(int i=m2;i&gt;=1;i--)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    for(int i=max(m1,m2);i;i--)&#123;</span><br><span class="line">        c[i]=max(a[i],b[i])+1;</span><br><span class="line">        c[i]=(c[i]&gt;2)?c[i]:2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=max(m1,m2);i++)&#123;</span><br><span class="line">        d[i]=(d[i-1]*c[i-1])%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans1=0,ans2=0;</span><br><span class="line"></span><br><span class="line">    for(int i=m1;i;i--)&#123;</span><br><span class="line">        (ans1+=a[i]*d[i]%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=m2;i;i--)&#123;</span><br><span class="line">        (ans2+=b[i]*d[i]%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(ans1-ans2+mod)%mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的进制考法，具体思路就是：我们得发现：$321=3\times 10\times 2+2\times 1+1$。</p>
</blockquote>
<h1 id="P6278-USACO20OPEN-Haircut-G"><a href="#P6278-USACO20OPEN-Haircut-G" class="headerlink" title="P6278 [USACO20OPEN] Haircut G"></a><a href="https://www.luogu.com.cn/problem/P6278">P6278 [USACO20OPEN] Haircut G</a></h1><ul>
<li>题意：有一个序列，长度为 $n$，且 $1 ≤ A[i] ≤ n$， 现在要求把大于 $j(j ≤ 0 &lt; n)$ 的 $A[i]$ 变为 $j$ 后有几个逆序对，每行输出一个。</li>
<li>思路：可以考虑在剪头发时，哪些逆序对会留下来，哪些逆序对会消失，易得：<br>（假设有一个逆序对 $(i,j)$,$k$ 表示目前减到的长度）当 $A<em>j\lt k$ 时，此时 $A_i$ 仍然大于 $A_j$，逆序对 $(i,j)$ 可以留下来。当 $A_j\ge k$ 时，此时 $A_i=A_j$，逆序对 $(i,j)$ 会消失。那么每当 $k$ 下降 $1$，所有 $A_j=k$ 的逆序对 $(i,j)$ 都会消失。我们可以开一个 $cnt$ 数组，$cnt_k$ 记录上述值。容易想到在树状数组求逆序对时进行维护（注意此时已经求出来了以当前位置结尾的逆序对个数），设当前位置为 $j$，逆序对个数为 $x$，则 $cnt</em>{Aj}+=x$。最后依次输出 $cnt$ 的前缀和即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int x,int c)&#123;</span><br><span class="line">    for(int i=x;i&lt;N;i+=lowbit(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ask(int x)&#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=x;i;i-=lowbit(i))res+=tr[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        w[i]++;</span><br><span class="line">        t[w[i]]+=i-1-ask(w[i]);</span><br><span class="line">        add(w[i],1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        ans+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的用树状数组求解逆序对的方法。我们用的是贡献法，就是可以考虑在剪头发时，哪些逆序对会留下来，哪些逆序对会消失。当 $A_j&lt;k$ 的时候，如果仍然满足逆序对的要求的话，那么此时的逆序对就得算上，反之逆序对就要减小。因此我们知道：那么每当 $k$ 下降 $1$，所有 $A_j=k$ 的逆序对 $(i,j)$ 都会消失，而且当头发长度为 $A_i$ 时逆序对的数量 = 到 $A_i$ 之前的逆序对数量 + 这个数所能贡献的逆序对的数量。</p>
</blockquote>
<h1 id="P6146-USACO20FEB-Help-Yourself-G"><a href="#P6146-USACO20FEB-Help-Yourself-G" class="headerlink" title="P6146 [USACO20FEB] Help Yourself G"></a><a href="https://www.luogu.com.cn/problem/P6146">P6146 [USACO20FEB] Help Yourself G</a></h1><ul>
<li>题意：给定 $n$ 条线段 $[l_i,r_i ]$，每次对于一条线段可以选或不选，求形成的 $2^n$ 种选择情况形成的连通块个数之和。</li>
<li>思路：为了方便计算，先按照 $l<em>i$ 升序排序。由于每条线段可选和不选，又因为数据规模不大，因此可以考虑dp。设 $f_i$ 为截止到第 $i$ 条边的答案。状态转移：不选第 $i$ 条线段，为 $f</em>{i-1}$。选第 $i$ 条线段。如果有前面的线段 $[l<em>i,r_i]$ 满足 $l_i \le r_j \le r_i$，那么它们将合并为同一线段，不会产生新的联通块。又因为此时我们对 $l_i$ 升序排序，所以计算有多少个线段 $[l_j,r_j]$ 满足，只需要 $r_j&lt;l_i$。暴力时间复杂度高，因此考虑桶排序的方式优化，定义 $cnt[i]$ 为有多少个满足 $r_j&lt;l_i$ 的线段，那么这条线段对答案的贡献为 $f</em>{i-1}+2^{cnt[i]}$。这个 $cnt[i]$ 可以搞成一个通排记录 $r_i$ 个数的前缀和。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct E&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator&lt;(const E&amp; t)const&#123;</span><br><span class="line">        return l&lt;t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        w[i]=&#123;l,r&#125;;</span><br><span class="line">        s[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=2*n;i++)s[i]+=s[i-1];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        (f[i]+=2*f[i-1]%mod+qmi(2,s[w[i].l-1])%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子集选取问题，我们可以用dp来写，就是对于每个线段，可选可不选，如果选的话，则要算上贡献，反之不要。因此得看每个区间跟上个区间是否有交集，我们可以用 $s$ 数组来存储所有右端点的个数。</p>
</blockquote>
</li>
</ul>
<h1 id="P6154"><a href="#P6154" class="headerlink" title="P6154"></a><a href="https://www.luogu.com.cn/problem/P6154">P6154</a></h1><ul>
<li>题意：给定一个有向无环图，求其中一条路径长度的期望。一条路径长度的期望 $=\frac{sum}{cnt}$。其中 $sum$ 代表所有路径长度的总和， $cnt$ 代表路径的个数。</li>
<li>思路：令 $f<em>i$ 表示从 $i$ 开始的路径长度和， $g_i$ 表示从 $i$ 开始的路径条数。则 $f_i=\sum\limits</em>{edge(i,j)}f<em>j+g_j$，$g_i=1+\sum\limits</em>{edge(i,j)}g_j$ ，那么此时的答案即为 $\dfrac{\sum f_i}{\sum g_i}$。这里我们采取的是拓扑排序，因为考虑 $DAG$ 中的一个点 $x$，定义一个点 from，那么根据 $DAG$ 的定义，$x$ 无法回到 from，也就是说，from对 $x$ 有影响， $x$ 对 from 无影响。</li>
</ul>
<blockquote>
<p>疑问：为什么状态转移是那样的？</p>
<p>答：很好理解，即 $j$ 到 $i$ 有边时，$f_i$ 为所有以 $j$ 为结尾的路径长度上均加上 $1$。而这样的路径有 $g _j$ 条，所以总的就是 $f_j+g_j$。至于边界值，显然 $∀i∈G,g_i=1$，因为每个点的路径条数至少为 $1$。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m;</span><br><span class="line">vector&lt;int&gt;g[N];</span><br><span class="line">int f[N],p[N];//f表示以节点i为结尾的总路径长度，p表示以节点i为结尾的路径个数</span><br><span class="line">int din[N];</span><br><span class="line"></span><br><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void topsort()&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!din[i])q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        for(auto&amp; j:g[t])&#123;</span><br><span class="line">            --din[j];</span><br><span class="line">            if(din[j]==0)&#123;</span><br><span class="line">                q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">            (f[j]+=(f[t]+p[t]))%=mod;</span><br><span class="line">            (p[j]+=p[t])%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        din[b]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topsort();</span><br><span class="line"></span><br><span class="line">    int ans1=0,ans2=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)(ans1+=f[i])%=mod;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)(ans2+=p[i])%=mod;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans1*qmi(ans2,mod-2)%mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很好的一道数学期望题，我们发现：所以选择的路径都是等概率的，因此对于等概率的，它的期望是： $\frac{路径长度}{路径总个数}$ ，那么本道题就是这样的求的。具体的状态转移内容可以看<a href="https://www.luogu.com.cn/article/m4npggjj">文章</a>。</p>
</blockquote>
<h1 id="指纹锁"><a href="#指纹锁" class="headerlink" title="指纹锁"></a><a href="https://ac.nowcoder.com/acm/contest/19850/L">指纹锁</a></h1><blockquote>
<p>很好的一道 STL 的题目，我们可以对set的排序进行自定义，具体的写法如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator()(const int&amp; a,const int&amp; b)const&#123;</span><br><span class="line">        if(labs(a-b)&lt;=k)return false;</span><br><span class="line">        return a&lt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;int,cmp&gt;S;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思就是：如果差值小于 $k$ 的话，就弹出，反之的话按从小到大排序。</p>
<h1 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a><a href="https://ac.nowcoder.com/acm/contest/19851/1001">四舍五入</a></h1><blockquote>
<p>这里要注意一下，如果我们对 <code>string</code> 类型进行操作取那个 <code>\0</code> 的操作的话，我们就得用 c 语言的输出方式输出，怎么输出呢？用转换器：<code>s.c_str()</code>。还有就是 <code>resize</code> 的用法，如果 <code>resize</code> 里面的 $n$ 小于本来的长度，前面 $n$ 元素是会 <strong>保留</strong> 的，如果其他元素在它的外面，就会被删掉。还有就是 <code>s.npos</code> 的用法，其实它指的是 <code>string</code> 中不存在位置的位置（是个常量）。</p>
</blockquote>
<h1 id="强迫症的序列"><a href="#强迫症的序列" class="headerlink" title="强迫症的序列"></a><a href="https://ac.nowcoder.com/acm/contest/19851/1022">强迫症的序列</a></h1><blockquote>
<p>题目说对 $n-1$ 加 $1$，那么我们可以对 $1$ 个数减 $1$。</p>
<h1 id="兔子的逆序对"><a href="#兔子的逆序对" class="headerlink" title="兔子的逆序对"></a><a href="https://ac.nowcoder.com/acm/contest/21763/1008">兔子的逆序对</a></h1><p>很好的一道逆序对的题目，我们采用的是用树状数组求逆序对的方式：<code>add(w[i],1),ans+=i-query(w[i])</code> 即可。拓展结论：假设有一个长度为 $m$ 的序列，它的逆序对的个数是 $x$，经过翻转，它的逆序对数是 $\frac{(r-l+1)(r-l)}{2}-x$。为什么是这样的呢？因为在翻转的过程中，正序变成逆序，逆序变成正序，由于没有想要的数，容易发现：$x+顺序对的个数=总对数$。或者也可以：交换偶数次，奇偶性不变； 交换奇数次，奇变偶，偶变奇； 翻转$[l,r]$，需要交换$(r−l+1)/2$次。</p>
<h1 id="P8898-USACO22DEC-Feeding-the-Cows-B"><a href="#P8898-USACO22DEC-Feeding-the-Cows-B" class="headerlink" title="P8898 [USACO22DEC] Feeding the Cows B"></a><a href="https://www.luogu.com.cn/problem/P8898">P8898 [USACO22DEC] Feeding the Cows B</a></h1><ul>
<li>题意：选出最少的草地，使得所有同品种的奶牛离这些草地的任意一个距离不超过 $k$，并输出方案。</li>
<li>思路：要让更多奶牛吃草，肯定在第 $i$ 个奶牛的时候尽量后放到最后一个力所能及的位置，即放到 $i+k$ 的位置，如果 $i+k&gt;n$，那么放在第 $n$ 个位置，因为所有 $i$ 互不相同，所以除非放在第 $n$ 块草坪，否则没有冲突，如果冲突，就每次判断略前的位置，一直到一个未冲突的位置。由于往后放，所以放过一次之后 $i$ 必须直接跳到 $i+2×k$。（此时还有一个策略就是尽可能先满足其中一头牛了之后再满足另外一头牛）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    string ans,s;</span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    if(!k)&#123;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans.resize(n,&#x27;.&#x27;);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;G&#x27;)&#123;</span><br><span class="line">            ans[min(i+k,n-1)]=&#x27;G&#x27;;</span><br><span class="line">            i+=2*k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;H&#x27;)&#123;</span><br><span class="line">            if(i+k&lt;n-1)&#123;</span><br><span class="line">                ans[i+k]=&#x27;H&#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                for(int j=n-1;j&gt;=0;j--)&#123;</span><br><span class="line">                    if(ans[j]==&#x27;.&#x27;)&#123;</span><br><span class="line">                        ans[j]=&#x27;H&#x27;;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=2*k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto c:ans)&#123;</span><br><span class="line">        if(c!=&#x27;.&#x27;)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    for(auto c:ans)cout&lt;&lt;c;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于两个变量的题目，我们可以先满足其中一个的，然后再满足另一个的。</li>
</ul>
</blockquote>
<h1 id="1324E-Sleeping-Schedule"><a href="#1324E-Sleeping-Schedule" class="headerlink" title="1324E Sleeping Schedule"></a><a href="https://codeforces.com/problemset/problem/1324/E">1324E Sleeping Schedule</a></h1><ul>
<li>题意：给定一个数组 $a$，可以选择将其中一些减 $1$（也可以不减），问前缀和数组对 $h$ 取模后在区间 $[L,R]$ 内的元素最多有多少个。</li>
<li>思路：因为数据规模不大，而且每个数可以选也可以不选，因此我们设 $dp[i][j]$ 表示在前 $i$ 个数中，所有数之和对 $h$ 取模的值为 $j$ 时，答案最大为多少。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;h&gt;&gt;l&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">    memset(f,-0x3f,sizeof f);//为什么要这样呢，因为我们不能从非法状态转移，这样也就保证每次只能从[0,0]转移过来</span><br><span class="line">    f[0][0]=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;h;j++)&#123;</span><br><span class="line">            if(j&gt;=l&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">                f[i][j]=max(f[i-1][(j-w[i]+h)%h]+1,f[i-1][(j-w[i]+1+h)%h]+1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                f[i][j]=max(f[i-1][(j-w[i]+h)%h],f[i-1][(j-w[i]+1+h)%h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;h;i++)ans=max(ans,f[n][i]);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这道题是一道很典型的 $DP$ 问题，就是它的状态不能从非 $0$ 开始的状态转移过来，因为不可能存在起始时刻不为 0 的情况，因而我们可以通过对 $f$ 数组赋最的值，这样就能保证不从其他非法状态转移。</p>
</blockquote>
</li>
</ul>
<h1 id="1368D-AND-OR-and-square-sum"><a href="#1368D-AND-OR-and-square-sum" class="headerlink" title="1368D AND, OR and square sum"></a><a href="https://codeforces.com/problemset/problem/1368/D">1368D AND, OR and square sum</a></h1><ul>
<li><p>题意：给定大小为 $n$ 的序列 $a$ ，定义一次操作为选择两个数 $i,j\in[1,n]$ ，设执行操作前 $a<em>i=x,a_j=y$ ，那么执行操作后 $a_i=x \operatorname{and} y,a_j=x \operatorname{or} y$ ，执行若干次操作后， $\sum</em>{i=1}^na_i^2$ 最大能为多少。</p>
</li>
<li><p>思路：首先得知道：$x+y=(x and y)+(x or y)$。（容斥显然得到的）<strong>也就是说，前后操作的总和是不变的</strong>。显然，当 $a$ 中较大的数越大时，$Σa^2$ 越大。又因为我们可以操作任意次，为了让大的尽量大，所以我们每次在二进制上取最多的位数，对于答案的贡献一定是最大的。于是做法就显然了，把所有二进制拆了扔进桶里，每次从取所有不为空的桶计入答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=20;j++)&#123;</span><br><span class="line">            cnt[j]+=(w[i]&gt;&gt;j)&amp;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int cur=0;</span><br><span class="line">        for(int j=0;j&lt;=20;j++)&#123;</span><br><span class="line">            if(cnt[j])&#123;</span><br><span class="line">                cnt[j]--;</span><br><span class="line">                cur+=(1ll&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=cur*cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的位运算题目，得让我知道 $x+y=(x and y)+(x or y)$，因此每次操作综合保持不变，因此要让平方和最大，就得让每次在二进制上取最多的位数，对于答案的贡献一定是最大的。（注意：综合不变的情况下，无论进行多少次操作，总的二进制的 $1$ 的个数不变）</p>
</blockquote>
</li>
</ul>
<h1 id="数位dp模板。值得每天写一下。"><a href="#数位dp模板。值得每天写一下。" class="headerlink" title="数位dp模板。值得每天写一下。"></a>数位dp模板。值得每天写一下。</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">int</span> k,len;</span><br><span class="line"><span class="type">int</span> f[<span class="number">110</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> cnt,<span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;len)&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt==k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[now][cnt][limit]!=<span class="number">-1</span>)<span class="keyword">return</span> f[now][cnt][limit];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxv=limit?num[now]:<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)&#123;</span><br><span class="line">        res+=<span class="built_in">dp</span>(now<span class="number">+1</span>,cnt+(i!=<span class="number">0</span>),limit&amp;(i==maxv));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[now][cnt][limit]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">110</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">110</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                f[i][j][k]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len=s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        num[i<span class="number">+1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AGC003C-BBuBBBlesort"><a href="#AGC003C-BBuBBBlesort" class="headerlink" title="[AGC003C] BBuBBBlesort!"></a><a href="https://www.luogu.com.cn/problem/AT_agc003_c">[AGC003C] BBuBBBlesort!</a></h1><ul>
<li>题意：给定一个序列 a，元素两两不同，可以使用两种操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 翻转相邻两个元素。</span><br><span class="line">2. 翻转相邻三个元素。</span><br></pre></td></tr></table></figure>
问怎么操作使这个序列变成升序，并使操作一的次数最少。输出这个最少的次数。</li>
<li>思路：注意到操作 $2$ 只能使下标奇偶相同的数的位置发生变化。然后操作 $1$ 能使下标奇偶不同的数的位置发生变化。由于所有数都不一样，所以每个数的最终位置都是确定的。那么如果最终位置和当前位置的奇偶性不一样，$ans←ans+1$。最后考虑到每次操作 $1$ 改变 $2$ 个数的位置的奇偶性，$ans← ans/2$。</li>
</ul>
<p>做法1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        b[i]=w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(b+1,b+1+n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)w[i]=lower_bound(b+1,b+1+n,w[i])-b;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if((i&amp;1)!=(w[i]&amp;1))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans/2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>做法2：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),x)-p.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;odd,even,t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        p.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">    p.<span class="built_in">erase</span>(<span class="built_in">unique</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>()),p.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)odd.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">        <span class="keyword">else</span> even.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(odd.<span class="built_in">begin</span>(),odd.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(even.<span class="built_in">begin</span>(),even.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;odd.<span class="built_in">size</span>()&amp;&amp;i&lt;even.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t.<span class="built_in">push_back</span>(odd[i]);</span><br><span class="line">        t.<span class="built_in">push_back</span>(even[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(odd.<span class="built_in">size</span>()&gt;even.<span class="built_in">size</span>())t.<span class="built_in">push_back</span>(odd.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        t[i<span class="number">-1</span>]=<span class="built_in">find</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        ans+=i<span class="number">-1</span>-<span class="built_in">query</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">add</span>(t[i<span class="number">-1</span>],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这道题很好的一道奇偶分析的题目，因为 $a<em>i=a</em>{i+2}$ ，所以奇数交换仍然是奇数，偶数也是。这种翻转问题得多多留意下标。</p>
</blockquote>
<h1 id="ABC238E-Range-Sums"><a href="#ABC238E-Range-Sums" class="headerlink" title="[ABC238E] Range Sums"></a><a href="https://www.luogu.com.cn/problem/AT_abc238_e">[ABC238E] Range Sums</a></h1><ul>
<li>题意：输入一个 $n$ 和 $q$ 分别表示数组长度为 $n$，有 $q$ 次输入：每次输入一个 $l$ 和 $r$，表示我们知道 $l$ 到 $r$ 区间的和问你最后能否知道数组的和。</li>
<li>思路：要求 $[l,r]$ 的和，此时得想到前缀和。而正向的前缀和公式是 $ans=s<em>r-s</em>{l-1}$，变形为 $s<em>{l-1}=s_r-ans$，对于题目给定的 $ans$，我们可以用 $s_r$ 来求粗 $s</em>{l-1}$，这个特点就很熟悉了，连一条边，然后判断 $0$ 和 $n$ 是否在同一个联通块中，如果在，那么就求的出 $s_n-s_0$  ，也就是所有数的和。联通块直接用并查集即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    if(x!=p[x])p[x]=find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)p[i]=i;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l=find(l-1),r=find(r);</span><br><span class="line">        p[l]=r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(find(0)==find(n)?&quot;Yes&quot;:&quot;No&quot;)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的一道并查集跟前缀和合并的一道题目，如果 $l$ 和 $r$ 是一个联通块的话，那么说明 $l-1\rightarrow r$ 的范围内的区间都能被表示。</p>
</blockquote>
</li>
</ul>
<h1 id="P2912-USACO08OCT-Pasture-Walking-G"><a href="#P2912-USACO08OCT-Pasture-Walking-G" class="headerlink" title="P2912 [USACO08OCT] Pasture Walking G"></a><a href="https://www.luogu.com.cn/problem/P2912">P2912 [USACO08OCT] Pasture Walking G</a></h1><ul>
<li>题意：求图上两个奶牛的距离。</li>
<li>思路：LCA模板题。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs(int u,int fa)&#123;</span><br><span class="line">    for(int i=1;i&lt;=20;i++)&#123;</span><br><span class="line">        f[u][i]=f[f[u][i-1]][i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto&amp; [j,w]:G[u])&#123;</span><br><span class="line">        if(j==fa)continue;</span><br><span class="line">        f[j][0]=u;</span><br><span class="line">        d[j]=d[u]+w;</span><br><span class="line">        dep[j]=dep[u]+1;</span><br><span class="line">        dfs(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int x,int y)&#123;</span><br><span class="line">    if(dep[x]&lt;dep[y])swap(x,y);</span><br><span class="line"></span><br><span class="line">    for(int i=20;~i;i--)&#123;</span><br><span class="line">        if(dep[f[x][i]]&gt;=dep[y])&#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(x==y)return x;</span><br><span class="line"></span><br><span class="line">    for(int i=20;~i;i--)&#123;</span><br><span class="line">        if(f[x][i]!=f[y][i])&#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[x][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].emplace_back(b,c);</span><br><span class="line">        G[b].emplace_back(a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1,0);</span><br><span class="line"></span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        int p=lca(x,y);</span><br><span class="line">        cout&lt;&lt;d[x]+d[y]-2*d[p]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
很好的一道 $lca$ 题目，是一道模板题，值得看看。</li>
</ul>
<h1 id="NOI2014-起床困难综合症"><a href="#NOI2014-起床困难综合症" class="headerlink" title="[NOI2014] 起床困难综合症  "></a><a href="https://www.luogu.com.cn/problem/P2114">[NOI2014] 起床困难综合症  </a></h1><ul>
<li>题意：给定 $n$ 个事件 $(opi,ti)$，其中 $opi$ 为$and/or/xor$ 三种位运算之一，$ti$ 为非负整数，要求在 $[0,m]$ 中选择一个数 $x$，最大化对 $x$ 依次执行 $n$ 个事件后的结果。</li>
<li>思路：由于要最大化结果，因此我们可以考虑贪心：能用 $0$ 换 $1$ 就一定能换，能用 $1$ 换 $1$ 也换，不能换就不换。注意到这道题的 $1$ 是怎么来的？它可能是从 $0$ 来的，也可能从 $1$ 来的，因此我们的初始值为全 $0$ 和全 $1$ 来计算。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m;</span><br><span class="line">string s;</span><br><span class="line">int a1=0,a2=-1;//全0和全1</span><br><span class="line">//尽可能变成1</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1,x;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;x;</span><br><span class="line">        if(s==&quot;AND&quot;)a1&amp;=x,a2&amp;=x;</span><br><span class="line">        if(s==&quot;OR&quot;)a1|=x,a2|=x;</span><br><span class="line">        if(s==&quot;XOR&quot;)a1^=x,a2^=x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=30;i&gt;=0;i--)&#123;</span><br><span class="line">        if(a1&gt;&gt;i&amp;1ll)ans+=(1ll&lt;&lt;i);//0-&gt;1</span><br><span class="line">        else if(a2&gt;&gt;i&amp;1ll&amp;&amp;(1ll&lt;&lt;i)&lt;=m)&#123;//1-&gt;1</span><br><span class="line">            ans+=(1ll&lt;&lt;i),m-=(1ll&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的一道位运算题目：位运算只针对二进制下的每一位，也就是说每一位经过 $n$ 次位运算以后，不会影响别的位。如果最后选 1 比选 0 更好，并且选完 1 过后 val≤m 那么选择 1。<strong>因此对于这种要选 $1$ 更好，我们就得想1是怎么来的，比如这道题1可以从0或者1来，因此我们就设a1=0,a2=-1。</strong> </p>
</blockquote>
</li>
<li>题意：给定一个长度为 n 的非负整数序列 A ，求一个平均数最大的，长度不小于 L 的子段。</li>
<li>思路：直接二分答案，然后对于二分答案中又有长度限制此时就考虑单调队列。然后这边需要注意的是，我们二分的是平均值，然后把每个数减去平均值就是每个数离平均数的差值，如果单调队列找到为 $0$ 的，此时说明满足条件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(double x)&#123;</span><br><span class="line">    vector&lt;double&gt;p(n+1,0);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]=w[i]-x;</span><br><span class="line">        p[i]+=p[i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double t=0;</span><br><span class="line"></span><br><span class="line">    deque&lt;int&gt;q;</span><br><span class="line"></span><br><span class="line">    for(int i=L;i&lt;=n;i++)&#123;</span><br><span class="line">        while(q.size()&amp;&amp;p[q.back()]&gt;p[i-L])q.pop_back();</span><br><span class="line">        q.push_back(i-L);</span><br><span class="line">        if(q.size()&amp;&amp;p[i]-p[q.front()]&gt;=0)return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    double l=0,r=2e9;</span><br><span class="line"></span><br><span class="line">    while(r-l&gt;eps)&#123;</span><br><span class="line">        double mid=(l+r)/2.0;</span><br><span class="line">        if(check(mid))l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(int)(r*1000)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="USACO03MAR-Best-Cow-Fences-G"><a href="#USACO03MAR-Best-Cow-Fences-G" class="headerlink" title="[USACO03MAR] Best Cow Fences G  "></a><a href="https://www.luogu.com.cn/problem/P10450">[USACO03MAR] Best Cow Fences G  </a></h1></li>
</ul>
<blockquote>
<p>对于平均数的问题，我们往往可以把原数全部减去平均数来判断多少大于平均数和小于平均数，然后这道题是长度只说明 $&gt;=L$ ，那么我们直接用单调队列即可，就是不需要长度太长弹出的操作（考察单调队列维护固定长度区间的最大值）。</p>
</blockquote>
<h1 id="ABC346D-Gomamayo-Sequence"><a href="#ABC346D-Gomamayo-Sequence" class="headerlink" title="[ABC346D] Gomamayo Sequence"></a><a href="https://www.luogu.com.cn/problem/AT_abc346_d">[ABC346D] Gomamayo Sequence</a></h1><ul>
<li>题意：有一个长为 N 的 01 串 S。定义好字符串：有且仅有一个 $1≤i&lt;N$，满足 $S<em>i=S</em>{i+1}$，把每个字符修改（0 变 1，1 变 0）需要 $c_i$ 块钱。问你把 S 改成好字符串需要几块钱。</li>
<li>思路：因为数字只有 $01$ 两个数，因此可以考虑dp。此时是三个维度的，$f_{i,j,k}$ 表示已经到第 $i$ 个地方，第 $i$ 位的状态是 $j$ 情况，且整个字符串的状态是 $k$ 的最小方案数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    f[2][0][0]=(s[1]==&#x27;0&#x27;)*w[1]+(s[2]==&#x27;1&#x27;)*w[2];</span><br><span class="line">    f[2][1][0]=(s[1]==&#x27;1&#x27;)*w[1]+(s[2]==&#x27;0&#x27;)*w[2];</span><br><span class="line">    f[2][0][1]=(s[1]==&#x27;1&#x27;)*w[1]+(s[2]==&#x27;1&#x27;)*w[2];</span><br><span class="line">    f[2][1][1]=(s[1]==&#x27;0&#x27;)*w[1]+(s[2]==&#x27;0&#x27;)*w[2];</span><br><span class="line"></span><br><span class="line">    for(int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i][0][0]=f[i-1][1][0]+(s[i]==&#x27;1&#x27;)*w[i];</span><br><span class="line">        f[i][1][0]=f[i-1][0][0]+(s[i]==&#x27;0&#x27;)*w[i];</span><br><span class="line">        f[i][0][1]=min(f[i-1][1][1],f[i-1][0][0])+(s[i]==&#x27;1&#x27;)*w[i];</span><br><span class="line">        f[i][1][1]=min(f[i-1][0][1],f[i-1][1][0])+(s[i]==&#x27;0&#x27;)*w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;min(f[n][0][1],f[n][1][1])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HAOI2008-糖果传递"><a href="#HAOI2008-糖果传递" class="headerlink" title="[HAOI2008] 糖果传递"></a><a href="https://www.luogu.com.cn/problem/P2512">[HAOI2008] 糖果传递</a></h1><ul>
<li>题意：有 $n$ 个小朋友坐成一圈，每人有 $a_i$ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $1$。</li>
<li>思路：我们算出 $ans=\sum_{i=1}^{n}|c_i-(-p_1)|$，这个也就是说，要找到一点到所有 $c_1,c_2,…,c_n$ 的距离最短，这样就转化成了货仓选址。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int sum=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        sum+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(sum%n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ave=sum/n;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        c[i]=(w[i]-ave);</span><br><span class="line">        c[i]+=c[i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(c+1,c+1+n);</span><br><span class="line"></span><br><span class="line">    int t=c[(n+1)&gt;&gt;1];</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=abs(t-c[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ABC327D-Good-Tuple-Problem"><a href="#ABC327D-Good-Tuple-Problem" class="headerlink" title="[ABC327D] Good Tuple Problem"></a><a href="https://www.luogu.com.cn/problem/AT_abc327_d">[ABC327D] Good Tuple Problem</a></h1><ul>
<li>题意：给定 $n$ 个值为 $0$ 或 $1$ 的点和 $m$ 条关系，每一条关系表示两个点的值不能相同，问是否有合法构造方案满足所有条件。</li>
<li>思路：对于这种一个取 $0$ 另一个必须取 $1$ 的情况，说明什么？说明我们可以用种类并查集来做（就是扩展域），就是 $x$ 跟 $y’$ 连边，然后 $y’$ 跟 $x$ 连边。（当然也可以用 <a href="https://www.luogu.com.cn/article/q5mxbvg9">2——SAT做法</a>）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    if(x!=p[x])p[x]=find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=m;i++)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n*2;i++)p[i]=i;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        x=find(a[i]),y=find(b[i]);</span><br><span class="line">        if(x==y)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        p[find(a[i]+n)]=y,p[find(b[i]+n)]=x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="1626C-Monsters-And-Spells"><a href="#1626C-Monsters-And-Spells" class="headerlink" title="1626C Monsters And Spells"></a><a href="https://codeforces.com/problemset/problem/1626/C">1626C Monsters And Spells</a></h1><ul>
<li>题意：有 $n$ 个怪兽，第 $i$ 个怪兽在第 $k_i$ 秒出现，血量为 $h_i$，你可以在每一秒提升战斗力，假设你上一秒的战斗力是 $x$，那么你这一秒战斗力可以选择 $x+1$ 或 $1$ 或 $0$。你要保证对于每个怪兽，在第 $k_i$ 秒时，战斗力至少是 $h_i$。每一秒消耗的魔力就是那一秒的战斗力，求能够打败所有怪兽所消耗的魔力值最小值。</li>
<li>思路：对于一个怪兽，如果要在第 $k_i$ 秒战斗力达到 $h_i$，那么你就至少在第 $k_i-h_i+1$ 秒开始积累战斗值。这样我们可以记一个怪兽转换为要求占用的区间 $[k_i-h_i+1,k_i]$。显然对于一个区间 $[l,r]$，这个区间的魔力值消耗就是 $1+2+3+\dots+(r-l+1)=(r-l+1)(r-l+2)/2$。那么，如果两个区间相交了，会发生什么事呢？假设两个区间 $[l_1,r_1],[l_2,r_2]$ 有相交。那么，在第 $r_1$ 秒的时间你的战斗力已经是一个很大的数了，而又无法在此时重新积累战斗力，不然就打败不了第二个怪兽，所以战斗力要继续累积。因此我们可以这两个区间的魔力值最小消耗就等价于合并成一个大区间。包含的情况也是一样。所以我们只需要把这些区间合并成若干个区间，然后再统计每个区间的答案即可。这一题的 $n$ 奇小，所以每次合并暴力把一个区间删掉都可以。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n;</span><br><span class="line">int k[N],h[N];</span><br><span class="line">struct E&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator&lt;(const E&amp; t)const&#123;</span><br><span class="line">        if(l!=t.l)return l&lt;t.l;</span><br><span class="line">        return r&lt;t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N];</span><br><span class="line"></span><br><span class="line">void del(int x)&#123;</span><br><span class="line">    for(int i=x;i&lt;n;i++)seg[i]=seg[i+1];</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;k[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;h[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        seg[i]=&#123;k[i]-h[i]+1,k[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(seg+1,seg+1+n);</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(seg[i].l&lt;=seg[i-1].r)&#123;</span><br><span class="line">            seg[i-1].r=max(seg[i].r,seg[i-1].r);</span><br><span class="line">            del(i);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=(seg[i].r-seg[i].l+1)*(seg[i].r-seg[i].l+2)/2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>区间很少的区间合并问题，此时可以用暴力删除的方式做题。</p>
</blockquote>
<h1 id="219D-Choosing-Capital-for-Treeland"><a href="#219D-Choosing-Capital-for-Treeland" class="headerlink" title="219D-Choosing Capital for Treeland  "></a><a href="https://www.luogu.com.cn/problem/CF219D">219D-Choosing Capital for Treeland  </a></h1><ul>
<li>题意：给定 $n$ 个点，$n−1$ 条有向边，求到达所有其他点需要更换方向最小的次数，及符合这类条件的点的升序序列</li>
<li><p>思路：换根dp的典型题目。（换根dp简单来说就是先算出任意一个点出发的情况，然后再通过从任意一个点出发算出的答案来更新特定根出发的答案）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs1(int u,int fa)&#123;//求出u到子节点需要逆转的边数</span><br><span class="line"></span><br><span class="line">    for(auto&amp; [j,w]:G[u])&#123;</span><br><span class="line">        if(j==fa)continue;</span><br><span class="line">        dfs1(j,u);</span><br><span class="line">        f[u]+=(f[j]+w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs2(int u,int fa)&#123;//求出u到全树需要逆转的边数</span><br><span class="line">    for(auto&amp; [j,w]:G[u])&#123;</span><br><span class="line">        if(j==fa)continue;</span><br><span class="line">        f[j]=f[u]+(w?-1:1);</span><br><span class="line">        dfs2(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].emplace_back(b,0);//正向边</span><br><span class="line">        G[b].emplace_back(a,1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs1(1,0);</span><br><span class="line">    dfs2(1,0);</span><br><span class="line"></span><br><span class="line">    int minv=*min_element(f+1,f+1+n);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;minv&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(f[i]==minv)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于这种题目，我们都是采用换根dp，为什么呢？因为它要求找到最好的位置作为首都。这种题都有一个特点就是：第一遍求的是根节点跟子树的关系，第二遍求的是该节点跟全树的关系。而且对于这种正向边和反向边变换的问题，我们直接建立双向边，然后如果要改变的话就加上该边的代价。</p>
<h1 id="包含二进制优化的多重背包问题的代码。"><a href="#包含二进制优化的多重背包问题的代码。" class="headerlink" title="包含二进制优化的多重背包问题的代码。"></a>包含二进制优化的多重背包问题的代码。</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c[<span class="number">0</span>]&gt;&gt;d[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i]&gt;&gt;d[i];</span><br><span class="line">        s[i]=a[i]/b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[<span class="number">0</span>]=n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];s[i]-=j,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=j*c[i];k--)&#123;</span><br><span class="line">                f[k]=<span class="built_in">max</span>(f[k],f[k-j*c[i]]+j*d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=s[i]*c[i];k--)&#123;</span><br><span class="line">            f[k]=<span class="built_in">max</span>(f[k],f[k-s[i]*c[i]]+s[i]*d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>差分的前缀和就是修改好的序列。</p>
</blockquote>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P8807">P8807 [蓝桥杯 2022 国 C] 取模</a></p>
</li>
<li>题意：给定 n,m，问是否存在两个不同的数 x,y 使得 1≤x&lt;y≤m 且 n mod x=n mod ⁡y。</li>
<li>思路：每组数据中，若存在 $n \bmod x = n \bmod y$，那么 $n \bmod \operatorname{lcm}(x,y) \le \min (x,y)$。原因显然。<br>而且，当 $m \ge 23$ 时，由于 $\operatorname{lcm}(1,2,\cdots,23) - 1 \gt 10^9$，所以显然有解。我们的暴力只需要依次枚举 $1 \le x \lt y \le 12$ 就可以。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    if(m&gt;n+1)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            if(n%i!=i-1)&#123;//说明它肯定跟前面相等</span><br><span class="line">                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果出现 $n\ mod \ i \not= i-1$，说明肯定跟前面相等。（因为我们就是按顺序枚举的）</p>
</blockquote>
<hr>
<h1 id="注意点总结"><a href="#注意点总结" class="headerlink" title="注意点总结"></a>注意点总结</h1><blockquote>
<p>如果对于某个 $i$ 满足 $a<em>{2i-1}&lt;a</em>{2i}$ 的话，此时式子的第二项是正数的情况下，它对答案的贡献就是 $2*(a<em>{2i-1}-a</em>{2i})$。</p>
<p>multiset 代替线段树来维护增删过程。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;w&gt;&gt;h&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;lx,ly;<span class="comment">//存储切割位置</span></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;x,y;<span class="comment">//x,y储存碎块边长</span></span><br><span class="line"></span><br><span class="line">    x.<span class="built_in">insert</span>(w);</span><br><span class="line">    y.<span class="built_in">insert</span>(h);</span><br><span class="line">    lx.<span class="built_in">insert</span>(<span class="number">0</span>),lx.<span class="built_in">insert</span>(w);</span><br><span class="line">    ly.<span class="built_in">insert</span>(<span class="number">0</span>),ly.<span class="built_in">insert</span>(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            ly.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">auto</span> it=ly.<span class="built_in">find</span>(p);</span><br><span class="line">            --it;</span><br><span class="line">            <span class="type">int</span> l=*it;<span class="comment">//前一条的位置</span></span><br><span class="line">            ++it,++it;</span><br><span class="line">            <span class="type">int</span> r=*it;<span class="comment">//后一条的位置</span></span><br><span class="line">            it=y.<span class="built_in">find</span>(r-l);</span><br><span class="line"></span><br><span class="line">            y.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">            y.<span class="built_in">insert</span>(r-p);</span><br><span class="line">            y.<span class="built_in">insert</span>(p-l);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lx.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">auto</span> it=lx.<span class="built_in">find</span>(p);</span><br><span class="line">            --it;</span><br><span class="line">            <span class="type">int</span> l=*it;</span><br><span class="line">            ++it,++it;</span><br><span class="line">            <span class="type">int</span> r=*it;</span><br><span class="line">            it=x.<span class="built_in">find</span>(r-l);</span><br><span class="line">            x.<span class="built_in">erase</span>(it);</span><br><span class="line">            x.<span class="built_in">insert</span>(r-p);</span><br><span class="line">            x.<span class="built_in">insert</span>(p-l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it=x.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">        <span class="type">int</span> l=*it;</span><br><span class="line">        it=y.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">        <span class="type">int</span> r=*it;</span><br><span class="line">        cout&lt;&lt;(l*r)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>连通性问题考虑方向： flood fill 并查集，dfs。</p>
<p>数字问题可以考虑数位dp和进制，特别注意有的时候如果不能有比如 $4$ 的存在，可以把它转化成九进制问题。</p>
<p>前缀和/异或和常见套路：如果异或和不为0，只要在数组内等于s的块数大于2就说明它可以合并每块使得最后异或和为0。</p>
<p>对于mex a=m，删除 $i（i&lt;m）$，那么代价就是$ (m(cnt-1)+i) $，此时我们的答案是ans=d1<em>(c1-1)+0+d2</em>(c2-1)+1+…+mex a<em>(c_{dk}-1)+dk，=d1</em>c1+d2<em>c2+…+mex a</em>ck-mex a。</p>
<p>gcd 和质数的关系：要使得删去的数最小，也就是保留的数越多，而且gcd要最大，我们可以枚举质数。<strong>拥有共同质数的数的gcd是最大的</strong>。</p>
<p><a href="https://codeforces.com/problemset/problem/1823/C">1823C</a> 当时认为比较难的数论题。</p>
<p>曼哈顿距离结论：曼哈顿距离内的数最多只能填(d+1)*(d+1)个。</p>
<p>倒相加可以规避段数系数限制，也就是：不知道多少段，可以把累乘变成累加。<a href="https://codeforces.com/problemset/problem/1903/C">1903C</a></p>
<p>最大子段区间异或和——tire树。</p>
<p>连续子串想前缀和，转化冒泡排序思想。比如：题目的描述可以改成 $s<em>{r}-s</em>{l-1}$，那么题目还可以转化成有 $k$ 对 $(i,j)$，使得 $s_i&lt;s_j$ 满足条件。</p>
<p>排序类问题要么想到冒泡排序，要么想到它的一些性质，比如本道题的性质就是分别位于首尾的 1 和 n 一定是在最后一次操作中归位的。</p>
<p>树状数组和最近配对点（树状数组可以优化）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> tr[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        v[w[i]+n].<span class="built_in">push_back</span>(i);</span><br><span class="line">        A.<span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">vis</span>(n+n<span class="number">+1</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n*<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;<span class="comment">//这边从右往左可以避免一些不必要的讨论</span></span><br><span class="line">    <span class="comment">//而且你从右往左还有个好处就是中间的一些没有配对的会被配对的移到前面去</span></span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        v[w[i]+n].<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="type">int</span> now=v[-w[i]+n].<span class="built_in">back</span>();</span><br><span class="line">        v[-w[i]+n].<span class="built_in">pop_back</span>();</span><br><span class="line">        vis[now]=<span class="literal">true</span>;</span><br><span class="line">        A.<span class="built_in">add</span>(now,<span class="number">-1</span>);</span><br><span class="line">        ans+=(A.<span class="built_in">query</span>(i<span class="number">-1</span>)-A.<span class="built_in">query</span>(now<span class="number">-1</span>));</span><br><span class="line">        cout&lt;&lt;(A.<span class="built_in">query</span>(i<span class="number">-1</span>)-A.<span class="built_in">query</span>(now<span class="number">-1</span>))&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;<span class="number">0</span>)ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自然数 $\gcd$ 的性质：自然数 $\gcd$ 的性质就是一半一半，一半是1，然后一半的一半是2…</p>
<p>序列配对可以考虑分治（这一部分得单独开专栏），例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ret=<span class="built_in">F</span>(l,mid)+<span class="built_in">F</span>(mid<span class="number">+1</span>,r);</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp1,mp2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&lt;=r;i++)pre[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">+1</span>;i&lt;=r;i++)pre[i]=<span class="built_in">max</span>(pre[i<span class="number">-1</span>],w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">+1</span>;i&lt;=r;i++)mp2[pre[i]-w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid,j=mid<span class="number">+1</span>,mx=<span class="number">0</span>;i&gt;=l;i--)&#123;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,w[i]);</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r&amp;&amp;pre[j]&lt;=mx)mp1[w[j]]++,mp2[pre[j]-w[j]]--,j++;</span><br><span class="line">        ret+=mp1[mx-w[i]]+mp2[w[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">F</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>树kruskal 删边变成树</p>
<p>有跳跃可以考虑dp、建图、dsu。</p>
</blockquote>
<hr>
<p>终于完结了，累死我了</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>abc137</title>
    <url>/2025/01/13/abc137/</url>
    <content><![CDATA[<h1 id="A-x"><a href="#A-x" class="headerlink" title="A. +-x"></a>A. +-x</h1><ul>
<li>模拟题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(&#123;a+b,a*b,a-b&#125;)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-One-Clue"><a href="#B-One-Clue" class="headerlink" title="B. One Clue"></a>B. One Clue</h1><ul>
<li>模拟题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x-k<span class="number">+1</span>;i&lt;=x+k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Green-Bin"><a href="#C-Green-Bin" class="headerlink" title="C. Green Bin"></a>C. Green Bin</h1><ul>
<li><p>题意：给出变位词概念，叫我们求出变位词对的个数。</p>
</li>
<li><p>解题：变位词本质上就是排完序是同一个单词，然后通过交换其中几个词。题目要求变位词对的个数，我们可以先统计排完序单词的个数，然后按照组合数 $C_{cnt}^{2}$ 来计算最后的答案即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        S[s]++;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x,y]:S)ans+=(y<span class="number">-1</span>)*y/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Summer-Vacation"><a href="#D-Summer-Vacation" class="headerlink" title="D. Summer Vacation"></a>D. Summer Vacation</h1><ul>
<li><p>题意：有 $n$ 个工会，如果你接受第 $i$ 个工作并完成它，你将在完成当天之后的 $A_i$ 天内获得奖励 $B_i$ 并且每天最多只能接受并完成一个工作，同时不能重新接受已经完成过的工作，求不迟于 $M$ 天内能获得的最大奖励数。</p>
</li>
<li><p>解题：要求最大奖励数，其实可以想到：尽可能选时间短的奖励多的，因此可以先对 $A_i$ 从小到大排序。那么之后我们肯定是尽可能选奖励多的，因此我们可以开一个大顶堆，把所有截至到第 $i$ 天之前的奖励数全部放入堆中，然后取出最大的即可。这样就能保证我们的贪心是正确的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].x&gt;&gt;w[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;=n&amp;&amp;w[t].x&lt;=i)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(w[t++].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res+=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是具有二维变量的贪心，有的时候可能是用 <code>dp</code> 去做，但本题数据规模较大，因此得想到贪心，这种常见的思路一般是先定一个顺序然后另一个顺序可以用类似 <strong>双指针</strong>、<strong>单调队列</strong>、<strong>堆</strong> 等优化和计算。</p>
</blockquote>
<h1 id="E-Coins-Respawn"><a href="#E-Coins-Respawn" class="headerlink" title="E. Coins Respawn"></a>E. Coins Respawn</h1><ul>
<li><p>题意：给你一张图，你从 $1$ 号点出发，要到 $n$ 号点，图上的每一条边都有硬币，你要收集它们，当然当你收集了一次之后在这条边又会出现这个硬币。最后到 $n$ 号节点时要上交 $T\times P$ 个硬币，其中 $T$ 是走的时间，$P$ 是给定值。求最后获得到的硬币数最多是多少。</p>
</li>
<li><p>思路：因为最后都要上交 $T\times P$ 个硬币，那不如简化运算，然所有权值都减去 $P$，这样最后就可以不用上交了。然后我们再考虑什么情况下会无解，也就是答案无限大的情况，那就是有一个边权和为正数的环与<strong>点 $n$ 联通</strong>，这里就先建立个反图，从 $n$ 出发，标记能走到的点，然后 spfa 的时候不去松弛它们，这样就能保证用spfa判断正环的时候包括 $n$ 这个点了（<strong>很重要，要不然过不了第三个测试点</strong>）。然后要求最大的答案，此时就是求从 $1\rightarrow n$ 的最长路，注意这里有可能有负权边，因此必须用 <code>spfa</code>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,p;</span><br><span class="line">vector&lt;PII&gt;G[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">bool</span> vis[N],st[N];</span><br><span class="line"><span class="type">int</span> cnt[N],dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[u])<span class="built_in">dfs</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>,st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,w]:G[t])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w)&#123;</span><br><span class="line">                dist[j]=dist[t]+w;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    cnt[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[j]&gt;n)&#123;</span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b,c-p);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(n);</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(dist[n],<span class="number">0ll</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看似简单，实则细节满满。</p>
</blockquote>
<h1 id="F-Polynomial-Construction-构造-多项式"><a href="#F-Polynomial-Construction-构造-多项式" class="headerlink" title="F. Polynomial Construction 构造+多项式"></a>F. Polynomial Construction 构造+多项式</h1><ul>
<li><p>题意：给出长度为 $p$ 的 $01$ 序列 $a$, 构造 $f(x)=\sum\limits_{i=0}^{p-1} b_i x^i$，满足 $f(i) \equiv a_i \pmod{p}$。</p>
</li>
<li><p>思路：可以看出 $f(x)$ 是一个多项式，此时可以考虑二项展开式。又因为此时的 $a$ 只有 $01$ 两种取值，因此可以：在 $a<em>x = 1$ 时构造一个函数 $g(i)$ 使 $i = x$ 时 $g(i) = 1$，$i \not = x$ 时 $g(i)=0$。这样使求和后只对 $f(x)$ 产生影响。由于题目要求是在模意义下（又因为 $p$ 为质数），且值为 $1$，可以考虑用费马小定理构造出 $g(i) = 1 - (i-x)^{p-1}$，后面的 $(i-x)^{p-1}$ 用二项式定理展开得 $\displaystyle\sum</em>{j=0}^{p-1} \binom{p-1}{j}i^{p-j-1}(-x)^i$。</p>
</li>
</ul>
<p><a href="https://www.luogu.com.cn/article/ht3daoip">思路参考</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)C[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(!a[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> f[N]=&#123;<span class="number">1</span>&#125;,now[N]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;p;j++)f[j]=(f[j<span class="number">-1</span>]*i)%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((p-j)&amp;<span class="number">1</span>)now[j]=(C[p<span class="number">-1</span>][j]*f[p<span class="number">-1</span>-j])%p;</span><br><span class="line">            <span class="keyword">else</span> now[j]=-(C[p<span class="number">-1</span>][j]*f[p<span class="number">-1</span>-j])%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p;j++)b[j]=(b[j]-now[j]+p)%p;</span><br><span class="line">        b[<span class="number">0</span>]=(b[<span class="number">0</span>]<span class="number">+1</span>)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多项式练少了，想不到这方面。</p>
</blockquote>
]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>VP Codeforces Round 786 (Div. 3)</title>
    <url>/2025/02/20/VP-Codeforces-Round-786-Div-3/</url>
    <content><![CDATA[<h1 id="A-Number-Transformation"><a href="#A-Number-Transformation" class="headerlink" title="A. Number Transformation"></a>A. Number Transformation</h1><ul>
<li>题意：给定两个整数 $x,y$，选择 $a,b$ 整数使得 $a\rightarrow b$。</li>
<li>思路：1.如果 $x=y$，输出 $3 \ 1$，如果 $x\not|y$，输出 $0 \ 0$，其他就直接输出 $k \ 1$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(y%x)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;3 1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k=y/x;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Dictionary"><a href="#B-Dictionary" class="headerlink" title="B. Dictionary"></a>B. Dictionary</h1><ul>
<li>题意：观察，求索引值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Word 1 : ab</span><br><span class="line">Word 2 : ac</span><br><span class="line">...</span><br><span class="line">Word 25 : az</span><br><span class="line">Word 26 : ba</span><br><span class="line">Word 27 : bc</span><br><span class="line">...</span><br><span class="line">Word 649 : zx</span><br><span class="line">Word 650 : zy</span><br></pre></td></tr></table></figure></li>
<li>思路：相同的字母会被舍去，因此如果前一个字母大于后一个字母的情况下，此时正常算，反之+1。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">string a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k=<span class="number">26</span>*(a[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)+a[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>-(a[<span class="number">1</span>]&gt;a[<span class="number">0</span>]?(a[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>):(a[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Infinite-Replacement"><a href="#C-Infinite-Replacement" class="headerlink" title="C. Infinite Replacement"></a>C. Infinite Replacement</h1><ul>
<li>题意：给一个只含小写字母 a 的字符串 s 和一个用来替换的字符串 t 。你可以将 s 中任意一个字母 a 用 t 来替换，替换的次数不限。对于每一个 s 和 t ，你可以得到几个不同的字符串？如果有无限个，输出 -1 。</li>
<li>思路：分类讨论：如果 $t=a$，此时不管怎样替换，$s$ 不会发生变化。如果 t 包含 a 这个字母的话，此时就是无限大，反之就是 $2^{(s.size())}$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s,t;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="string">&quot;a&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                f=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="number">1ll</span>&lt;&lt;s.<span class="built_in">size</span>();</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-A-B-C-Sort"><a href="#D-A-B-C-Sort" class="headerlink" title="D. A-B-C Sort"></a>D. A-B-C Sort</h1><ul>
<li>题意：你有三个数组 a,b,c，a 初始有 n 个元素，b 和 c 初始是空的。你可以执行以下算法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步，当 a 不为空，重复从 a 取出末尾的元素并将其插入 b 的正中间。如果 b 当前有奇数个元素，可以选择将 a 中取出的元素插入 b 正中间元素紧挨着的左侧或右侧的空位上。</span><br><span class="line"></span><br><span class="line">在此之后 a 变成空的，b 有 n 个元素。</span><br><span class="line"></span><br><span class="line">第二步，当 b 不为空，重复取出 b 正中间的元素并将其插入 c 的末尾。如果 b 当前有偶数个元素，可以选择从正中间两个元素中取出一个。</span><br><span class="line"></span><br><span class="line">在此之后 b 变成空的，c 有 n 个元素。</span><br></pre></td></tr></table></figure></li>
<li>思路：容易看出，当 b 长度为奇数时，将 a 数组中的元素插入 b 数组，有 2 种情况，可以插在前面，也可以插在后面。然后从 b 数组中取出，放到 c 数组时，与上面的情况，要么这两个数非降序，要么反之。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c的任意两个相邻的数就是a中相邻的数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=(n&amp;<span class="number">1</span>)<span class="number">+1</span>;i-=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;w[i<span class="number">-1</span>])<span class="built_in">swap</span>(w[i],w[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;w[i<span class="number">+1</span>])f=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(f?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Breaking-the-Wall"><a href="#E-Breaking-the-Wall" class="headerlink" title="E. Breaking the Wall"></a>E. Breaking the Wall</h1><p>- </p>
]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>整理（正在施工）</title>
    <url>/2025/02/14/%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>待施工</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>abc377</title>
    <url>/2025/01/30/abc377/</url>
    <content><![CDATA[<h1 id="A-Rearranging-ABC"><a href="#A-Rearranging-ABC" class="headerlink" title="A. Rearranging ABC"></a>A. Rearranging ABC</h1><ul>
<li><p>题意：求给定的字符串是不是 <code>ABC</code>。</p>
</li>
<li><p>思路：直接判断。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        S[x]++;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[<span class="string">&#x27;A&#x27;</span>]==<span class="number">1</span>&amp;&amp;S[<span class="string">&#x27;B&#x27;</span>]==<span class="number">1</span>&amp;&amp;S[<span class="string">&#x27;C&#x27;</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Avoid-Rook-Attack"><a href="#B-Avoid-Rook-Attack" class="headerlink" title="B. Avoid Rook Attack"></a>B. Avoid Rook Attack</h1><ul>
<li>题意：一个棋子在图中记为 <code>*</code>，跟它同一行或同一列不能放 <code>*</code>，问还有几个方格能放棋子。</li>
<li>思路：因为 $n$ 很小，直接暴力枚举整张图，把能被覆盖到的标记，此时剩下的就是答案。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n=<span class="number">8</span>;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                t.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:t)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            vis[x][i]=<span class="number">1</span>;</span><br><span class="line">            vis[i][y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ans+=(vis[i][j]==<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Avoid-Knight-Attack"><a href="#C-Avoid-Knight-Attack" class="headerlink" title="C. Avoid Knight Attack"></a>C. Avoid Knight Attack</h1><ul>
<li><p>题意：一个棋子可以像中国象棋的 “马” 那样走 “日” 覆盖，问图中没有被棋子覆盖的地方的方格数。</p>
</li>
<li><p>思路：直接用 <code>set</code> 去维护每个棋子能覆盖到的点，因为 <code>set</code> 自带去重功能，最后直接把棋盘大小减去 <code>set</code> 的元素的个数就是答案。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    set&lt;PII&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> x=a+dx[j],y=b+dy[j];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>||x&gt;n||y&gt;n)<span class="keyword">continue</span>;</span><br><span class="line">            S.<span class="built_in">insert</span>(&#123;x,y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        S.<span class="built_in">insert</span>(&#123;a,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;((<span class="type">long</span> <span class="type">long</span>)n*n-(<span class="type">long</span> <span class="type">long</span>)S.<span class="built_in">size</span>())&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Many-Segments-2"><a href="#D-Many-Segments-2" class="headerlink" title="D.  Many Segments 2"></a>D.  Many Segments 2</h1><ul>
<li><p>题意：给定 $n$ 个区间，求出区间 $[l,r]$ 不完全包含区间 $[L_i,R_i]$ 的区间个数。</p>
</li>
<li><p>思路：因为数据规模比较大，对于这种求个数的问题可以考虑贡献法。然后我们又发现了：如果固定 $l$ 的话，它的答案是取决于所有 $L_i&gt;=l$ 的区间中 $R_i$ 最小的。此时我们用双指针来做，此时从大到小枚举 $l$ 的时候（为什么从大到小，因为你更新最小值的时候肯定是从大到小来维护的），$L_i&gt;=l$ 的区间会逐渐变多，此时统计右端点即可，然后每次更新一下最小值即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lst=m<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">1</span>&amp;&amp;w[j].fi&gt;=i)&#123;</span><br><span class="line">            lst=<span class="built_in">min</span>(lst,w[j].se);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=(lst-i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Permute-K-times-2"><a href="#E-Permute-K-times-2" class="headerlink" title="E. Permute K times 2"></a>E. Permute K times 2</h1><ul>
<li><p>题意：给定排列，然后每次操作将 $P<em>i$ 更新为 $P</em>{P_i}$，问第 $k$ 次操作 $P$ 的结果。</p>
</li>
<li><p>思路：对于这种题，可以考虑结合图来做，也就是画图。通过画图，可以很容易知道最后肯定会形成一个环，具体字怎么画呢？就是将 $P<em>i$ 与 $P</em>{P_i}$ 连边。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/lnswgoyg.png" alt=""></p>
</li>
<li><p>通过手算可以知道：它的第一个数在 $5$ 次操作的值是 $5,2,4,6,5$，解释一下就是：操作一次从 $5\rightarrow 2$，也就是走一步；然后第二次操作从 $2\rightarrow 4$，在图上走两步。以此类推，若要一个数按题目要求变换 $k$ 次，那么它的值将变为它向箭头方向走 $k-1$ 步的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    a[cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        g[i].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])cnt++,<span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="built_in">qmi</span>(<span class="number">2</span>,k,(<span class="type">int</span>)a[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            w[a[i][j]]=a[i][(j+s)%(<span class="type">int</span>)a[i].<span class="built_in">size</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;w[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Avoid-Queen-Attack"><a href="#F-Avoid-Queen-Attack" class="headerlink" title="F. Avoid Queen Attack"></a>F. Avoid Queen Attack</h1><ul>
<li><p>题意：对于一个棋子，它可以覆盖的范围类似 “米” 字形。给定一张图，问最后可以放棋子的格子数。</p>
</li>
<li><p>思路：如果是十字的话还好做，但这道题有对角线，因此对于对角线，我们可以取个巧，就是让 $x+y$ 作为 <code>/</code> 形对角线，让 $x-y$ 最为 <code>\</code> 形对角线，那么对于 <code>/</code> 对角线的取值范围就是 $[n+1,2n]$，对于 <code>\</code> 对角线的取值范围就是 $[0,n-1]$ 。此时我们可以先去让 <code>\</code> 形对角线满足条件，因为 <code>/</code> <code>\</code> 会有交点。这样的话我们可以先把十字形的先去掉，也就是先把十字形覆盖的格数算出来，从剩下的个数进行对角线的选择。然后根据 <code>*</code> 的横坐标、纵坐标和 <code>\</code> 形对角线，此时要看 <code>\</code> 形对角线能覆盖到哪里，可以算：（比如现在是已知横坐标和对角线去求 $y$ 就是 $d=x-y$ =&gt; $y=x-d$，然后最后的答案假如对于某个 <code>\</code> 对角线，是把对角线长度 $n-d$ 减去被对角线覆盖到的格子数（已经被覆盖到的格子数））。当开始枚举另一边的时候得注意：中间重复部分，此时可以列出方程 $a=x-y,b=x+y$ 解得：$x=(a+b)/2,y=(b-a)/2$，注意 $x,y$ 均为整数,如果能整除的话说明有交点，反之没有。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        ht.<span class="built_in">insert</span>(a);</span><br><span class="line">        vt.<span class="built_in">insert</span>(b);</span><br><span class="line">        zhu.<span class="built_in">insert</span>(a-b);</span><br><span class="line">        fu.<span class="built_in">insert</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=(n-ht.<span class="built_in">size</span>())*(n-vt.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> d:zhu)&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;cs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:ht)&#123;</span><br><span class="line">            <span class="type">int</span> y=x-d;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:vt)&#123;</span><br><span class="line">            <span class="type">int</span> x=d+y;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num=cs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len_d=n-<span class="built_in">abs</span>(d);</span><br><span class="line">        ans-=(len_d-num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:fu)&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;cs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:ht)&#123;</span><br><span class="line">            <span class="type">int</span> y=e-x;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:vt)&#123;</span><br><span class="line">            <span class="type">int</span> x=e-y;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:zhu)&#123;</span><br><span class="line">            <span class="type">int</span> x=(d+e)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> y=(e-d)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((e+d)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=cs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len_d=n-<span class="built_in">abs</span>(e-(n<span class="number">+1</span>));</span><br><span class="line">        ans-=(len_d-num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G-Edit-to-Match"><a href="#G-Edit-to-Match" class="headerlink" title="G.  Edit to Match"></a>G.  Edit to Match</h1><ul>
<li><p>题意：给你 $n$ 个字符串，记 $s_0$ 为空，对于每个字符串 $i\in[1,n]$，求通过删除/添加后缀字母的操作，最少需要操作多少次使得 $s_i=s_k,k\in[0,i-1]$。</p>
</li>
<li><p>思路：这就是很典型的字符串匹配，对于字符串的前缀匹配，可以考虑字典树。将每个数插入到类似于 <code>trie</code> 树的东西上，再用 $en_i$ 数组记录离这个节点最近的结尾字符，代价即为：$en_p+n-i+1$，取最小值即可。其中 $en_i$ 就是 <code>cnt</code> 数组。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,n=s.<span class="built_in">size</span>();</span><br><span class="line">    ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[p][u]==<span class="number">0</span>)tr[p][u]=++idx;</span><br><span class="line">        p=tr[p][u];</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,cnt[p]+n-i<span class="number">-1</span>);</span><br><span class="line">        cnt[p]=<span class="built_in">min</span>(cnt[p],n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    cnt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点系列——数据结构</title>
    <url>/2025/02/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h1><ul>
<li>概念： 给定一棵无向树，包含 $n$ 个点 $n-1$ 条边，在树中任意两个点之间加一条边，此时树中<strong>有且仅有</strong>一个环，此时整棵树的形状应该是以环为中心，环上每个点都可能向环外延伸出一棵子树，这就是一棵基环树。</li>
<li>性质：</li>
</ul>
<ol>
<li>对于每棵基环树，恰好有 $n$ 个点 $n$ 条边。</li>
<li>可以发现，仙人掌是有多个简单环，而基环树只有一个简单环，因此基环树其实是一个特殊的仙人掌。</li>
<li>如果给基环树中每条边一个方向，环上边的方向都要一致，如果以环上每个点为根的子树上的边都是指向环外，则称为外向树。如果以环上每个点为根的子树上的边都是指向环内，则称为内向树。</li>
<li>若干棵基环树构成的图，被称为基环（树）森林。若干棵外向树构成的图，被称为外向树森林。若干棵内向树构成的图，被称为内向树森林。</li>
<li>对于一张图，如果图中每个点恰好有 $1$ 条入边或恰好有 $1$ 条出边，那么这张图一定是一个基环森林。</li>
</ol>
<p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/7958357/">参考</a></p>
<ul>
<li>应用：基环树问题的常见题型就是求树上的某些信息。</li>
</ul>
<h2 id="P1399-NOI2013-快餐店"><a href="#P1399-NOI2013-快餐店" class="headerlink" title="P1399 [NOI2013] 快餐店"></a>P1399 [NOI2013] 快餐店</h2><ul>
<li><p>题意：给定一张图，包含 $n$ 个点，每个点都有一个父节点。让你在某一处（可以在点上，也可以在边上）安置一个快餐店使得整张图上离它最远的点最近。</p>
</li>
<li><p>思路：根据<strong>每个点都有一个父节点</strong>可以知道：这张图是基环树。要求与最远的顾客之间的距离，那么我们肯定很容易想到在树的直径的终点放快餐店。由于这张图是基环树，有一个朴素的想法：我们可以考虑每次破掉环上的一条边使它变成一颗树，然后求出直径，最后统计所有的直径中最短的那个作为答案即可。但这个的时间复杂度是 $O(n^2)$，此时考虑优化：我们先考虑整个图上的直径可能存在的情况：1.这个直径完全在环上某一点所在的子树中。2.这个直径从环上某一点所在子树出发，到达该点后在环上走过一些边到达另一个点，进入该点所在子树并且结束。此时第一种情况就比较好算，直接维护每一颗子树的直径即可。对于第二种情况，我们容易发现直径在某个子树内的部分一定是从该子树的根出发的最长路径，也就是该树的<strong>最大深度</strong>。所以我们预先处理环上所有点所在子树的深度。然后通过预处理出 $A,B,C,D$ 数组，然后再通过切断环上第 $i$ 号点求直径（$B<em>i,D_i,A_i+C</em>{i+1}+tmp$）<a href="https://www.luogu.com.cn/article/qm5qkbsm">具体的ABCD什么意思这篇文章讲的很清楚</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt;G[N];</span><br><span class="line"><span class="type">int</span> din[N],fa[N],w[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> inc[N],cv[N],cw[N],cnt;</span><br><span class="line"><span class="type">double</span> ans1,ans2=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">double</span> A[N],B[N],C[N],D[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,v]:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">        fa[j]=u,w[j]=v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(j))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> p=u;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                inc[p]=<span class="number">1</span>,cv[++cnt]=p;</span><br><span class="line">                cw[cnt]=w[p];</span><br><span class="line">                p=fa[p];</span><br><span class="line">                <span class="keyword">if</span>(p==u)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,v]:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=fa&amp;&amp;!inc[j])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j,u);</span><br><span class="line">            ans1=<span class="built_in">max</span>(ans1,d[u]+d[j]+v);</span><br><span class="line">            d[u]=<span class="built_in">max</span>(d[u],d[j]+v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        G[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(cv[i],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//断开(1,cnt)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        sum+=cw[i<span class="number">-1</span>];</span><br><span class="line">        A[i]=<span class="built_in">max</span>(A[i<span class="number">-1</span>],sum+d[cv[i]]);<span class="comment">//前缀中链长度+节点深度</span></span><br><span class="line">        B[i]=<span class="built_in">max</span>(B[i<span class="number">-1</span>],mx+sum+d[cv[i]]);<span class="comment">//前缀中两棵树的深度+两节点的距离</span></span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum=mx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> cn=cw[cnt];</span><br><span class="line">    cw[cnt]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        sum+=cw[i];</span><br><span class="line">        C[i]=<span class="built_in">max</span>(C[i<span class="number">+1</span>],sum+d[cv[i]]);</span><br><span class="line">        D[i]=<span class="built_in">max</span>(D[i<span class="number">+1</span>],mx+sum+d[cv[i]]);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)&#123;<span class="comment">//枚举断开环边拼凑答案</span></span><br><span class="line">        res=<span class="built_in">max</span>(&#123;B[i],D[i<span class="number">+1</span>],A[i]+C[i<span class="number">+1</span>]+cn&#125;);</span><br><span class="line">        ans2=<span class="built_in">min</span>(ans2,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans2=<span class="built_in">min</span>(ans2,B[cnt]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1Lf&quot;</span>,<span class="built_in">max</span>(ans1,ans2)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P5022-NOIP-2018-提高组-旅行"><a href="#P5022-NOIP-2018-提高组-旅行" class="headerlink" title="P5022 [NOIP 2018 提高组] 旅行"></a>P5022 [NOIP 2018 提高组] 旅行</h2><ul>
<li><p>题意：给定一个基环树，求第一次去到每个点的字典序最小的编号顺序。</p>
</li>
<li><p>思路：如果是普通的树（$n=m+1$），我们直接走字典序小的点就可以了，这部分可以对每个点的出边进行排序即可。如果是基环树（$n\not=m+1$），可以考虑暴力删边，此时就是将基环树转化成普通树，然后对于每一次暴力删边的结果进行深搜遍历。（时间复杂度 $O(n^2)$）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力删边即可对于基环树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> path[N],better,cnt;</span><br><span class="line">PII e[N];</span><br><span class="line"><span class="type">int</span> du,dv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!better)&#123;</span><br><span class="line">        <span class="comment">//若序号变大则退回，变小则走完</span></span><br><span class="line">        <span class="keyword">if</span>(u&gt;path[cnt])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&lt;path[cnt])better=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    path[cnt++]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(v==du&amp;&amp;u==dv)<span class="keyword">continue</span>;<span class="comment">//遇到断边</span></span><br><span class="line">        <span class="keyword">if</span>(v==dv&amp;&amp;u==du)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(v))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//枚举断点</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">        e[i]=&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(),G[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==m<span class="number">+1</span>)<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            du=e[i].x,dv=e[i].y;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">            cnt=better=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树上启发式合并-dsu-on-tree"><a href="#树上启发式合并-dsu-on-tree" class="headerlink" title="树上启发式合并 dsu on tree"></a>树上启发式合并 dsu on tree</h1><ul>
<li><p>概念：首先得知道轻子树和重子树概念（树链剖分）。</p>
</li>
<li><p>使用场景: 1.统计/查询一颗树所有子树内节点的信息。2.每次要合并两个集合的时候，我们可以每次把较小集合的元素合并到较大集合中去，这样就能保证时间复杂度为：$O(nlogn)$。</p>
</li>
</ul>
<blockquote>
<p>也就是：只支持子树查询，不支持修改操作。</p>
</blockquote>
<ul>
<li><p>原理：贪心。</p>
</li>
<li><p>性质：</p>
</li>
</ul>
<ol>
<li>一个点总是有1个重儿子, 除了叶子节点。</li>
<li>一个点可能是父节点的重儿子, 但不一定再重链上。</li>
<li>一个点至多往上走logn步就被合并到重链。</li>
</ol>
<ul>
<li><p>实现方法：对于每个节点, 总是先统计 ”轻” 子树, 并将桶清空, 最后统计 ”重” 子树, 并将桶保留。（这样能保证时间复杂度是 $O(nlogn)$，都是把轻子树合并到重子树中去）</p>
</li>
<li><p>步骤：</p>
</li>
</ul>
<ol>
<li>先跑重链剖分，预处理出每个节点的重儿子;</li>
<li>dfs，对于节点 <code>u</code>，总是先统计轻子树的信息，再统计重子树信息，最后统计 <code>u</code> 的信息。看情况清空桶。</li>
<li>通常需要预处理将询问离线。</li>
</ol>
<p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/12548702/">参考</a></p>
<h2 id="CF600E-Lomsat-gelral"><a href="#CF600E-Lomsat-gelral" class="headerlink" title="CF600E Lomsat gelral"></a>CF600E Lomsat gelral</h2><ul>
<li><p>题意：求出以 $i$ 为根的子树中，占主导颜色（出现次数最多）的编号和。</p>
</li>
<li><p>思路：暴力搜索 $O(n^2)$，采取启发式合并。</p>
</li>
<li><p>具体做法：用 <code>cnt[i]</code> 记录颜色 <code>i</code> 的出现次数，对于节点 <code>u</code>，此时：</p>
</li>
</ul>
<ol>
<li><p>先遍历 <code>u</code> 的轻儿子，计算答案，但不保留它对答案的贡献（目的是更快的算重儿子的贡献）</p>
</li>
<li><p>遍历 <code>u</code> 的重儿子，保留贡献。</p>
</li>
<li><p>再遍历轻儿子。</p>
</li>
</ol>
<blockquote>
<p>注意：为什么不合并1、3步呢？</p>
<p>答：因为我们要重复使用 <code>cnt</code> 数组，且对于 <code>A</code> 子树不能影响 <code>B</code> 子树。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line"><span class="type">int</span> son[N],siz[N],cnt[N];</span><br><span class="line"><span class="type">int</span> sum,ans[N],mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j,u);</span><br><span class="line">        siz[u]+=siz[j];</span><br><span class="line">        <span class="keyword">if</span>(siz[son[u]]&lt;siz[j])&#123;</span><br><span class="line">            son[u]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> son)</span></span>&#123;</span><br><span class="line">    cnt[c[u]]++;</span><br><span class="line">    <span class="keyword">if</span>(cnt[c[u]]&gt;mx)mx=cnt[c[u]],sum=c[u];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt[c[u]]==mx)sum+=c[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=fa&amp;&amp;j!=son)<span class="built_in">add</span>(j,u,son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    cnt[c[u]]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=fa)<span class="built_in">sub</span>(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这边保留重儿子是因为轻儿子的贡献已经算在了重儿子内部（也就是合并了），因此要把轻儿子的贡献删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> opt)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先搜索轻儿子再到重儿子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa||j==son[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j,u,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[u])<span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add</span>(u,fa,son[u]);<span class="comment">//累加贡献（轻儿子和u的）</span></span><br><span class="line">    ans[u]=sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!opt)<span class="built_in">sub</span>(u,fa),sum=mx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CF1709E-XOR-Tree"><a href="#CF1709E-XOR-Tree" class="headerlink" title="CF1709E XOR Tree"></a>CF1709E XOR Tree</h2><ul>
<li><p>题意：定义一条路径 $P(u,v)$ 的权值为经过的所有点的点权的异或和，定义一棵树是合法的，当且仅当树上所有简单路径（只经过每个点一次的路径）的的权值都不为 $0$。你可以对权值进行修改，可以改成任意正整数，问最少修改多少次才能让这棵树合法。</p>
</li>
<li><p>思路：首先我们可以用前缀和来维护树上的异或关系。根据贪心我们可以知道：修改路径上 <code>lca</code> 的就能满足最小的条件。最后推导得到式子：<code>d[u]=d[v]^a[x]</code>（这个是非法路径），其中 <code>x</code> 为 <code>lca(u,v)</code>，<code>d[u]</code> 表示从根 $1$ 到 $u$ 的路径上所有点权的疑惑和，<code>a[u]</code> 表示 $u$ 的点权。那么此时我们只要把 $x=lca(u,v)$ 的点权改为很大的整数，就可以消除所有经过 $x$ 点的非法路径。即 $x$ 点相对于一个端点，对于代码上来说，就是把以 $x$ 为根的子树从桶中清空。具体实现就是：如果发现经过当前子树根的非法路径，直接答案+1，并清空当前子树的集合，如果没有发现，则把小集合合并到大集合中。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N],d[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt;S[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    S[u].<span class="built_in">insert</span>(d[u]);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[j]=d[u]^w[j];</span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(S[u].<span class="built_in">size</span>()&lt;S[j].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">swap</span>(S[u],S[j]);<span class="comment">//保证u是大集合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> z:S[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[u].<span class="built_in">find</span>(z^w[u])!=S[u].<span class="built_in">end</span>())f=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> z:S[j])&#123;</span><br><span class="line">            S[u].<span class="built_in">insert</span>(z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f)ans++,S[u].<span class="built_in">clear</span>();<span class="comment">//算完之后得清空数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是说：启发式合并不是一成不变的，它只是个优化算法，没有固定的模板。</p>
</blockquote>
<h1 id="线段树-树状数组"><a href="#线段树-树状数组" class="headerlink" title="线段树/树状数组"></a>线段树/树状数组</h1><ul>
<li>用法：可以用在区间查询区间修改的操作中。</li>
</ul>
<h2 id="P2572-SCOI2010-序列操作"><a href="#P2572-SCOI2010-序列操作" class="headerlink" title="P2572 [SCOI2010] 序列操作"></a>P2572 [SCOI2010] 序列操作</h2><ul>
<li>题意：给定如下操作：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 l r 把 [l,r] 区间内的所有数全变成 0；</span><br><span class="line">1 l r 把 [l,r] 区间内的所有数全变成 1；</span><br><span class="line">2 l r 把 [l,r] 区间内的所有数全部取反，也就是说把所有的 0 变成 1，把所有的 1 变成 0；</span><br><span class="line">3 l r 询问 [l,r] 区间内总共有多少个 1；</span><br><span class="line">4 l r 询问 [l,r] 区间内最多有多少个连续的 1。</span><br></pre></td></tr></table></figure></li>
<li>思路：线段树，但本道题有取反和赋值两个操作，此时就得开两个懒标记。对于有两个懒标记的情况，就得考虑优先级：<strong>一般来说：赋值标记优先级高于取反标记</strong>。然后要求区间内连续的 <code>1</code> ，就得添加 <code>lsum,rsum,tsum</code> 变量来求。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> b,lb,rb,mb;</span><br><span class="line">    <span class="type">int</span> c,lc,rc,mc;</span><br><span class="line">    <span class="type">int</span> len,tag,rev;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(E&amp; u,E l,E r)</span></span>&#123;</span><br><span class="line">    u.b=l.b+r.b;</span><br><span class="line">    u.lb=l.c?l.lb:l.b+r.lb;</span><br><span class="line">    u.rb=r.c?r.rb:r.b+l.rb;</span><br><span class="line">    u.mb=<span class="built_in">max</span>(&#123;l.mb,r.mb,l.rb+r.lb&#125;);</span><br><span class="line">    u.c=l.c+r.c;</span><br><span class="line">    u.lc=l.b?l.lc:l.c+r.lc;</span><br><span class="line">    u.rc=r.b?r.rc:r.c+l.rc;</span><br><span class="line">    u.mc=<span class="built_in">max</span>(&#123;l.mc,r.mc,l.rc+r.lc&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> opt)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">        t.b=t.lb=t.rb=t.mb=<span class="number">0</span>;</span><br><span class="line">        t.c=t.lc=t.rc=t.mc=t.len;</span><br><span class="line">        t.tag=t.rev=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">        t.b=t.lb=t.rb=t.mb=t.len;</span><br><span class="line">        t.c=t.lc=t.rc=t.mc=<span class="number">0</span>;</span><br><span class="line">        t.tag=<span class="number">1</span>,t.rev=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(t.b,t.c),<span class="built_in">swap</span>(t.lb,t.lc);</span><br><span class="line">        <span class="built_in">swap</span>(t.rb,t.rc),<span class="built_in">swap</span>(t.mb,t.mc);</span><br><span class="line">        t.rev^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u],tr[u&lt;&lt;<span class="number">1</span>],tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">0</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">1</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(t.rev)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    t.tag=<span class="number">-1</span>;</span><br><span class="line">    t.rev=<span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=c[l];</span><br><span class="line">    tr[u]=&#123;l,r,t,t,t,t,t^<span class="number">1</span>,t^<span class="number">1</span>,t^<span class="number">1</span>,t^<span class="number">1</span>,r-l<span class="number">+1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    E res;</span><br><span class="line">    <span class="built_in">pushup</span>(res,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l++,r++;</span><br><span class="line">        <span class="keyword">if</span>(op&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,r,op);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            E t=<span class="built_in">query</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">                cout&lt;&lt;t.b&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;t.mb&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1972-SDOI2009-HH的项链"><a href="#P1972-SDOI2009-HH的项链" class="headerlink" title="P1972 [SDOI2009] HH的项链"></a>P1972 [SDOI2009] HH的项链</h2><ul>
<li><p>题意：询问某一段贝壳中，包含了多少种不同的贝壳。</p>
</li>
<li><p>思路：对于给定区间询问，往往有两种方式查询：<strong>在线查询、离线查询</strong>。很明显，本题离线查询更优，因为离线查询可以给查询排序，这样可以用类似双指针的思想来查询，大大降低时间复杂度。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于区间查询问题，要么在线处理，要么离线处理</span></span><br><span class="line"><span class="comment">//显然，本道题离线处理能减小时间复杂度</span></span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r&lt;t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        e[i]=&#123;l,r,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=last;j&lt;=e[i].r;j++)&#123;<span class="comment">//重叠部分被算过，因此不需要再跳到重叠部分</span></span><br><span class="line">            <span class="keyword">if</span>(vis[w[j]])<span class="built_in">add</span>(vis[w[j]],<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">add</span>(j,<span class="number">1</span>);</span><br><span class="line">            vis[w[j]]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        last=e[i].r<span class="number">+1</span>;</span><br><span class="line">        ans[e[i].id]=<span class="built_in">query</span>(e[i].r)-<span class="built_in">query</span>(e[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P4344-SHOI2015-脑洞治疗仪-线段树-二分"><a href="#P4344-SHOI2015-脑洞治疗仪-线段树-二分" class="headerlink" title="P4344 [SHOI2015] 脑洞治疗仪 线段树+二分"></a>P4344 [SHOI2015] 脑洞治疗仪 线段树+二分</h2><ul>
<li><p>题意：我们将大脑视作一个 01 序列，求出在大脑某个区间中最大的连续脑洞区域有多大。同时给出脑洞的治疗仪的使用方式：仅会尽量填补位置比较靠前的脑洞。（也就是把一段区间的 $1$ 的个数全部添加到另一段区间内）</p>
</li>
<li><p>思路：可以把题目转化成对于操作1 $[l_0,r_0]=0，[l_1,r_1]=1$，设 $[l_0,r_0]$ 有 $x$ 个 $1$ ，$[l_1,r_1]$ 有 $y$ 个 $0$，也就是需要在 $[l_1,r_1]$ 中找出 $\min(x,y)$ 个 $0$ 替换。但区间越长 $0$ 的个数越多，因此具有单调性，那么采用二分答案即可找出替换的区间。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> s,ls,rs,ms,len,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//s是1的个数</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> l1,r1,l0,r0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(E&amp; u,E l,E r)</span></span>&#123;</span><br><span class="line">    u.s=l.s+r.s;</span><br><span class="line">    u.ls=l.s?l.ls:l.len+r.ls;</span><br><span class="line">    u.rs=r.s?r.rs:r.len+l.rs;</span><br><span class="line">    u.ms=<span class="built_in">max</span>(&#123;l.ms,r.ms,l.rs+r.ls&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;<span class="comment">//赋值为0</span></span><br><span class="line">        t.ms=t.ls=t.rs=t.len;</span><br><span class="line">        t.s=t.tag=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t.ms=t.ls=t.rs=<span class="number">0</span>;</span><br><span class="line">        t.s=t.len,t.tag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">0</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">1</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    t.tag=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u],tr[u&lt;&lt;<span class="number">1</span>],tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,r-l<span class="number">+1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>].r&gt;=l)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l&lt;=r)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].s;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="keyword">return</span> <span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;tr[u&lt;&lt;<span class="number">1</span>].r)<span class="keyword">return</span> <span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q0</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].len-tr[u].s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="keyword">return</span> <span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;tr[u&lt;&lt;<span class="number">1</span>].r)<span class="keyword">return</span> <span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;tr[u&lt;&lt;<span class="number">1</span>].r)<span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    E res;</span><br><span class="line">    <span class="built_in">pushup</span>(res,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;l1&gt;&gt;r1;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">q1</span>(<span class="number">1</span>,l0,r0);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,l0,r0,<span class="number">0</span>);<span class="comment">//全变0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=l1,r=r1<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">q0</span>(<span class="number">1</span>,l1,mid)&lt;=x)l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,l1,l,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l0&gt;&gt;r0;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)<span class="built_in">change</span>(<span class="number">1</span>,l0,r0,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">work</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>)cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l0,r0).ms&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P2824-HEOI2016-TJOI2016-排序-线段树-二分"><a href="#P2824-HEOI2016-TJOI2016-排序-线段树-二分" class="headerlink" title="P2824 [HEOI2016/TJOI2016] 排序 线段树+二分"></a>P2824 [HEOI2016/TJOI2016] 排序 线段树+二分</h2><ul>
<li><p>题意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 l r 表示将区间 [l,r] 的数字升序排序</span><br><span class="line">1 l r 表示将区间 [l,r] 的数字降序排序</span><br></pre></td></tr></table></figure>
<p>最后查询 <code>q</code> 位置上的数字。</p>
</li>
<li><p>思路：如果这道题暴力去做 $O(mnlogn)$。因此我们转化一下思路就是：把上序列和下降序列分别转化成01序列。因为线段树操作01序列比较容易。这样就把区间排序转化成了区间修改和区间查询。因为这个线段树维护的是排列，因此可以用二分来求解某个位置上的值。因为具有二段性，为什么具有二段性呢？因此我们可以把 $&gt;=mid$ 的设为 $1$ ，反之为 $0$。之后查询的时候如果是 $1$ 则在 $&gt;=mid$ 找。对于这种 $01$ 序列的懒标记都是 $0$ 和 $1$，没有标记就是 $-1$。总的来说本道题就是二分答案的思路，因为本道题查询只有 $1$ 个。只查找 <code>sum</code> 不需要区间合并，而且 <code>sum</code> 不涉及累加的过程，因为本题只是排序。只是移动位置，没有其他任何合并操作，因此不需要区间合并以及 <code>sum</code> 累加。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],m,op[N];</span><br><span class="line"><span class="type">int</span> L[N],R[N];</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].tag!=<span class="number">-1</span>)&#123;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].sum=tr[u].tag*(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l<span class="number">+1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum=tr[u].tag*(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l<span class="number">+1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].tag=tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag=tr[u].tag;</span><br><span class="line">        tr[u].tag=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,w[l]&gt;=x,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid,x),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r,x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].sum=k*(tr[u].r-tr[u].l<span class="number">+1</span>);</span><br><span class="line">        tr[u].tag=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n,x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l=L[i],r=R[i];</span><br><span class="line">        <span class="type">int</span> cnt=<span class="built_in">query</span>(<span class="number">1</span>,l,r);<span class="comment">//1的个数</span></span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,r-cnt<span class="number">+1</span>,r,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,r-cnt,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,l+cnt<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l+cnt,r,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,q,q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;op[i]&gt;&gt;L[i]&gt;&gt;R[i];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P5142-区间方差-线段树"><a href="#P5142-区间方差-线段树" class="headerlink" title="P5142 区间方差 线段树"></a>P5142 区间方差 线段树</h2><ul>
<li><p>题意：给定操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若 c=1，为修改操作，代表将 bx 赋值为 y。</span><br><span class="line">若 c=2，为查询操作，代表查询 bx 到 by​ 的方差。</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：方差的计算只需要计算平方和和区间和即可。因为：</p>
<script type="math/tex; mode=display">\begin{aligned} \sigma^2  = \frac{1}{n} \sum \limits_{i = 1}^n (x_i - \bar{x})^2 \\  = \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \sum \limits_{i = 1}^nx_i + n \bar{x}^2) \\  = \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \times n \bar{x} + n \bar{x}^2) \\  = \frac{1}{n} \sum \limits_{i = 1}^n x_i^2 - \bar{x}^2 \\ \end{aligned}</script></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rev</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmi</span>(x,mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> s1,s2;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].s1=(tr[u&lt;&lt;<span class="number">1</span>].s1+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s1)%mod;</span><br><span class="line">    tr[u].s2=(tr[u&lt;&lt;<span class="number">1</span>].s2+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s2)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,w[l],w[l]*w[l]%mod&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].s1=v;</span><br><span class="line">        tr[u].s2=v*v%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,k,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,k,v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].s1;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)res=(res+<span class="built_in">query1</span>(u&lt;&lt;<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)res=(res+<span class="built_in">query1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].s2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)res=(res+<span class="built_in">query2</span>(u&lt;&lt;<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)res=(res+<span class="built_in">query2</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> s1=<span class="built_in">query1</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            <span class="type">int</span> s2=<span class="built_in">query2</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            <span class="type">int</span> t=<span class="built_in">rev</span>(y-x<span class="number">+1</span>);</span><br><span class="line">            <span class="type">int</span> ave=s1*t%mod;</span><br><span class="line">            <span class="type">int</span> d=s2*t%mod-ave*ave%mod;</span><br><span class="line">            d=(d%mod+mod)%mod;</span><br><span class="line">            cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P2184-贪婪大陆-差分-线段树"><a href="#P2184-贪婪大陆-差分-线段树" class="headerlink" title="P2184 贪婪大陆 差分+线段树"></a>P2184 贪婪大陆 差分+线段树</h2><ul>
<li><p>题意：询问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若 q=1，则表示 SCV 在 [l,r] 这段区间布上一种地雷；</span><br><span class="line">若 q=2，则表示小 FF 询问当前 [l,r] 区间总共有多少种地雷。</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：其实很容易理解就是询问一段区间内有多少段不同的区间，此时可以用差分来做。然后发现：只要一个区间的开头在一个节点 $i$ 的左边，那么这个区间包含在区间 $1-i$ 中，只要一个区间的尾部在一个节点 $j$ 的左边，那么这个区间肯定不属于 $j$之后的所有区间。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum[<span class="number">2</span>];<span class="comment">//sum[0]为区间起点，sum[1]为终点</span></span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    tr[u].sum[k]=tr[u&lt;&lt;<span class="number">1</span>].sum[k]+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].sum[k]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,x,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,k);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r,k)+<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,r,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;(<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,r,<span class="number">0</span>)-<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,l<span class="number">-1</span>,<span class="number">1</span>))&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P4198-楼房重建-与-k-（斜率）有关的"><a href="#P4198-楼房重建-与-k-（斜率）有关的" class="headerlink" title="P4198 楼房重建 与 $k$ （斜率）有关的"></a>P4198 楼房重建 与 $k$ （斜率）有关的</h2><ul>
<li><p>题意：在一个平面内，求出所有的高度大于 $0$ 的点与 $(0,0)$ 的连线没有与之前的线段相交的楼房，带修改。</p>
</li>
<li><p>思路：线段树得维护 $k$ 和可见数量，其中可见数量因为右区间可能被左边的挡住了，因此得递归判断。</p>
</li>
</ul>
<blockquote>
<p>注意：右边的可见楼数一定是 $sum[n]-sum[ls]$，不是 $sum[rs]$，因为 $sum[rs]$ 是指从原点上看的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">double</span> mx;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">double</span> mls)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].mx&lt;=mls)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[u].mx&gt;mls;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>].mx&lt;=mls)<span class="keyword">return</span> <span class="built_in">dfs</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r,mls);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(u&lt;&lt;<span class="number">1</span>,l,mid,mls)+tr[u].sum-tr[u&lt;&lt;<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u].mx=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].mx,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+<span class="built_in">dfs</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r,tr[u&lt;&lt;<span class="number">1</span>].mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">double</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].mx=v;</span><br><span class="line">        tr[u].sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,k,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,k,v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u,tr[u].l,tr[u].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,x,(<span class="type">double</span>)y/x);</span><br><span class="line">        cout&lt;&lt;tr[<span class="number">1</span>].sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h1><ul>
<li><p>概念：可持久化线段树，就是保留历史的线段树。可持久化线段树，就是在线段树的每次操作中保留历史记录，并且从第 $i$个线段树的根开始访问第 $i$ 个历史版本的线段树，其中初始版本编号为0。</p>
</li>
<li><p>可持久化线段树无法使用普通线段树的堆式存储法，所以要采用动态开点法。为了好写，我们把每一个节点表示的区间放到函数的参数内部，这样可以有效减小空间和代码实现难度。</p>
</li>
<li><p>使用场景：区间第 k 大/小问题、区间内有多少不同的数字、区间更新等。</p>
<h2 id="P2464-SDOI2008-郁闷的小-J"><a href="#P2464-SDOI2008-郁闷的小-J" class="headerlink" title="P2464 [SDOI2008] 郁闷的小 J"></a>P2464 [SDOI2008] 郁闷的小 J</h2></li>
<li><p>题意：给定数列上有 $n$ 个颜色，两种操作：1、单点修改。2、区间查询 $[l,r]$ 内颜色 $k$ 出现的次数。</p>
</li>
<li>思路：肯定可以考虑可持久化线段树做法，首先把书的编号设为版本号，因为本道题不需要回溯，因此我们的change函数不需要写(int&amp; u,int v)的int v可以省去。还有就是得离散化。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N*<span class="number">2</span>];<span class="comment">//b为离散化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> opt,l,r,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> root[N],tot,cnt;</span><br><span class="line"><span class="type">int</span> ls[N*<span class="number">25</span>],rs[N*<span class="number">25</span>],sum[N*<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    sum[u]=sum[ls[u]]+sum[rs[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span>&amp; u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u)u=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        sum[u]+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">change</span>(ls[u],l,mid,p,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(rs[u],mid<span class="number">+1</span>,r,p,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x&amp;&amp;r&lt;=y)<span class="keyword">return</span> sum[u];</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)s+=<span class="built_in">query</span>(ls[u],l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)s+=<span class="built_in">query</span>(rs[u],mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[++cnt]=a[i];</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">char</span> s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            q[i].opt=<span class="number">0</span>;</span><br><span class="line">            cin&gt;&gt;q[i].l&gt;&gt;q[i].id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q[i].opt=<span class="number">1</span>;</span><br><span class="line">            cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].id;</span><br><span class="line">        &#125;</span><br><span class="line">        b[++cnt]=q[i].id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+cnt);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bn=<span class="built_in">unique</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+cnt)-b<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+bn,a[i])-b;</span><br><span class="line">        <span class="built_in">change</span>(root[a[i]],<span class="number">1</span>,n,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q[i].opt)&#123;</span><br><span class="line">            <span class="built_in">change</span>(root[a[q[i].l]],<span class="number">1</span>,n,q[i].l,<span class="number">-1</span>);</span><br><span class="line">            a[q[i].l]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+bn,q[i].id)-b;</span><br><span class="line">            <span class="built_in">change</span>(root[a[q[i].l]],<span class="number">1</span>,n,q[i].l,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> id=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+bn,q[i].id)-b;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(root[id],<span class="number">1</span>,n,q[i].l,q[i].r)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><p>如果是线性无关的话，那么它对应在线性空间中就是一个基底，简称“基”。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3iruzjw1.png" alt=""></p>
<p>线性空间的数量成为维度。</p>
<p>向量组等价：左边的向量能被右边的向量表示出来，右边也能被表示。</p>
<p>铺垫：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fo5wybkl.png" alt=""></p>
<p>要求一堆向量的基，我们可以用高斯消元来求。</p>
<p>高斯消元的过程不会影响向量的等价性。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/iq4ogzia.png" alt=""></p>
<p>此时高斯消元剩下的就是基了。</p>
<p>注意：子空间是指所有基能表示出来的向量集合。</p>
<p>性质：线性空间的任意两个基底它一定是等价的，维度一样的。</p>
<p>举一个例子：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7zj1w2ju.png" alt=""></p>
<p>极大线性无关组 $\le 60$，那么我们的线性空间的基底 $\le 60$，因此我们的线性空间表示出来的向量跟 $n=10^5$ 表示出来的是一模一样的。</p>
<ul>
<li>性质：</li>
</ul>
<ol>
<li>原序列里面的任意一个数都可以由线性基里面的一些数异或得到。</li>
<li>线性基里面的任意一些数异或起来都不能得到 $0$。</li>
<li>线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的。</li>
</ol>
<p><a href="https://blog.csdn.net/a_forever_dream/article/details/83654397">性质参考</a></p>
<h2 id="P4570-BJWC2011-元素"><a href="#P4570-BJWC2011-元素" class="headerlink" title="P4570 [BJWC2011] 元素"></a>P4570 [BJWC2011] 元素</h2><ul>
<li><p>题意：有 $n$ 个元素，每个元素能选当且仅当它的元素序号不能通过之前选过的东西的元素序号异或得到，在此前提下，求魔力的最大值。</p>
</li>
<li><p>思路：根据上述给定的性质，我们可以知道，一个序列，能够插入到线性基里面的元素是一定的，那么既然只能插那么多个，显然优先插魔力值大的进去。这样的贪心显然是最优的。<a href="https://www.luogu.com.cn/article/zhjz6jl9">为什么呢，细节可看</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N],p[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(E x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.num&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].num)&#123;</span><br><span class="line">                x.num^=p[i].num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p[i]=x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].num&gt;&gt;a[i].val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">insert</span>(a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)ans+=p[i].val;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点系列——基础数据结构</title>
    <url>/2025/02/17/%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1-1-链表"><a href="#1-1-链表" class="headerlink" title="1.1 链表"></a>1.1 链表</h1><h2 id="洛谷-P1996-约瑟夫问题"><a href="#洛谷-P1996-约瑟夫问题" class="headerlink" title="洛谷-P1996 约瑟夫问题"></a>洛谷-P1996 约瑟夫问题</h2><ul>
<li>我就直接模拟</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;k)&#123;</span><br><span class="line">            <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(vis[id])&#123;</span><br><span class="line">                id++;</span><br><span class="line">                f=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(id&gt;n)id=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">                id++;</span><br><span class="line">                <span class="keyword">if</span>(id&gt;n)id=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(vis[id])&#123;</span><br><span class="line">                    id++;</span><br><span class="line">                    <span class="keyword">if</span>(id&gt;n)id=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;id&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        vis[id]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1160-队列安排-list-做法"><a href="#洛谷-P1160-队列安排-list-做法" class="headerlink" title="洛谷-P1160 队列安排 list 做法"></a>洛谷-P1160 队列安排 list 做法</h2><ul>
<li><p><code>list</code> 有 <code>insert</code> 函数，可以将某个数插入在某个位置的后面，这里的位置是 <code>list&lt;int&gt;::iterator</code> 。</p>
</li>
<li><p>只不过为了优化，此时存储 <code>list&lt;int&gt;::iterator</code> 的所有位置，这样速度就会快很多。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;lt;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator elt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    elt[<span class="number">1</span>]=lt.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(y)&#123;</span><br><span class="line">            it=elt[x];<span class="comment">//然后这里的elt存储的是某个数前面的位置</span></span><br><span class="line">            lt.<span class="built_in">insert</span>(++it,i);<span class="comment">//因为list插入都是在某个位置的后面插</span></span><br><span class="line">            elt[i]=--it;<span class="comment">//左闭右开</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            it=elt[x];</span><br><span class="line">            lt.<span class="built_in">insert</span>(it,i);</span><br><span class="line">            elt[i]=--it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(elt[x]!=lt.<span class="built_in">end</span>())&#123;</span><br><span class="line">            lt.<span class="built_in">erase</span>(elt[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        elt[x]=lt.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:lt)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-2-队列"><a href="#1-2-队列" class="headerlink" title="1.2 队列"></a>1.2 队列</h1><h2 id="洛谷-P1540-机器翻译"><a href="#洛谷-P1540-机器翻译" class="headerlink" title="洛谷-P1540 机器翻译"></a>洛谷-P1540 机器翻译</h2><ul>
<li>直接模拟。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            S.<span class="built_in">insert</span>(x);</span><br><span class="line">            ans++;</span><br><span class="line">            q.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(q.sz&gt;m)S.<span class="built_in">erase</span>(q.<span class="built_in">front</span>()),q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-1003-Max-Sum-连续和的dp"><a href="#HDU-1003-Max-Sum-连续和的dp" class="headerlink" title="HDU-1003 Max Sum 连续和的dp"></a>HDU-1003 Max Sum 连续和的dp</h2><ul>
<li>这个就是 dp 问题，只不过我觉得用队列麻烦。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>,al=<span class="number">1</span>,ar=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>]+w[i],w[i]);</span><br><span class="line">        <span class="keyword">if</span>(f[i]==f[i<span class="number">-1</span>]+w[i])&#123;</span><br><span class="line">            r=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f[i]==w[i])&#123;</span><br><span class="line">            l=r=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;ans)&#123;</span><br><span class="line">            ans=f[i];</span><br><span class="line">            al=l,ar=r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;T++&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;al&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ar&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1440-求m区间内的最小值-双端队列"><a href="#洛谷-P1440-求m区间内的最小值-双端队列" class="headerlink" title="洛谷-P1440 求m区间内的最小值 双端队列"></a>洛谷-P1440 求m区间内的最小值 双端队列</h2><ul>
<li><strong>注意一下：这里是不包括 $i$ 的前面 $m$ 个的最小值，因此我把那个输出放在弹出队首之后和弹出队尾之前的操作。反之如果包括，则写在下面</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;m)q.<span class="built_in">pop_front</span>();</span><br><span class="line">    </span><br><span class="line">        cout&lt;&lt;w[q.<span class="built_in">front</span>()]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;w[q.<span class="built_in">back</span>()]&gt;=w[i])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2032-扫描"><a href="#洛谷-P2032-扫描" class="headerlink" title="洛谷-P2032 扫描"></a>洛谷-P2032 扫描</h2><ul>
<li>跟上一道题类似。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;=m)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;w[q.<span class="built_in">back</span>()]&lt;=w[i])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m)&#123;<span class="comment">//因为有包括该数的前k个数，所以必须写在下面，上一题是没有包括这个数，所以写在上面</span></span><br><span class="line">            cout&lt;&lt;w[q.<span class="built_in">front</span>()]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1714-切蛋糕-前缀和"><a href="#洛谷-P1714-切蛋糕-前缀和" class="headerlink" title="洛谷-P1714 切蛋糕 前缀和"></a>洛谷-P1714 切蛋糕 前缀和</h2><ul>
<li>就是把求最小值改成了前缀和，一样的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;k)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;s[i]&lt;=s[q.<span class="built_in">back</span>()])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,s[i]-s[q.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="总结一下（易错点）："><a href="#总结一下（易错点）：" class="headerlink" title="总结一下（易错点）："></a><strong>总结一下（易错点）：</strong></h3><ol>
<li>如果是求前面的最小值的话，此时 <code>deque</code> 的初始加入的数不能是 <code>0</code>，必须是 <code>1</code>，如果是前缀和这样的，就可以是 <code>0</code>。</li>
<li>如果是不包括 $i$ 的前面 $m$ 个的最小值，因此我把那个输出放在弹出队首之后和弹出队尾之前的操作。反之如果包括，则写在下面。</li>
</ol>
<hr>
<h2 id="洛谷-P2629-好消息，坏消息"><a href="#洛谷-P2629-好消息，坏消息" class="headerlink" title="洛谷 - P2629 好消息，坏消息"></a>洛谷 - P2629 好消息，坏消息</h2><ul>
<li>因为这道题有跨区间（就是从 $[k,n]$ $[1,k-1]$），那么可以扩展数组，那么此时这些区间的长度就是固定的了，那么我们就可以用单调队列来维护了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],w[i+n]=w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m=n;</span><br><span class="line">    n*=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;m)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;s[i]&lt;=s[q.<span class="built_in">back</span>()])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[q.<span class="built_in">front</span>()]-s[i-m]&gt;=<span class="number">0</span>)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复制数组有的时候很重要，特别对于移动或跨区间问题上。</p>
</blockquote>
<h2 id="洛谷-P2422-良好的感觉"><a href="#洛谷-P2422-良好的感觉" class="headerlink" title="洛谷 - P2422 良好的感觉"></a>洛谷 - P2422 良好的感觉</h2><ul>
<li>题目要求最大的值（区间内的最小值乘区间和的值），此时如果我们固定了最小的值，那岂不是很好算。根据这个思路，我们可以对于每一个数，看它往左最远能扩展到哪里，往右同理。这里就可以用栈来维护了。（悄悄地说一下，这道题好像也可用悬线法）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],s[N];<span class="comment">//考虑一个值它能作为什么区间的最小值，即它能向两边扩展多少</span></span><br><span class="line"><span class="type">int</span> L[N],R[N];</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;w[stk[top]]&gt;=w[i])&#123;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        L[i]=stk[top];</span><br><span class="line">        stk[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    stk[<span class="number">0</span>]=n<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;w[stk[top]]&gt;=w[i])top--;</span><br><span class="line">        R[i]=stk[top]<span class="number">-1</span>;</span><br><span class="line">        stk[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)ans=<span class="built_in">max</span>(ans,(s[R[i]]-s[L[i]])*w[i]);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1540-机器翻译-1"><a href="#洛谷-P1540-机器翻译-1" class="headerlink" title="洛谷 - P1540 机器翻译"></a>洛谷 - P1540 机器翻译</h2><ul>
<li>题目叫我们查找查词典次数，查词典次数被定义为如果内存中有（此时我们可以用队列来维护内存，因为内存的大小是固定的），那么就可以增加答案了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            S.<span class="built_in">insert</span>(x);</span><br><span class="line">            ans++;</span><br><span class="line">            q.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(q.sz&gt;m)S.<span class="built_in">erase</span>(q.<span class="built_in">front</span>()),q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P3957-跳房子-区间不固定的单调队列"><a href="#洛谷-P3957-跳房子-区间不固定的单调队列" class="headerlink" title="洛谷 - P3957  跳房子 区间不固定的单调队列"></a>洛谷 - P3957  跳房子 区间不固定的单调队列</h2><ul>
<li>可以发现：这道题的弹跳距离是个范围。而且这道题具有二段性，也就是如果低于了这个值，那么可能跳不过去。这里得特别注意区间是个范围的单调队列的写法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=d)&#123;</span><br><span class="line">        l=<span class="number">1</span>,r=x+d;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l=d-x,r=x+d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n+n,<span class="number">-1e18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;j&amp;&amp;w[i].fi-w[j].fi&gt;=l)&#123;<span class="comment">//区间不固定，也就是区间是个大范围都是这么写</span></span><br><span class="line">            <span class="keyword">while</span>(q.sz&amp;&amp;f[q.<span class="built_in">back</span>()]&lt;=f[j])q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(j++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;w[i].fi-w[q.<span class="built_in">front</span>()].fi&gt;r)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(q.sz)f[i]=f[q.<span class="built_in">front</span>()]+w[i].se;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;=k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i].fi&gt;&gt;w[i].se,s+=(w[i].se&gt;<span class="number">0</span>?w[i].se:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s&lt;k)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1725-琪露诺"><a href="#洛谷-P1725-琪露诺" class="headerlink" title="洛谷 - P1725 琪露诺"></a>洛谷 - P1725 琪露诺</h2><ul>
<li>这道题和上一道题类似，只不过得注意：只要她下一步的位置编号大于 $N$ 就算到达对岸。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n*<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;j&amp;&amp;i-j&gt;=L)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.sz&amp;&amp;f[q.<span class="built_in">back</span>()]&lt;=f[j])q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(j++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;R)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(q.sz)f[i]=f[q.<span class="built_in">front</span>()]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,n,n*<span class="number">3</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>总结：区间是个范围的单调队列来维护最大/最小值的写法：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FOR</span>(i,<span class="number">0</span>,n*<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;j&amp;&amp;i-j&gt;=L)&#123;<span class="comment">//L,R是区间范围</span></span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;f[q.<span class="built_in">back</span>()]&lt;=f[j])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;R)q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span>(q.sz)f[i]=f[q.<span class="built_in">front</span>()]+w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="洛谷-P2776-小组队列"><a href="#洛谷-P2776-小组队列" class="headerlink" title="洛谷 - P2776 小组队列"></a>洛谷 - P2776 小组队列</h2><ul>
<li>这道题存在在特定的位置上插入值，此时得考虑链表。</li>
</ul>
<blockquote>
<p>deque双端队列是一个很好的办法 deque的操作:</p>
<p>void push_front(const T&amp; x):双端队列头部增加一个元素X</p>
<p>void push_back(const T&amp; x):双端队列尾部增加一个元素x</p>
<p>void pop_front():删除双端队列中最前一个元素</p>
<p>void pop_back():删除双端队列中最后一个元素</p>
<p>iterator begin():返回向量头指针，指向第一个元素</p>
<p>iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line">list&lt;<span class="type">int</span>&gt;lst;</span><br><span class="line">deque&lt;list&lt;<span class="type">int</span>&gt;::iterator&gt;pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(pos[w[x]].sz)&#123;</span><br><span class="line">                it=*(--pos[w[x]].<span class="built_in">end</span>());</span><br><span class="line">                it++;</span><br><span class="line">                pos[w[x]].<span class="built_in">push_back</span>(lst.<span class="built_in">insert</span>(it,x));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lst.<span class="built_in">push_back</span>(x);</span><br><span class="line">                it=--lst.<span class="built_in">end</span>();</span><br><span class="line">                pos[w[x]].<span class="built_in">push_back</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            it=lst.<span class="built_in">begin</span>();</span><br><span class="line">            cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">            pos[w[*it]].<span class="built_in">pop_front</span>();</span><br><span class="line">            lst.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Task = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; Task; Task--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h1><h2 id="HDU-1062-Text-Reverse"><a href="#HDU-1062-Text-Reverse" class="headerlink" title="HDU - 1062 Text Reverse"></a>HDU - 1062 Text Reverse</h2><ul>
<li>模拟。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    s+=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>&amp;&amp;s[i]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            S.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(S.sz)&#123;</span><br><span class="line">                cout&lt;&lt;S.<span class="built_in">top</span>();</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2947-Look-Up-S"><a href="#洛谷-P2947-Look-Up-S" class="headerlink" title="洛谷 - P2947 Look Up S"></a>洛谷 - P2947 Look Up S</h2><ul>
<li>这里得从大到小去维护栈，因为奶牛是往右看的，右边的高，栈能维护从 $n$ 到 $i$ 最高的奶牛的下标。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(S.sz&amp;&amp;w[S.<span class="built_in">top</span>()]&lt;=w[i])S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(S.sz)ans[i]=S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P5788-单调栈"><a href="#洛谷-P5788-单调栈" class="headerlink" title="洛谷 - P5788 单调栈"></a>洛谷 - P5788 单调栈</h2><ul>
<li>和上一道类似。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(S.sz&amp;&amp;w[S.<span class="built_in">top</span>()]&lt;=w[i])S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(S.sz)ans[i]=S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="洛谷-P1449-后缀表达式"><a href="#洛谷-P1449-后缀表达式" class="headerlink" title="洛谷 - P1449 后缀表达式"></a>洛谷 - P1449 后缀表达式</h2><ul>
<li>就是维护两个栈，一个是符号栈，另一个是数字栈。符号栈还有优先级，优先级高的先运算。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    s.<span class="built_in">pop_back</span>();</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;S;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            S.<span class="built_in">push</span>(res);</span><br><span class="line">            res=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            res=(res&lt;&lt;<span class="number">3</span>)+(res&lt;&lt;<span class="number">1</span>)+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> a=S.<span class="built_in">top</span>();S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> b=S.<span class="built_in">top</span>();S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>)S.<span class="built_in">push</span>(a+b);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>)S.<span class="built_in">push</span>(b-a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)S.<span class="built_in">push</span>(b/a);</span><br><span class="line">            <span class="keyword">else</span> S.<span class="built_in">push</span>(b*a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;S.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="洛谷-P1739-表达式括号匹配"><a href="#洛谷-P1739-表达式括号匹配" class="headerlink" title="洛谷 - P1739 表达式括号匹配"></a>洛谷 - P1739 表达式括号匹配</h2><ul>
<li>这道题直接用栈维护，如果右括号多就不对，左括号到最后还有剩也不对。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;(&#x27;</span>)S.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!S.sz)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(!S.sz?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1981-表达式求值"><a href="#洛谷-P1981-表达式求值" class="headerlink" title="洛谷 - P1981  表达式求值"></a>洛谷 - P1981  表达式求值</h2><ul>
<li>这道题就是多了个中缀表达式转化成后缀表达式的操作以及判断括号是否匹配的操作。</li>
</ul>
<p>具体细节可看代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;S&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ovel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">char</span> c=op.<span class="built_in">top</span>();op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)num.<span class="built_in">push</span>((a+b)%<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)num.<span class="built_in">push</span>((a-b)%<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)num.<span class="built_in">push</span>((a*b)%<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">else</span> num.<span class="built_in">push</span>((a/b)%<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.sz&amp;&amp;s[j]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[j]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                res=((res&lt;&lt;<span class="number">3</span>)+(res&lt;&lt;<span class="number">1</span>)+s[j]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">10000</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(res);</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(op.sz&amp;&amp;S[op.<span class="built_in">top</span>()]&gt;=S[s[i]])<span class="built_in">ovel</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(op.sz)<span class="built_in">ovel</span>();</span><br><span class="line">    cout&lt;&lt;num.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1175-表达式的转换"><a href="#洛谷-P1175-表达式的转换" class="headerlink" title="洛谷 - P1175 表达式的转换"></a>洛谷 - P1175 表达式的转换</h2><ul>
<li>这道题比较复杂，得考虑表达式树，这种做法是通法，因为它能输出，每一步的运算过程以及可以输出后缀前缀中缀表达式。很方便。</li>
</ul>
<h3 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a><a href="https://blog.csdn.net/fireflylane/article/details/83017889">表达式树</a></h3><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><ol>
<li>先找根：有加减找最后一个加减，有乘除找最后一个乘除，否则找第一个幂。</li>
</ol>
<p>注意：括号内要看成一个整体（不然递归到后面会出错） 如果整个式子是形如 (xxxxx) 型要先把外括号去掉，且一定要对应。</p>
<ol>
<li><p>递归。</p>
</li>
<li><p>我们得知道：</p>
</li>
</ol>
<ul>
<li>树的结构。</li>
<li>叶子结点的数值。</li>
<li>每个节点的符号。（叶子结点就是” “）</li>
</ul>
<p><a href="https://www.luogu.com.cn/article/1phl9fzr">参考</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> ch[N];</span><br><span class="line"><span class="type">int</span> num[N],lf[N],rf[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        num[++cnt]=s[l]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch[cnt]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[l]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,l<span class="number">+1</span>,r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)t++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)t--;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==r)l++,r--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p,t=<span class="number">5</span>;<span class="comment">//t:+1-1*2/2^3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,l,r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tt=<span class="number">1</span>,j;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=l;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">&#x27;)&#x27;</span>)tt++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;(&#x27;</span>)tt--;</span><br><span class="line">                <span class="keyword">if</span>(!tt)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i=j;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;s[i]&gt;=<span class="string">&#x27;0&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>)&amp;&amp;t&gt;<span class="number">1</span>)p=i,t=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i]==<span class="string">&#x27;*&#x27;</span>||s[i]==<span class="string">&#x27;/&#x27;</span>)&amp;&amp;t&gt;<span class="number">2</span>)p=i,t=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i]==<span class="string">&#x27;^&#x27;</span>)&amp;&amp;t&gt;<span class="number">3</span>)p=i,t=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x=++cnt;</span><br><span class="line">    ch[x]=s[p];</span><br><span class="line">    lf[x]=cnt<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,p<span class="number">-1</span>);</span><br><span class="line">    rf[x]=cnt<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)<span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> a-b;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)<span class="keyword">return</span> a*b;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;/&#x27;</span>)<span class="keyword">return</span> a/b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmi</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[u]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        cout&lt;&lt;num[u]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(lf[u]),<span class="built_in">print</span>(rf[u]);</span><br><span class="line">    cout&lt;&lt;ch[u]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[x]==<span class="string">&#x27; &#x27;</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(lf[x]);</span><br><span class="line">    <span class="built_in">dfs</span>(rf[x]);</span><br><span class="line">    num[x]=<span class="built_in">calc</span>(num[lf[x]],num[rf[x]],ch[x]);</span><br><span class="line">    ch[x]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>,s.sz<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1-4-二叉树与哈夫曼树"><a href="#1-4-二叉树与哈夫曼树" class="headerlink" title="1.4 二叉树与哈夫曼树"></a>1.4 二叉树与哈夫曼树</h1><h2 id="HDU-2527-Safe-Or-Unsafe"><a href="#HDU-2527-Safe-Or-Unsafe" class="headerlink" title="HDU - 2527 Safe Or Unsafe"></a>HDU - 2527 Safe Or Unsafe</h2><ul>
<li>就是算huffman编码，因为一个字母的权值等于该字母在字符串中出现的频率。$WPL$ 的算法就是两个两个堆合并的过程。具体细节可看代码。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;t&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">p</span><span class="params">(<span class="number">30</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        p[x-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,VI,greater&lt;<span class="type">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(a+b);</span><br><span class="line">        res+=a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!res)res=q.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res&lt;=t)cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1087-FBI-树"><a href="#洛谷-P1087-FBI-树" class="headerlink" title="洛谷 - P1087 FBI 树"></a>洛谷 - P1087 FBI 树</h2><ul>
<li>就是递归（因为递归本身也就是栈）。要找后序遍历，就把输出放在后面即可（回溯位置）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">FBI</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">FBI</span>(p.<span class="built_in">substr</span>(<span class="number">0</span>,p.sz/<span class="number">2</span>));</span><br><span class="line">        cout&lt;&lt;<span class="built_in">FBI</span>(p.<span class="built_in">substr</span>(p.sz/<span class="number">2</span>,p.sz/<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t0=p.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>),t1=p.<span class="built_in">find</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(t0!=<span class="number">-1</span>&amp;&amp;t1!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(t0!=<span class="number">-1</span>&amp;&amp;t1==<span class="number">-1</span>)<span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(t0==<span class="number">-1</span>&amp;&amp;t1!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">FBI</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1030-求先序排列"><a href="#洛谷-P1030-求先序排列" class="headerlink" title="洛谷 - P1030 求先序排列"></a>洛谷 - P1030 求先序排列</h2><ul>
<li>已知中序与后序排列，求先序遍历。根据每种遍历的结构，比如先序遍历的结构是 <code>根 左子树 右子树</code>。那么可以很容易写出代码。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string sa,string sb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sa.sz&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;sb[sb.sz<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> t=sa.<span class="built_in">find</span>(sb[sb.sz<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">dfs</span>(sa.<span class="built_in">substr</span>(<span class="number">0</span>,t),sb.<span class="built_in">substr</span>(<span class="number">0</span>,t));</span><br><span class="line">        <span class="built_in">dfs</span>(sa.<span class="built_in">substr</span>(t<span class="number">+1</span>),sb.<span class="built_in">substr</span>(t,sa.sz<span class="number">-1</span>-t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1305-新二叉树"><a href="#洛谷-P1305-新二叉树" class="headerlink" title="洛谷 - P1305 新二叉树"></a>洛谷 - P1305 新二叉树</h2><ul>
<li>这就是建一颗树即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">char</span> l,r;</span><br><span class="line">&#125;w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">char</span> rt,<span class="type">char</span> l,<span class="type">char</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;rt;</span><br><span class="line">    <span class="keyword">if</span>(l)<span class="built_in">dfs</span>(l,w[l].l,w[l].r);</span><br><span class="line">    <span class="keyword">if</span>(r)<span class="built_in">dfs</span>(r,w[r].l,w[r].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            c=s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>]!=<span class="string">&#x27;*&#x27;</span>)w[s[<span class="number">0</span>]].l=s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">2</span>]!=<span class="string">&#x27;*&#x27;</span>)w[s[<span class="number">0</span>]].r=s[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(c,w[c].l,w[c].r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1229-遍历问题"><a href="#洛谷-P1229-遍历问题" class="headerlink" title="洛谷 - P1229 遍历问题"></a>洛谷 - P1229 遍历问题</h2><ul>
<li>从当前遍历节点来看，如果不是链的话，受到左右节点影响，显然先序和后序遍历的子树开头和结尾两个字符不会相等。因此可以发现满足上述条件的唯一情况就是从当前节点开始的子树的是链的情况，接下来可以选择把子树放到左边，也可以选择放到右边，答案 $×2$ 即可。总的来说就是如果只有一个儿子的话，那么它可以是左儿子也可以是右儿子。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,a.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,b.sz<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]&amp;&amp;a[i<span class="number">+1</span>]==b[j<span class="number">-1</span>])&#123;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P5018-对称二叉树"><a href="#洛谷-P5018-对称二叉树" class="headerlink" title="洛谷 - P5018  对称二叉树"></a>洛谷 - P5018  对称二叉树</h2><ul>
<li>只需要判断每个节点的子树是否为对称二叉树，然后计算该子树的节点个数就行了。<img src="https://cdn.luogu.com.cn/upload/image_hosting/i7uonvng.png" alt=""><br>当到节点 $x$ 时，需要满足 $v<em>{l_x}=v</em>{r<em>x}$。到节点 $y$ 和 $z$ 时，需要满足 $v</em>{l<em>y}=v</em>{r<em>z}$ 和 $v</em>{r<em>y}=v</em>{l_z}$。若其中 $l,r$ 其中一个的值为 $-1$ 或 $v$ 不相等，那么它就不是对称二叉树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N];</span><br><span class="line"><span class="type">int</span> l[N],r[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(l[u]);</span><br><span class="line">    siz[u]+=siz[l[u]];</span><br><span class="line">    <span class="built_in">dfs1</span>(r[u]);</span><br><span class="line">    siz[u]+=siz[r[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">-1</span>&amp;&amp;y==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">-1</span>||y==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(w[x]!=w[y])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs2</span>(l[x],r[y])&amp;&amp;<span class="built_in">dfs2</span>(r[x],l[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs2</span>(i,i))&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,siz[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P5597-复读"><a href="#洛谷-P5597-复读" class="headerlink" title="洛谷 - P5597  复读"></a>洛谷 - P5597  复读</h2><ul>
<li>很神奇<a href="https://www.luogu.com.cn/article/n0mlpy4y">看解题的</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;tr[N],tr2[N];<span class="comment">//每次指令后都不可能返回祖先节点了</span></span><br><span class="line"><span class="comment">//到下一个灰色点之前必须先把上面部分全部访问完,否则就不可能回去了</span></span><br><span class="line"><span class="type">int</span> tot,p1,p2,tot2,ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> p=++tot;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>||t==<span class="number">3</span>)tr[p].l=<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>||t==<span class="number">3</span>)tr[p].r=<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;<span class="comment">//合并树</span></span><br><span class="line">    <span class="keyword">if</span>(p==p1||q==p2)p2=q,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr2[q].l)tr2[q].l=++tot2;</span><br><span class="line">        <span class="built_in">dfs</span>(tr[p].l,tr2[q].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr2[q].r)tr2[q].r=++tot2;</span><br><span class="line">        <span class="built_in">dfs</span>(tr[p].r,tr2[q].r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">    p1=u,p2=<span class="number">0</span>,tot2=<span class="number">1</span>;<span class="comment">//p1是原树，p2是合并树</span></span><br><span class="line">    <span class="built_in">memset</span>(tr2,<span class="number">0</span>,<span class="keyword">sizeof</span> tr2);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,tot2);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="number">2</span>*(tot2<span class="number">-1</span>)-dep);</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l)<span class="built_in">calc</span>(tr[u].l,dep<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tr[u].r)<span class="built_in">calc</span>(tr[u].r,dep<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2168-荷马史诗"><a href="#洛谷-P2168-荷马史诗" class="headerlink" title="洛谷 - P2168 荷马史诗"></a>洛谷 - P2168 荷马史诗</h2><ul>
<li>典型的 $k$ 叉树。</li>
</ul>
<blockquote>
<p>对于 $k$ 叉哈夫曼树的求解,直观的想法是在贪心的基础上,改为每次从堆中去除最小的 $k$ 个权值合并。然而，仔细思考可以发现，如果在执行最后一次循环时，堆的大小在（2~k-1）之间（不足以取出 k 个），那么整个哈夫曼树的根的子节点个数就小于k。这显然不是最优解————我们任意取哈夫曼树中一个深度最大的节点，改为树根的子节点，就会使 $∑w_i\times l_i$  变小。因此，我们应该在执行上述贪心算法之前，补加一些额外的权值为0的叶子节点，使叶子节点的个树满足(n-1)%(k-1)=0。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII,VPII,GII&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((n<span class="number">-1</span>)%(k<span class="number">-1</span>))&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);<span class="comment">//补节点</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dep=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">            sum+=q.<span class="built_in">top</span>().fi;</span><br><span class="line">            dep=<span class="built_in">max</span>(dep,q.<span class="built_in">top</span>().se);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        res+=sum;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;sum,dep<span class="number">+1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl&lt;&lt;q.<span class="built_in">top</span>().se&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-5-堆"><a href="#1-5-堆" class="headerlink" title="1.5 堆"></a>1.5 堆</h1><h2 id="洛谷-P3378-堆"><a href="#洛谷-P3378-堆" class="headerlink" title="洛谷 - P3378 堆"></a>洛谷 - P3378 堆</h2><ul>
<li>模拟</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> op,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1090-合并果子"><a href="#洛谷-P1090-合并果子" class="headerlink" title="洛谷 - P1090 合并果子"></a>洛谷 - P1090 合并果子</h2><ul>
<li>每次拿去两个较小的果子，这里就可以用堆来维护了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        q.<span class="built_in">push</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=a+b;</span><br><span class="line">        q.<span class="built_in">push</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1168-中位数"><a href="#洛谷-P1168-中位数" class="headerlink" title="洛谷 - P1168 中位数"></a>洛谷 - P1168 中位数</h2><ul>
<li>如果直接用排序加取中位数的方法，时间复杂度很高，因此可以想到对顶堆来做。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(q<span class="number">1.</span>sz&gt;q<span class="number">2.</span>sz)&#123;</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">push</span>(q<span class="number">1.</span><span class="built_in">top</span>());</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q<span class="number">2.</span>sz&gt;q<span class="number">1.</span>sz)&#123;</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">push</span>(q<span class="number">2.</span><span class="built_in">top</span>());</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;q<span class="number">1.</span><span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2085-最小函数值"><a href="#洛谷-P2085-最小函数值" class="headerlink" title="洛谷 - P2085 最小函数值"></a>洛谷 - P2085 最小函数值</h2><ul>
<li>就是搞一个堆，然后把函数的值都放进去。这边存在一个优化，就是这边先把 $x=1$ 带入每个函数里面去，然后把这些得到的值都放入堆中，然后从堆中取出较小的值，然后把 $x+1$ 的值又放入堆中，这样是最优的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,x,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y&gt;t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;E&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;a[i]+b[i]+c[i],<span class="number">1</span>,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        E t=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;t.y&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;a[t.id]*(t.x<span class="number">+1</span>)*(t.x<span class="number">+1</span>)+b[t.id]*(t.x<span class="number">+1</span>)+c[t.id],t.x<span class="number">+1</span>,t.id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2827-蚯蚓"><a href="#洛谷-P2827-蚯蚓" class="headerlink" title="洛谷 - P2827 蚯蚓"></a>洛谷 - P2827 蚯蚓</h2><ul>
<li>这道题如果每次切断都去维护一下堆的话，时间复杂度特别高，因此对于堆，如果要优化，一般想到的都是队列。首先我们明白一个不等式 $x_1-\lfloor px_1 \rfloor \ge x_2 \lfloor px_2 \rfloor$，具体证明过程请 <a href="https://www.luogu.com.cn/article/hgnmtohe">看，包含所有细节</a>。根据这个不等式，我们可以考虑维护三个队列，而不必维护一个优先队列，因为三个队列始终保持满足单调性，无需使用优先队列。然后根据此思路即可拿到所有 $q = 0$ 的分，接下来为了解决 $q \gt 0$，通常方法都是计个 $tag$，加入队列时把两段都减掉一个 $q$，$tag$ 加上一个 $q$。考虑到一条在第 $i$ 时刻加入的长度为 $len$ 蚯蚓，如果在第 $j$ 时刻被拿出来砍，因为它一共经历了 $j - i - 1$ 次切割，一次切割长度加 $q$，所以总长度是 $q \times (j - i - 1) + len$。<strong>可以在常数时间内算出</strong>，不必打 $tag$ 标记，只需多存个加入时间。  </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,q,u,v,t,w[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;qw[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// int INF=1e18;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n,<span class="built_in">GI</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        qw[<span class="number">1</span>].<span class="built_in">push</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        PII tt=<span class="built_in">max</span>(&#123;</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">1</span>].sz?qw[<span class="number">1</span>].<span class="built_in">front</span>():INF,<span class="number">1</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">2</span>].sz?qw[<span class="number">2</span>].<span class="built_in">front</span>():INF,<span class="number">2</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">3</span>].sz?qw[<span class="number">3</span>].<span class="built_in">front</span>():INF,<span class="number">3</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> x=tt.fi+q*i,y=tt.se;</span><br><span class="line">        qw[y].<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%t==t<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> b=x*u/v,c=x-b;</span><br><span class="line">        qw[<span class="number">2</span>].<span class="built_in">push</span>(b-q-q*i);</span><br><span class="line">        qw[<span class="number">3</span>].<span class="built_in">push</span>(c-q-q*i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n+m)&#123;</span><br><span class="line">        PII tt=<span class="built_in">max</span>(&#123;</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">1</span>].sz?qw[<span class="number">1</span>].<span class="built_in">front</span>():INF,<span class="number">1</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">2</span>].sz?qw[<span class="number">2</span>].<span class="built_in">front</span>():INF,<span class="number">2</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">3</span>].sz?qw[<span class="number">3</span>].<span class="built_in">front</span>():INF,<span class="number">3</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> x=tt.fi,y=tt.se;</span><br><span class="line">        qw[y].<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;x+q*m&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P3045-Cow-Coupons-G"><a href="#洛谷-P3045-Cow-Coupons-G" class="headerlink" title="洛谷 - P3045  Cow Coupons G"></a>洛谷 - P3045  Cow Coupons G</h2><ul>
<li>反悔贪心的题目。<blockquote>
<p>反悔贪心是什么？</p>
<p>答：其实贪心本身不带有反悔，是因为此时的贪心可以从局部最优解推出全局最优解。但当有些时候局部最优解推不出全局最优解时，就要用反悔贪心，在适当的时候撤销之前做出的决策。</p>
</blockquote>
</li>
<li>我们先选取 $c$ 最小的 $k$ 个物品使用优惠劵，当前已经使用的价格是 $tot$。下文为方便表述，记使用优惠劵的物品集合为 $A$，他在求解过程中不是固定不变的。<br>当前考虑第 $i$ 个物品，由于 $k$ 张优惠券已经用完了，所以只能以原价 $p_i$ 购买物品 $i$。现在考虑反不反悔的条件是什么。<br>如果要反悔，那么用优惠券买 $i$ 的价格一定要小于用原价买 $i$。当 $i$ 用了优惠券，那么 $A$ 势必要有一个物品（记为 $j,j \in A$）做出退让，用原价来买 $j$。（其实相当于用 $i$ 来代替 $j$），那么一定满足以下不等式：</li>
</ul>
<script type="math/tex; mode=display">tot-c_j+p_j+c_i\lt tot+p_i</script><p>意思是：$i$ 代替 $j$ 用优惠券的价格比用原价买 $i$ 便宜，这个时候就需要反悔。<br>发现 $tot$ 可以消去：</p>
<script type="math/tex; mode=display">-c_j+p_j+c_i\lt p_i</script><p>然后把下标相同的归在小于号的同一侧：</p>
<script type="math/tex; mode=display">p_j-c_j\lt p_i-c_i</script><p>他们的形式是相同的，所以我们可以设 $\Delta_i=p_i-c_i$：</p>
<script type="math/tex; mode=display">\Delta_j\lt\Delta_i</script><p>所以只要在已经使用优惠券的物品里面，存在一个 $j$，使得 $\Delta<em>j\lt\Delta_i$，我们就需要用 $i$ 代替 $j$ 使用优惠券。也就是 $k$ 个物品中，$(\Delta_j)</em>{\min}\lt\Delta_i$ 。注意这个不是恒等式，因为 $i \notin A$，但是 $j\in A$。<br>最小值可以用优先队列来求。</p>
<p><a href="https://www.luogu.com.cn/article/zg562iym">引用</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="type">int</span> p[N],c[N];</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,GII&gt;P,C;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,VI,GI&gt;delta;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">        P.<span class="built_in">push</span>(&#123;p[i],i&#125;);</span><br><span class="line">        C.<span class="built_in">push</span>(&#123;c[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,k)delta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(P.sz)&#123;</span><br><span class="line">        PII x=P.<span class="built_in">top</span>();</span><br><span class="line">        PII y=C.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[x.se])&#123;</span><br><span class="line">            P.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[y.se])&#123;</span><br><span class="line">            C.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原价买比按优惠价买并且补上差价便宜的话，我们就就用原价买</span></span><br><span class="line">        <span class="keyword">if</span>(delta.<span class="built_in">top</span>()+y.fi&gt;x.fi)&#123;<span class="comment">//用原价买 i 更划算</span></span><br><span class="line">            m-=x.fi;</span><br><span class="line">            vis[x.se]=<span class="number">1</span>;</span><br><span class="line">            P.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//用优惠券买 i 更划算</span></span><br><span class="line">            m-=y.fi+delta.<span class="built_in">top</span>();</span><br><span class="line">            vis[y.se]=<span class="number">1</span>;</span><br><span class="line">            C.<span class="built_in">pop</span>();</span><br><span class="line">            delta.<span class="built_in">pop</span>();</span><br><span class="line">            delta.<span class="built_in">push</span>(p[y.se]-c[y.se]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="待深入总结"><a href="#待深入总结" class="headerlink" title="待深入总结"></a>待深入总结</h2>]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>队内训练1</title>
    <url>/2025/02/15/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%831/</url>
    <content><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/odexe5it.png" alt=""></p>
<p><a href="https://codeforces.com/gym/103427">题目来源：2021年ICPC沈阳站</a></p>
<hr>
<p><strong>以下是对于原题目的顺序，但队内训练是抽了几道题目，具体对应关系见上图。</strong></p>
<p>签到：EF</p>
<p>铜牌题：BJ</p>
<p>银牌题：HILM</p>
<p>金牌题：G…</p>
<hr>
<h1 id="A-签到题"><a href="#A-签到题" class="headerlink" title="A 签到题"></a>A 签到题</h1><ul>
<li>简单模拟<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j<span class="number">+1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j<span class="number">+1</span>])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[j<span class="number">+1</span>]!=s[i])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[j<span class="number">+1</span>]==s[i])j++;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">5</span>)&#123;</span><br><span class="line">            j=ne[j];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="B-签到题"><a href="#B-签到题" class="headerlink" title="B 签到题"></a>B 签到题</h1><ul>
<li><p>题目可能有点难理解，就是说对于每个字母选取的是当前遍历到的字符的后面最后一个跟它相同字母的后面的字母个数。</p>
</li>
<li><p>然后求最大字典序就直接用 <code>max</code> 函数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt;S;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!S.<span class="built_in">count</span>(s[j]))f[s[j]]=S.<span class="built_in">size</span>();</span><br><span class="line">            S.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">            ans[i]+=<span class="built_in">char</span>(f[s[j]]+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ans<span class="number">+1</span>,ans<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-染色法"><a href="#C-染色法" class="headerlink" title="C 染色法"></a>C 染色法</h1><ul>
<li>可以很容易发现：把这些关系建图，然后对于每一个联通块的第一个点可以填 $0$ 也可以填 $1$，这两种情况取个最小值。</li>
<li>特判就是如果矛盾（就类似染色问题那种矛盾）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)p[i]=i,siz[i]=<span class="number">1</span>,ans[i]=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        a--,b--;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">        <span class="built_in">uni</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]!=i)<span class="keyword">continue</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(<span class="number">30</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        ans[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,w]:g[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    ans[j]=(ans[t]^w);</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    <span class="built_in">FOR</span>(k,<span class="number">0</span>,<span class="number">29</span>)&#123;</span><br><span class="line">                        cnt[k]+=((ans[j]&gt;&gt;k)&amp;<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ans[j]!=(ans[t]^w))&#123;</span><br><span class="line">                        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">29</span>)&#123;</span><br><span class="line">            res+=(<span class="number">1</span>&lt;&lt;j)*<span class="built_in">min</span>(cnt[j],siz[i]-cnt[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-bfs预处理"><a href="#D-bfs预处理" class="headerlink" title="D bfs预处理"></a>D bfs预处理</h1><ul>
<li>有很多次查询，但转移状态的次数不多，因此可以先预处理从某一个状态到某一个状态的最小花费，这里可以用 <code>bfs</code> 先预处理。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;string&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    dist[<span class="string">&quot;0000&quot;</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        string t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        string a,b;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(j,i,<span class="number">3</span>)&#123;</span><br><span class="line">                a=b=t;</span><br><span class="line">                <span class="built_in">FOR</span>(k,i,j)&#123;</span><br><span class="line">                    a[k]=(t[k]-<span class="string">&#x27;0&#x27;</span><span class="number">+1</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    b[k]=(t[k]-<span class="string">&#x27;0&#x27;</span><span class="number">+9</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dist.<span class="built_in">find</span>(a)==dist.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(a);</span><br><span class="line">                    dist[a]=dist[t]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dist.<span class="built_in">find</span>(b)==dist.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(b);</span><br><span class="line">                    dist[b]=dist[t]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="function">string <span class="title">c</span><span class="params">(<span class="number">4</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">3</span>)c[i]=(b[i]-a[i]<span class="number">+10</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;dist[c]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-思维-targin"><a href="#E-思维-targin" class="headerlink" title="E 思维+targin"></a>E 思维+targin</h1><ul>
<li><p>可以发现<strong>线图</strong>就是偶数的时候可以满足匹配，然后就是得看奇数。</p>
</li>
<li><p>奇数的时候得特殊考虑，最好转化成 <code>偶数+桥+偶数</code> 的形式，这样把桥删了不会对两边偶数的匹配产生影响。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/li_wen_zhuo/article/details/121633394?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164346130316780265469877%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164346130316780265469877&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-121633394.pc_search_result_control_group&amp;utm_term=Line%20Graph%20Matching&amp;spm=1018.2226.3001.4187">具体接替可以参考</a>，他用的是并查集，但我用 <code>targin</code> 一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;PII&gt; g[N];</span><br><span class="line"><span class="type">int</span> din[N];</span><br><span class="line"><span class="type">int</span> low[N],dfn[N];</span><br><span class="line"><span class="type">int</span> tmd,stk[N],siz[N];</span><br><span class="line"><span class="type">int</span> scc_cnt,tot,minv=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">targin</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    low[u]=dfn[u]=++tmd;</span><br><span class="line">    siz[u]=din[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,w]:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])&#123;</span><br><span class="line">            <span class="built_in">targin</span>(j,u);</span><br><span class="line">            siz[u]+=siz[j];</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">            <span class="keyword">if</span>(low[j]&gt;dfn[u])&#123;</span><br><span class="line">                <span class="keyword">if</span>((siz[j]<span class="number">-1</span>)/<span class="number">2</span>%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    minv=<span class="built_in">min</span>(minv,w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minv=<span class="built_in">min</span>(minv,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j!=pre)&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">            minv=<span class="built_in">min</span>(minv,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dfn[u]&lt;dfn[j])&#123;</span><br><span class="line">            tot++;<span class="comment">//联通块内边数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">        din[a]++,din[b]++;</span><br><span class="line">        res+=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(m&amp;<span class="number">1</span>))&#123;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            tot=<span class="number">0</span>;</span><br><span class="line">            minv=<span class="number">1e18</span>;</span><br><span class="line">            <span class="built_in">targin</span>(i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(tot&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                res-=minv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G-KMP"><a href="#G-KMP" class="headerlink" title="G KMP"></a>G KMP</h1><ul>
<li>就是典型KMP的border的应用，只不过KMP是前缀的border，这道题要求的是后缀的border，可以考虑 SA，也可以用KMP的fail。</li>
</ul>
<p><a href="https://www.cnblogs.com/Qing17/p/18419276">细节</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;s[p])&#123;</span><br><span class="line">            p=i,j=<span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fail[j]&amp;&amp;s[p+fail[j]]&lt;s[i])&#123;</span><br><span class="line">            j=fail[j];</span><br><span class="line">            p=i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[p+fail[j]]==s[i])&#123;</span><br><span class="line">            fail[j<span class="number">+1</span>]=fail[j]<span class="number">+1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[p+fail[j]]&gt;s[i])&#123;</span><br><span class="line">            fail[++j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;p&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>日常训练</tag>
      </tags>
  </entry>
  <entry>
    <title>队内训练2</title>
    <url>/2025/02/15/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%832/</url>
    <content><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ea0037oi.png" alt=""></p>
<p>题目来源：2024湖南省赛</p>
<h1 id="A-签到题"><a href="#A-签到题" class="headerlink" title="A 签到题"></a>A 签到题</h1><ul>
<li>模拟</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> t=x;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,k)&#123;</span><br><span class="line">            t%=n;</span><br><span class="line">            w[t]=<span class="number">1</span>;</span><br><span class="line">            t=t*x%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> t=x;</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,k)&#123;</span><br><span class="line">            t%=n;</span><br><span class="line">            <span class="keyword">if</span>(!w[t])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                f=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t*x%n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)<span class="keyword">continue</span>;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-签到题"><a href="#B-签到题" class="headerlink" title="B 签到题"></a>B 签到题</h1><ul>
<li>直接用 <code>log2</code> 更快，因为跟二次方幂有关。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        t+=<span class="built_in">log2</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t=<span class="built_in">ceil</span>(<span class="number">1.</span>*t/<span class="built_in">log2</span>(<span class="number">2024</span>));</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>)t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-子集枚举dp"><a href="#C-子集枚举dp" class="headerlink" title="C 子集枚举dp"></a>C 子集枚举dp</h1><p><img src="https://img2024.cnblogs.com/blog/3495111/202410/3495111-20241018180916745-1648809.png" alt=""></p>
<ul>
<li><p>数很小，可以考虑状态压缩，然后这里是数很小，因此对每个数选和不选进行状态压缩。</p>
</li>
<li><p>此时注意到任意两个字符串相与为 $0$ 则可以合并。求 $1$ 的最多的合并后的串。可以先 $18n$ 枚举处理所有的 $01$ 串。然后 <code>dp</code> 转移拿到最大出现子集，那么 <code>f[x] + f[s^x]</code> 就是答案。其中 <code>f[i]</code> 表示状态为 $i$ 的 $01$ 串从出现的子集转移过来的 $1$ 的个数最多是多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;w[i],w[i]--;</span><br><span class="line">    <span class="comment">//枚举子集dp</span></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,i,<span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(n,i<span class="number">+17</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&amp;(<span class="number">1</span>&lt;&lt;w[j]))<span class="keyword">break</span>;</span><br><span class="line">            p|=(<span class="number">1</span>&lt;&lt;w[j]);</span><br><span class="line">            f[p]=__builtin_popcount(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">17</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[i^(<span class="number">1</span>&lt;&lt;j)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]+f[i^((<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="D-最短路"><a href="#D-最短路" class="headerlink" title="D 最短路"></a>D 最短路</h1><ul>
<li>因为有一个神奇的魔法，因此可以对这个魔法的是否使用搞一个最短路即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;PII&gt; g[N];</span><br><span class="line"><span class="type">int</span> dist[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,id,op;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d==t.d)<span class="keyword">return</span> op&gt;t.op;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;E&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        dist[i][<span class="number">0</span>]=dist[i][<span class="number">1</span>]=a[i];</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;dist[i][<span class="number">0</span>],i,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [d,u,op]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[u][op])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u][op]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,w]:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!op)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[j][<span class="number">0</span>]&gt;dist[u][<span class="number">0</span>]+w)&#123;</span><br><span class="line">                    dist[j][<span class="number">0</span>]=dist[u][<span class="number">0</span>]+w;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j][<span class="number">0</span>],j,<span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dist[j][<span class="number">1</span>]&gt;dist[u][<span class="number">0</span>])&#123;</span><br><span class="line">                    dist[j][<span class="number">1</span>]=dist[u][<span class="number">0</span>];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j][<span class="number">1</span>],j,<span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[j][<span class="number">1</span>]&gt;dist[u][<span class="number">1</span>]+w)&#123;</span><br><span class="line">                    dist[j][<span class="number">1</span>]=dist[u][<span class="number">1</span>]+w;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j][<span class="number">1</span>],j,<span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(dist[i][<span class="number">0</span>],dist[i][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-计算几何-建图-贪心"><a href="#E-计算几何-建图-贪心" class="headerlink" title="E 计算几何+建图+贪心"></a>E 计算几何+建图+贪心</h1><ul>
<li>核心思想就是：枚举任意两点形成的有向边，选择夹角不超过 $90$ 度的其他有向边得到一个有向无环图，图上最长路就是答案。（这样就能把所有情况考虑进去）</li>
<li>因为数很小，因此就可以暴力建图。$O(n^4)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m=<span class="number">1e3</span><span class="number">+10</span>,eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;w[N];</span><br><span class="line"><span class="type">int</span> f[N*N],din[N],ans;</span><br><span class="line"></span><br><span class="line">E <span class="keyword">operator</span>-(E a,E b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_len</span><span class="params">(E a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(a.x*a.x+a.y*a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cross</span><span class="params">(E a,E b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(E a,E b,<span class="type">bool</span> flag)</span></span>&#123;<span class="comment">//选择夹角不超过90度的其他有向边得到一个有向无环图</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cross</span>(a,b)&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cross</span>(a,b)&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> t=(<span class="number">1.</span>*a.x*b.x<span class="number">+1.</span>*a.y*b.y)/(<span class="number">1.</span>*<span class="built_in">get_len</span>(a)*<span class="built_in">get_len</span>(b));</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">0</span>-eps||t<span class="number">-1.0</span>&gt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(E a,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)f[i]=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)din[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(w[i]-w[<span class="number">0</span>],a,flag))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">check</span>(w[j]-w[<span class="number">0</span>],a,flag))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(w[j]-w[i],a,flag))&#123;</span><br><span class="line">                    g[i].<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                    din[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[t])&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[t]<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">if</span>(--(din[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    w[<span class="number">0</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        w[i]=&#123;a,b&#125;;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)&#123;</span><br><span class="line">            f[<span class="number">0</span>]++;</span><br><span class="line">            i--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=f[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                <span class="built_in">get</span>(w[j]-w[i],<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">get</span>(w[j]-w[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-尺取法"><a href="#F-尺取法" class="headerlink" title="F 尺取法"></a>F 尺取法</h1><ul>
<li><p>发现所谓的 <code>beautiful sequence</code>就是长度为 $len$ 的连续数字，比如说长度为 $5$ 那么答案就是 <code>2 3 4 5 6</code>。</p>
</li>
<li><p>所以要解决找这个序列我们可以对值域双指针尺取法。</p>
</li>
<li><p>因为满足连续，那么假设长度为 $5$ 的序列满足，那么所有 $len&lt;5$ 的序列的子序列也是满足的,所以 $ans+=r-l+1$。</p>
</li>
<li><p>然后要判断两个串是否都出现，可以用树状数组来判断。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="type">int</span> posa[N],posb[N];</span><br><span class="line"><span class="type">int</span> tra[N],trb[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adda</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))tra[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addb</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))trb[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">querya</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tra[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryb</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=trb[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i],posa[a[i]]=i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i],posb[b[i]]=i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>,l=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="built_in">adda</span>(posa[r],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addb</span>(posb[r],<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> q1=<span class="built_in">querya</span>(posa[r]);</span><br><span class="line">        <span class="type">int</span> q2=<span class="built_in">queryb</span>(posb[r]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;q1!=q2)&#123;</span><br><span class="line">            <span class="built_in">adda</span>(posa[l],<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">addb</span>(posb[l],<span class="number">-1</span>);</span><br><span class="line">            q1=<span class="built_in">querya</span>(posa[r]);</span><br><span class="line">            q2=<span class="built_in">queryb</span>(posb[r]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=r-l<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G-KMP-DP"><a href="#G-KMP-DP" class="headerlink" title="G KMP+DP"></a>G KMP+DP</h1><ul>
<li><p>因为数据规模不大，而且这道题很类似之前做的 KMP+dp 的题目，但之前那道题是求最长公共子序列不包括特定串的。</p>
</li>
<li><p>这道题是求方案数的并且包括 $\le k$ 的特定串的个数。</p>
</li>
<li><p>因此可以让 $f_{i,j,k}$ 表示当前填到了第 $i$ 个数，填了 $j$ 个特定串个数，当且匹配到了 $k$ 这个字符。</p>
</li>
<li><p>那么状态转移也是很容易的，只不过要先对特定串求 <code>next</code> 数组（也就是border）。这里还得注意的就是对于第 $i$ 个数填什么是得枚举的。</p>
</li>
<li><p>最后的答案就是在匹配的位置加起来。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10010</span>][<span class="number">12</span>][N];</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    m=s.sz;</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j<span class="number">+1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j<span class="number">+1</span>])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,k)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(l,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;c&lt;=<span class="string">&#x27;z&#x27;</span>;c++)&#123;</span><br><span class="line">                    <span class="type">bool</span> pipei=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> p=l;pipei==<span class="number">0</span>;p=ne[p])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[p<span class="number">+1</span>]==c)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(p==m<span class="number">-1</span>)&#123;</span><br><span class="line">                                (f[i<span class="number">+1</span>][j<span class="number">+1</span>][<span class="number">0</span>]+=f[i][j][l])%=mod;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                (f[i<span class="number">+1</span>][j][p<span class="number">+1</span>]+=f[i][j][l])%=mod;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pipei=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!p)<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(pipei)<span class="keyword">continue</span>;</span><br><span class="line">                    (f[i<span class="number">+1</span>][j][<span class="number">0</span>]+=f[i][j][l])%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        (ans+=f[n][k][i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>日常训练</tag>
      </tags>
  </entry>
  <entry>
    <title>好题整理</title>
    <url>/2025/02/05/%E5%A5%BD%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h1><h2 id="2018A-Card-Partition-1600-思维题"><a href="#2018A-Card-Partition-1600-思维题" class="headerlink" title="2018A-Card Partition *1600 思维题"></a>2018A-Card Partition <strong>*1600</strong> 思维题</h2><ul>
<li>这道题就是简单的枚举，因为 $n$ 不大。因此就直接枚举每组分成多少张，这样就能算出组数了，这里的总数是把加的牌也算进去的，这样就是看最坏的情况下能否满足题目条件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int mx=0,s=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],mx=max(mx,w[i]),s+=w[i];</span><br><span class="line"></span><br><span class="line">    int ls=s+k;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int t=ls/i;//假定分成t份</span><br><span class="line">        if(t&gt;=mx&amp;&amp;t*i&gt;=s&amp;&amp;t*i&lt;=ls)ans=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2004D-Colored-Portals-1600"><a href="#2004D-Colored-Portals-1600" class="headerlink" title="2004D-Colored Portals *1600"></a>2004D-Colored Portals <strong>*1600</strong></h2><p><del>真的受不了这种题，看错一个地方调了我一个半小时。</del></p>
<ul>
<li><p>思路很简单，因为只有 $4$ 种颜色取 $2$ 种，那么总共也就有 $6$ 种情况。可以推出答案就两种情况——在同一层、不在同一层（可以证明只需要一个辅助城市即可）</p>
</li>
<li><p>这里取巧：每种颜色组合在每一层出现的最远位置和最近位置记录下来，这里就直接用 <code>vector&lt;array&lt;int,6&gt;&gt;(n+1,&#123;-1,-1,-1,-1,-1,-1&#125;)</code> 来记录，就是这里，我没想到。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,q;</span><br><span class="line">map&lt;string,int&gt;id&#123;&#123;&quot;BG&quot;,1&#125;,&#123;&quot;BR&quot;,2&#125;,&#123;&quot;BY&quot;,3&#125;,&#123;&quot;GR&quot;,4&#125;,&#123;&quot;GY&quot;,5&#125;,&#123;&quot;RY&quot;,6&#125;,</span><br><span class="line">    &#123;&quot;GB&quot;,1&#125;,&#123;&quot;RB&quot;,2&#125;,&#123;&quot;YB&quot;,3&#125;,&#123;&quot;RG&quot;,4&#125;,&#123;&quot;YG&quot;,5&#125;,&#123;&quot;YR&quot;,6&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;a(n+1,0);</span><br><span class="line">    vector&lt;string&gt;s(n+1);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        a[i]=id[s[i]];        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;int,7&gt;&gt;b(n+1,&#123;-1,-1,-1,-1,-1,-1,-1&#125;);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]=b[i-1];</span><br><span class="line">        b[i][a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;int,7&gt;&gt;c(n+2,&#123;-1,-1,-1,-1,-1,-1,-1&#125;);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=6;i++)c[n+1][i]=-1;</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        c[i]=c[i+1];</span><br><span class="line">        c[i][a[i]]=i;</span><br><span class="line">        // cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // cout&lt;&lt;c[2][2]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">        if(x&gt;y)swap(x,y);</span><br><span class="line"></span><br><span class="line">        if(x==y)&#123;</span><br><span class="line">            cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans=1e18;</span><br><span class="line"></span><br><span class="line">        if(s[x][0]==s[y][0]||s[x][0]==s[y][1]||s[x][1]==s[y][0]||s[x][1]==s[y][1])&#123;</span><br><span class="line">            cout&lt;&lt;abs(x-y)&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int t1=a[x],t2=a[y];</span><br><span class="line">        bool f=false;</span><br><span class="line">        // cout&lt;&lt;t1&lt;&lt;&#x27; &#x27;&lt;&lt;t2&lt;&lt;endl;</span><br><span class="line">        for(int i=1;i&lt;=6;i++)&#123;</span><br><span class="line">            if(i!=t1&amp;&amp;i!=t2)&#123;</span><br><span class="line">                // cout&lt;&lt;b[x][i]&lt;&lt;&#x27; &#x27;&lt;&lt;b[y][i]&lt;&lt;&#x27; &#x27;&lt;&lt;c[x][i]&lt;&lt;&#x27; &#x27;&lt;&lt;c[y][i]&lt;&lt;endl;</span><br><span class="line">                if(b[x][i]!=-1||b[y][i]!=-1||c[x][i]!=-1||c[y][i]!=-1)&#123;</span><br><span class="line">                    f=1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(!f)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=6;i++)&#123;</span><br><span class="line">            if(i!=t1&amp;&amp;i!=t2)&#123;</span><br><span class="line">                if(b[x][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(b[x][i]-x)+abs(b[x][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">                if(b[y][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(b[y][i]-x)+abs(b[y][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">                if(c[x][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(c[x][i]-x)+abs(c[x][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">                if(c[y][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(c[y][i]-x)+abs(c[y][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1996E-Decode-1600-前缀和-思维"><a href="#1996E-Decode-1600-前缀和-思维" class="headerlink" title="1996E-Decode *1600 前缀和+思维"></a>1996E-Decode <strong>*1600</strong> 前缀和+思维</h2><ul>
<li>$n$ 很大，要求两个变量的方案和，可以想到<strong>贡献法</strong>。</li>
<li>很容易想到对于某一个满足的如 $11111001111$ 如果满足题意，答案就是 $l\times r$。</li>
<li>有两个变量不好算，因此枚举一个变量：对于每一个 $l,r$，此时固定 $r$，都有：</li>
</ul>
<script type="math/tex; mode=display">ans=l_1*r+l_2*r+l_3*r+...+l_k*r</script><script type="math/tex; mode=display">ans=\sum_{i=1}^{k}{l_k}*r</script><p>因此我们只需要算 $\sum_{i=1}^{k}{l_k}$ 即可，这个我们可以用 <code>map</code> 来解决。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.size();</span><br><span class="line"></span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line">    map&lt;int,int&gt;S;</span><br><span class="line">    S[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i]=sum[i-1]+(s[i]==&#x27;1&#x27;?1:-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+(n-i+1)*(S[sum[i]])%mod)%mod;</span><br><span class="line">        S[sum[i]]+=i+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-6水题3-1600题6"><a href="#2-6水题3-1600题6" class="headerlink" title="2.6水题3+1600题6"></a>2.6水题3+1600题6</h1><h2 id="1994C-Hungry-Games-1600-二分-思维"><a href="#1994C-Hungry-Games-1600-二分-思维" class="headerlink" title="1994C-Hungry Games *1600 二分+思维"></a>1994C-Hungry Games <strong>*1600</strong> 二分+思维</h2><ul>
<li>就是一个二分去划分边界，对于一个左端点为 $i$ 的区间，可以分为两部分，一部分为 $a_i$~$a_q$​，这部分他们的总和就是 $≤x$，显然不涉及到“归零”这个操作，答案直接加上 $q−i−1$。</li>
<li><code>accumulate()</code> 第三个参数是基准值，也就是 $f_1+f_2+…+f_n+t$，$t$ 就是基准值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],s[i]=s[i-1]+w[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;f(n+2);</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=0;i--)&#123;</span><br><span class="line">        int q=upper_bound(s+1,s+1+n,s[i]+k)-s;//ai~aq</span><br><span class="line">        f[i]=f[q]+q-i-1;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;accumulate(f.begin(),f.end(),0ll)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>错误次数：2</p>
<p>错误原因：已经想到二分/双指针去做，但没有深入思考边界的处理。</p>
</blockquote>
<h2 id="1978D-Elections-1600-思维-前缀和"><a href="#1978D-Elections-1600-思维-前缀和" class="headerlink" title="1978D-Elections *1600 思维+前缀和"></a>1978D-Elections <strong>*1600</strong> 思维+前缀和</h2><p>思路很清晰，答案就三种情况：0，i，i-1。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    w[1]+=k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=max(pre[i-1],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        suf[i]=max(suf[i+1],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t=*max_element(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    int cnt=0,id=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(t==w[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(t==w[i])&#123;</span><br><span class="line">            id=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(w[1]&gt;=t)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;0 &quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;1 &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(w[i]&gt;=t)&#123;</span><br><span class="line">            if(w[i]==t&amp;&amp;cnt!=1&amp;&amp;i!=id)&#123;</span><br><span class="line">                cout&lt;&lt;i-1&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cout&lt;&lt;0&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int ans=i-1;</span><br><span class="line">            if(s[i]&lt;t)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>错误次数：2</p>
<p>错误原因：要用前缀和去比较</p>
</blockquote>
<h2 id="1956C-Nene’s-Magical-Matrix-1600-构造"><a href="#1956C-Nene’s-Magical-Matrix-1600-构造" class="headerlink" title="1956C-Nene’s Magical Matrix *1600 构造"></a>1956C-Nene’s Magical Matrix <strong>*1600</strong> 构造</h2><ul>
<li>构造方案是行和列的赋值，其实通过多次画图可以知道：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">2 2 3 4 5</span><br><span class="line">3 3 3 4 5</span><br><span class="line">4 4 4 4 5</span><br><span class="line">5 5 5 5 5</span><br></pre></td></tr></table></figure></li>
<li>这种方案是最优的，而且要输出方案也很好写，我们只需要从外到内而且排列都不需要变换。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        ans+=(i*i+(i+1+n)*(n-i)/2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27; &#x27;&lt;&lt;n*2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    FORD(i,1,n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;1 &quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        FOR(j,1,n)cout&lt;&lt;j&lt;&lt;&quot; \n&quot;[j==n];</span><br><span class="line">        cout&lt;&lt;&quot;2 &quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        FOR(j,1,n)cout&lt;&lt;j&lt;&lt;&quot; \n&quot;[j==n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误次数：1</p>
<p>错误原因：布置行了后面开始考虑列的时候忽略了行的修改。</p>
</blockquote>
<h2 id="1957C-How-Does-the-Rook-Move-1600-排列组合"><a href="#1957C-How-Does-the-Rook-Move-1600-排列组合" class="headerlink" title="1957C-How Does the Rook Move? *1600 排列组合"></a>1957C-How Does the Rook Move? <strong>*1600</strong> 排列组合</h2><ul>
<li>这种就是画个图枚举，可以发现:</li>
<li><ul>
<li>如果你画在对角线上机器人就没有地方画了，此时就是随便放，方案也就是 $C_{n}^{i}$，其中 $n$ 表示之前下完棋剩下棋盘的行数，$i$ 表示下了 $i$ 次放在对角线的棋，<strong>这里的 $n-i$ 是偶数，如果不是的情况下，那么会对下面不在对角线的情况下会下不完剩余的列</strong>。</li>
</ul>
</li>
<li><ul>
<li>除对角线画，一共有 $C_{n-i}^{j}\times j!$，$j=\frac{n-i}{2}$。</li>
</ul>
</li>
<li>那么答案就是二者乘积之和。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b/=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init(int x)&#123;</span><br><span class="line">    fac[0]=infac[0]=1;</span><br><span class="line">    FOR(i,1,x)&#123;</span><br><span class="line">        fac[i]=fac[i-1]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infac[x]=qmi(fac[x],mod-2);</span><br><span class="line"></span><br><span class="line">    FORD(i,1,x-1)&#123;</span><br><span class="line">        infac[i]=infac[i+1]*(i+1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int C(int x,int y)&#123;</span><br><span class="line">    return fac[x]*infac[y]%mod*infac[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    map&lt;int,int&gt;S;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,k)&#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">        S[x[i]]=S[y[i]]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n=n-S.size();</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FOR2(i,n&amp;1,n)&#123;</span><br><span class="line">        int j=(n-i)/2;</span><br><span class="line">        ans=(ans+C(n,i)*C(n-i,j)%mod*fac[j]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1971F-Circle-Perimeter-1600-数学"><a href="#1971F-Circle-Perimeter-1600-数学" class="headerlink" title="1971F-Circle Perimeter *1600 数学"></a>1971F-Circle Perimeter <strong>*1600</strong> 数学</h2><p><del>服了，我怎么会一直往那个 <strong>皮克定理</strong> 那边去想</del></p>
<ul>
<li>公式推导：</li>
</ul>
<script type="math/tex; mode=display">r\le \sqrt{x^2+y^2} < r+1</script><script type="math/tex; mode=display">r^2\le x^2+y^2<(r+1)^2</script><script type="math/tex; mode=display">r^2-y^2\le x^2 <(r+1)^2-y^2</script><script type="math/tex; mode=display">\sqrt{r^2-y^2}\le x<\sqrt{(r+1)^2-y^2}</script><ul>
<li><p>那么 $x<em>{min}=\lfloor \sqrt{r^2-y^2} \rfloor$ ，$x</em>{max}=\lceil\sqrt{(r+1)^2-y^2} \rceil$</p>
</li>
<li><p>此时直接枚举 $y$ 就可以算出 $x$ 了，最后答案 $\times 4$ 就可以了。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int mx=floor(sqrt((n+1)*(n+1)-i*i-0.5));</span><br><span class="line">        int mn=ceil(sqrt(n*n-i*i));</span><br><span class="line">        ans+=mx-mn+1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*4&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误次数： 1</p>
<p>错误原因：皮克定理是用来算多边形的面积跟整点数的关系，圆的面积不是定数，如果要用的话很难取 $eps$，因此最好不用。</p>
</blockquote>
<h2 id="1976C-Job-Interview-1600-思维"><a href="#1976C-Job-Interview-1600-思维" class="headerlink" title="1976C-Job Interview *1600 思维"></a>1976C-Job Interview <strong>*1600</strong> 思维</h2><ul>
<li>总共的职位数只有 $n+m$ 个，但总共有 $n+m+1$ 个人，为了更好的讨论，这里直接不选最后一个人，此时就很好做了，用的是贪心。</li>
<li>这里我是用 $vis_i$ 表示第 $i$ 个人被选上测试职业，$ca$ 表示选了 $ca$ 个程序员，$f_i$ 表示该人不被选上个人可以<strong>多</strong>获得的价值。</li>
<li>此时的 $f_i$ 此时就是一个差值（变化量），默认不选最后一个人的答案是 $ans$。</li>
<li>然后，发现如果改为不选第 $i$ 个人，实际上就是让下一个原本要选某一个职业但是没法选的人选某一个职业​ 然后还要有下一个人顶替他选的岗位，以此类推。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n+m+1;i++)cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=n+m+1;i++)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;f(n+m+2,0),vis(n+m+2,0);</span><br><span class="line"></span><br><span class="line">    int ca=0,cb=0,ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n+m;i++)&#123;//默认不选最后一个</span><br><span class="line">        if(ca==n)ans+=b[i],vis[i]=0;</span><br><span class="line">        else if(cb==m)ans+=a[i],vis[i]=1;</span><br><span class="line">        else if(a[i]&gt;b[i])vis[i]=1,ans+=a[i],ca++;</span><br><span class="line">        else ans+=b[i],vis[i]=0,cb++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ca=n+m+1,cb=n+m+1;</span><br><span class="line"></span><br><span class="line">    for(int i=n+m;i;i--)&#123;</span><br><span class="line">        if(ca==n+m+1&amp;&amp;vis[i])f[i]=f[ca]+a[ca];</span><br><span class="line">        else if(cb==n+m+1&amp;&amp;!vis[i])f[i]=f[cb]+b[cb];</span><br><span class="line">        else if(vis[i])f[i]=f[ca]+a[ca]-b[ca];</span><br><span class="line">        else f[i]=f[cb]+b[cb]-a[cb];</span><br><span class="line">        if(vis[i]&amp;&amp;b[i]&gt;a[i])cb=i;</span><br><span class="line">        else if(!vis[i]&amp;&amp;b[i]&lt;a[i])ca=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n+m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;(ans-(vis[i]?a[i]:b[i])+f[i])&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>没想出来这么做，憨了</del></p>
</blockquote>
<h2 id="HDU-6702-amp-位运算"><a href="#HDU-6702-amp-位运算" class="headerlink" title="HDU-6702-&amp; 位运算"></a>HDU-6702-&amp; 位运算</h2><ul>
<li>容易发现要让答案最小，对每一位进行分析很容易发现，当 $a,b$ 在同一位均为 $1$ 的情况下，此时 $c$ 填 $1$.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=34;i&gt;=0;i--)&#123;</span><br><span class="line">        if((a&gt;&gt;i&amp;1)&amp;&amp;(b&gt;&gt;i&amp;1))&#123;</span><br><span class="line">            ans|=(1ull&lt;&lt;(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans==0)&#123;</span><br><span class="line">        if(((a^0)&amp;(b^0))==0)&#123;</span><br><span class="line">            cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-6707-Shuffle-Card-STL：栈"><a href="#HDU-6707-Shuffle-Card-STL：栈" class="headerlink" title="HDU-6707-Shuffle Card STL：栈"></a>HDU-6707-Shuffle Card STL：栈</h2><ul>
<li>没什么好说的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    stack&lt;int&gt;stk;</span><br><span class="line"></span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        stk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(stk.size())&#123;</span><br><span class="line">        int x=stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        if(!vis[x])&#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!vis[w[i]])&#123;</span><br><span class="line">            cout&lt;&lt;w[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-6708-Windows-Of-CCPC找规律"><a href="#HDU-6708-Windows-Of-CCPC找规律" class="headerlink" title="HDU-6708-Windows Of CCPC找规律"></a>HDU-6708-Windows Of CCPC找规律</h2><ul>
<li>根据这个: <img src="https://cdn.vjudge.net.cn/afbcb5c2cef9da397ceb1c5aadddc45b?v=1723071497" alt=""></li>
</ul>
<p>和：</p>
<p><img src="https://cdn.vjudge.net.cn/cba282549674e44e31536068319c9ff8?v=1723071497" alt=""></p>
<ul>
<li><p>又因为数组的大小是 $2$ 的幂次方且都是从 $2^{n-1}$ 得到，因此我们可以对上述字母分块，我们可以很容易发现：第一块和第四块是相同的，第二块和第三块是相同的。</p>
</li>
<li><p>块数划分编号：</p>
</li>
</ul>
<p>1 2 3 4</p>
<ul>
<li>然后直接打表就可以了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init()&#123;</span><br><span class="line">    s[1][1]=s[1][2]=s[2][2]=&#x27;C&#x27;;</span><br><span class="line">    s[2][1]=&#x27;P&#x27;;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=10;i++)&#123;</span><br><span class="line">        int l=pow(2,i-1);</span><br><span class="line">        int r=pow(2,i);</span><br><span class="line">        for(int j=1;j&lt;=l;j++)&#123;</span><br><span class="line">            for(int k=l+1;k&lt;=r;k++)&#123;</span><br><span class="line">                s[j+l][k]=s[j][k]=s[j][k-l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=l;j++)&#123;</span><br><span class="line">            for(int k=1;k&lt;=l;k++)&#123;</span><br><span class="line">                s[j+l][k]=(s[j][k]==&#x27;C&#x27;?&#x27;P&#x27;:&#x27;C&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    n=pow(2,n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-7-1600-1800乱刷"><a href="#2-7-1600-1800乱刷" class="headerlink" title="2.7 1600-1800乱刷"></a>2.7 1600-1800乱刷</h1><p><del>今天感觉什么事情都没干，昨晚睡太晚导致今天早上起不来，然后打算下午睡个觉，没想到又浪费了很多时间，服了，今天约等于也就只有5个小时刷题时间，太少了，而且做的又少，难受，今晚又做题做累了，明天又很冷，不知道会不会起得来。</del></p>
<p>这几天计划是刷1600-2400的题，康复训练，已经很久没有做 <code>codeforces</code> 的题了。</p>
<h2 id="1946C-Tree-Cutting-1600-二分-dfs"><a href="#1946C-Tree-Cutting-1600-二分-dfs" class="headerlink" title="1946C-Tree Cutting *1600 二分+dfs"></a>1946C-Tree Cutting <strong>*1600</strong> 二分+dfs</h2><ul>
<li>这个一看肯定跟子树有关系，因此就得维护 <code>siz</code> 数组。</li>
<li>如果选某一条边，此时就让它的 <code>siz</code> 清零，这样不会对后面产生影响。</li>
<li>题目的答案具有单调性（如果给的答案太大了，可以通过缩小区间来减小答案的范围），可以很容易写出二分。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    VII g(n+1);</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-1)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        g[b].emplace_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;siz(n+1,0);</span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    function&lt;void(int,int,int)&gt; dfs=[&amp;](int u,int fa,int lim)&#123;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        for(auto&amp; j:g[u])&#123;</span><br><span class="line">            if(j==fa)continue;</span><br><span class="line">            dfs(j,u,lim);</span><br><span class="line">            siz[u]+=siz[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(siz[u]&gt;=lim)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            siz[u]=0;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(u==1&amp;&amp;siz[u]&lt;lim&amp;&amp;cnt==k)cnt=0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function&lt;bool(int)&gt;check=[&amp;](int x)&#123;</span><br><span class="line">        siz.clear();</span><br><span class="line">        cnt=0;</span><br><span class="line">        dfs(1,0,x);</span><br><span class="line">        return cnt&lt;=k;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int l=0,r=n+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>总结：思路很简单的，认真考虑是可以很快的想出来。</p>
</blockquote>
<h2 id="2020C-Bitwise-Balancing-1600-位运算"><a href="#2020C-Bitwise-Balancing-1600-位运算" class="headerlink" title="2020C-Bitwise Balancing *1600 位运算"></a>2020C-Bitwise Balancing <strong>*1600</strong> 位运算</h2><ul>
<li>这道题就直接枚举每一位做，然后发现如果在第 $i$ 位下，$b=1,c=0,d=1$，这种情况是允许的，还有就是 $b=0,c=1,d=1$ 也是允许的，其他情况均不行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">    int a=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,61)&#123;</span><br><span class="line">        int x,y,z;</span><br><span class="line">        x=((b&gt;&gt;i)&amp;1);</span><br><span class="line">        y=((c&gt;&gt;i)&amp;1);</span><br><span class="line">        z=((d&gt;&gt;i)&amp;1);</span><br><span class="line">        if(x!=z)&#123;</span><br><span class="line">            if(1-y!=z)&#123;</span><br><span class="line">                cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">                return;    </span><br><span class="line">            &#125;</span><br><span class="line">            a|=(1ll&lt;&lt;(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：位运算的题很多情况下都得按位看，然后有的时候可能会用枚举答案的思想来做题。</p>
</blockquote>
<h2 id="2035C-Alya-and-Permutation-1600-构造-位运算"><a href="#2035C-Alya-and-Permutation-1600-构造-位运算" class="headerlink" title="2035C-Alya and Permutation *1600 构造+位运算"></a>2035C-Alya and Permutation <strong>*1600</strong> 构造+位运算</h2><ul>
<li>这种题你乍一看很没有思路，此时可以发现不同点：奇数和偶数它们的答案是不同的。这点可以通过样例来看。</li>
<li>因为奇数最后一次操作是与，因为与会使答案$\le n$，所以盲猜答案是 $n$。</li>
<li>因为偶数最后一次操作是或，或能让答案 $&gt;=n$，所以很容易知道答案肯定是 $2^{\lfloor{\log_{2}n}\rfloor}-1$。</li>
<li>其实最关键的是答案的构造，这里分类讨论。</li>
<li><ul>
<li>奇数：因为最后一次操作是与，然后最后一位数肯定是与 $n$，那么 $n$ 的前面操作也要使得结果为 $n$，要不然结果就不会等于 $n$ 了。发现 $1,n-1,n$ 这种组合可以，因为是先与 $1$，此时你不管前面如何，最低位必为 $1$（因为 $n$ 是奇数）。</li>
</ul>
</li>
<li><ul>
<li>偶数：因为最后一次操作是或，那么你要让答案等于 $2^{\lfloor{\log_{2}n}\rfloor+1}-1$，就得让除最高位外其余的均为 $1$，然后在此数前面的只需要提供最高位即可。那么 $n,n-1,2^{\lfloor{\log_{2}n}\rfloor}-1$ 满足要求。</li>
</ul>
</li>
<li><ul>
<li>偶数还有一种特殊情况，就是很有可能 $n=2^{\lfloor{\log_{2}n}\rfloor}$，那么前面就不能有 $n-1$，此时 $1,n-3,n-2,n-1,n$ 满足条件。因为 $n-1$ 的二进制就是全 $1$ 的数字，但你肯定不能让 $n-1$ 消失，又因为 $n-1$ 前的操作符是与，为了让 $n-1$ 能够完整的传承下去，那么必须得让前面的数字的结果为 $n-1$，那么 $1,n-3,n-2$ 符合条件。</li>
</ul>
</li>
</ul>
<p><del>就是这道题，浪费了我1个多小时的时间，真憨了。</del></p>
<ul>
<li>最后的代码也是特别的短。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    if(n&amp;1)&#123;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        FOR(i,1,n-4)cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        cout&lt;&lt;1&lt;&lt;&#x27; &#x27;&lt;&lt;n-2&lt;&lt;&#x27; &#x27;&lt;&lt;n-1&lt;&lt;&#x27; &#x27;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int t=log2(n);</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;(int(pow(2,t+1))-1)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        if((int)pow(2,t)==n)&#123;</span><br><span class="line">            FOR(i,1,n-5)cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            cout&lt;&lt;1&lt;&lt;&#x27; &#x27;&lt;&lt;n-3&lt;&lt;&#x27; &#x27;&lt;&lt;n-2&lt;&lt;&#x27; &#x27;&lt;&lt;n-1&lt;&lt;&#x27; &#x27;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            FOR(i,1,(int)(pow(2,t)-2))cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            FOR(i,(int)pow(2,t),n-2)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;n-1&lt;&lt;&#x27; &#x27;&lt;&lt;(int)pow(2,t)-1&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有认真考虑偶数的关系，偶数还有一种情况没有考虑到。</p>
</blockquote>
<h2 id="1932E-Final-Countdown-1600-贡献法-高精度"><a href="#1932E-Final-Countdown-1600-贡献法-高精度" class="headerlink" title="1932E-Final Countdown*1600 贡献法+高精度"></a>1932E-Final Countdown<strong>*1600</strong> 贡献法+高精度</h2><ul>
<li>思路特别简单，就是去算：比如123，答案就是123+12+1。</li>
<li>但这边得优化一下，就是按每一位来做，此时前缀和来做就可以了，前缀和是维护位数数字的和的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    VI sum(n),C;</span><br><span class="line"></span><br><span class="line">    sum[0]=s[0]-&#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-1)&#123;</span><br><span class="line">        sum[i]=sum[i-1]+s[i]-&#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t=0;</span><br><span class="line"></span><br><span class="line">    FORD(i,0,n-1)&#123;</span><br><span class="line">        t+=sum[i];</span><br><span class="line">        C.pb(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t)C.pb(t);</span><br><span class="line"></span><br><span class="line">    while(C.sz&gt;1&amp;&amp;C.back()==0)C.pop_back();</span><br><span class="line"></span><br><span class="line">    reverse(ALL(C));</span><br><span class="line"></span><br><span class="line">    for(auto x:C)cout&lt;&lt;x;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>错误次数：1</p>
<p>错误原因：没有对操作优化，单纯相加很耗时的。</p>
</blockquote>
<h2 id="1928C-Physical-Education-Lesson-1600-数学"><a href="#1928C-Physical-Education-Lesson-1600-数学" class="headerlink" title="1928C-Physical Education Lesson *1600 数学"></a>1928C-Physical Education Lesson <strong>*1600</strong> 数学</h2><ul>
<li><p>这道题可以很容易知道：题目的函数的周期 $T=2(k-1)$。</p>
</li>
<li><p>然后要求的是 $k$，然后可以知道求的东西是： <script type="math/tex">n\equiv x (\mod 2(k-1))</script></p>
</li>
<li><p>以及： <script type="math/tex">n\equiv 2k-x (\mod 2(k-1)) \iff n\equiv 2-x(\mod 2(k-1))</script></p>
</li>
<li><p>所以题目就转化成了求满足以上两个式子不同的 $k$ 的个数。</p>
</li>
<li><p><strong>特别知道：$a\equiv b(\mod x)$，求 $x$ 的个数，那么也就是求 $a-b|x$的个数，此时就转化成了求 $a-b$ 因子的个数</strong>。</p>
</li>
<li><p>注意：当 $x=k$ 的时候，会多算一次；因子必须是<strong>偶数</strong>，因为是 $2(k-1)$，这个数是偶数。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int i,int b,int x)&#123;</span><br><span class="line">    int k=i/2+1;</span><br><span class="line">    if(!(i&amp;1)&amp;&amp;i&gt;=2&amp;&amp;(k&gt;=x)&amp;&amp;!(b!=x&amp;&amp;(k==x)))return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calc(int a,int b,int x)&#123;</span><br><span class="line">    int p=a-b,res=0;</span><br><span class="line">    for(int i=1;i&lt;=p/i;i++)&#123;</span><br><span class="line">        if(p%i==0)&#123;</span><br><span class="line">            if(check(i,b,x))res++;</span><br><span class="line">            if(i!=p/i)&#123;</span><br><span class="line">                if(check(p/i,b,x))res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    int res=calc(n,x,x);</span><br><span class="line">    if(x!=1)res+=calc(n,2-x,x);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：卡在黑体部分内容。</p>
</blockquote>
<h2 id="510C-Fox-And-Names-1600-拓扑序"><a href="#510C-Fox-And-Names-1600-拓扑序" class="headerlink" title="510C-Fox And Names *1600 拓扑序"></a>510C-Fox And Names <strong>*1600</strong> 拓扑序</h2><ul>
<li>又是一道把字母转化到图的题目。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;s[i];</span><br><span class="line"></span><br><span class="line">    string s2=s[1],s1;</span><br><span class="line"></span><br><span class="line">    VII g(300);</span><br><span class="line">    VI din(300,0),ans;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        s1=s[i];</span><br><span class="line"></span><br><span class="line">        int a=0;</span><br><span class="line">        </span><br><span class="line">        int m=min&lt;int&gt;(s1.sz,s2.sz);</span><br><span class="line"></span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            if(s1[a]!=s2[a])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(a&gt;=m&amp;&amp;s2.sz&gt;s1.sz)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // cout&lt;&lt;s2[a]&lt;&lt;&#x27; &#x27;&lt;&lt;s1[a]&lt;&lt;endl;</span><br><span class="line">        if(s2[a]&gt;=&#x27;a&#x27;)&#123;</span><br><span class="line">            g[s2[a]].emplace_back(s1[a]);</span><br><span class="line">            din[s1[a]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        s2=s1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line"></span><br><span class="line">    FOR(i,&#x27;a&#x27;,&#x27;z&#x27;)&#123;</span><br><span class="line">        if(!din[i])q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(q.sz)&#123;</span><br><span class="line">        int t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ans.pb(t);</span><br><span class="line">        for(auto x:g[t])&#123;</span><br><span class="line">            --din[x];</span><br><span class="line">            if((din[x])==0)&#123;</span><br><span class="line">                q.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans.sz&lt;26)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(auto x:ans)cout&lt;&lt;char(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：对于很多字符的题目要找什么关系的时候，往往会转化到图<del>（还记得ICPC杭州区域赛A题用的也是字符串的关系建图）</del></p>
</blockquote>
<h2 id="Maximum-AND-1800-位运算"><a href="#Maximum-AND-1800-位运算" class="headerlink" title="Maximum AND *1800 位运算"></a>Maximum AND <strong>*1800</strong> 位运算</h2><p><del>不得不说位运算的挺有意思的，出题人总有很特殊的角度进行考察。</del></p>
<ul>
<li>$b$ 数组是可以任意排序的。</li>
<li>因为是先异或再与的，可以发现：要让最后的结果最大，那肯定对于每一位来说都要有 $1$ 是最好的。</li>
<li>可以发现：$0 \^\ 1 =1$，那么可以知道 $a$ 数组的 $0$ 的个数是可以跟 $b$ 数组的 $1$ 数组是相等的（前提是在第 $i$ 位的情况下），反过来也相等。</li>
<li>那么也就是说匹配是相同的。</li>
<li>此时就可以先枚每一位，如果答案的这一位要是 $1$ 的情况下，那么必须让 $a$ 数组和 $b$ 数组的匹配是相同的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int t)&#123;</span><br><span class="line">    VI x,y;</span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        x.pb(a[i]&amp;t);</span><br><span class="line">        y.pb((b[i]&amp;t)^t);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ALL(x));</span><br><span class="line">    sort(ALL(y));</span><br><span class="line">    return x==y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;a[i];</span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FORD(i,0,30)&#123;</span><br><span class="line">        if(check(ans|(1ll&lt;&lt;i)))&#123;</span><br><span class="line">            ans|=(1&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有想到每一位的匹配是相同的。</p>
</blockquote>
<h1 id="2-8-专题速练-水题乱刷"><a href="#2-8-专题速练-水题乱刷" class="headerlink" title="2.8 专题速练+水题乱刷"></a>2.8 专题速练+水题乱刷</h1><p><del>今天特别冷，我靠，手放在键盘上一种冻僵的感觉很难受，所以今天的做题体验是特别的差，但今天算下来我也收获了挺多。</del></p>
<p><del>后面决定启动仪式的时候得做几道水题，要不然没有状态。</del></p>
<h2 id="1920C-Partitioning-the-Array-1600-数学"><a href="#1920C-Partitioning-the-Array-1600-数学" class="headerlink" title="1920C-Partitioning the Array *1600 数学"></a>1920C-Partitioning the Array <strong>*1600</strong> 数学</h2><ul>
<li>要分成 $k$ 份，那么 $k$ 必须是 $n$ 的因数。</li>
<li>要让每个组的数相同，那么也就是让 $a<em>i \equiv a</em>{i+k}(\mod m)$，那么算这个之前做过类似的，就是变成： $a<em>i -a</em>{i+k}\equiv 0(\mod m)$，也就是 $|a<em>i-a</em>{i+k}|$ 能被 $m$ 整除，那么 $m$ 也就是它的因数。</li>
<li>要求 $m$ 的个数也就是求 $|a<em>i-a</em>{i+k}|$ 的最小公倍数。</li>
<li><p>如果最小公倍数等于 $1$ 则不满足条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    int t=0;</span><br><span class="line">    FOR(i,x+1,n)&#123;</span><br><span class="line">        t=__gcd(t,abs(w[i]-w[i-x]));</span><br><span class="line">        if(t==1)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n/i;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            if(check(i))res++;</span><br><span class="line">            if(i!=n/i&amp;&amp;check(n/i))res++;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>最关键的是得考虑多个数都能被 $x$ 整除，那么 $x$ 是它们的最小公倍数。</p>
</blockquote>
<h2 id="1899F-Alex’s-whims-1600-思维-构造"><a href="#1899F-Alex’s-whims-1600-思维-构造" class="headerlink" title="1899F-Alex’s whims *1600 思维+构造"></a>1899F-Alex’s whims <strong>*1600</strong> 思维+构造</h2><ul>
<li>这就是骗分题，直接让树是一条链，此时的边长是 $n-1$。</li>
<li>然后如果 $d\&lt;n-1$，此时就断开 $(n,n-1)$，连接 $(n,d)$<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-1)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;i+1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    int t=n-1;</span><br><span class="line"></span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int d;</span><br><span class="line">        cin&gt;&gt;d;</span><br><span class="line">        if(d==t)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1 -1 -1&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;&#x27; &#x27;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">            t=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>最关键的就是能想到是一条链，然后在链条上修修补补就可以了。因此对于构造题，可以想象特殊情况是什么，这样就能更好的构造了。（<del>千万不要被难度吓到，其实有的难度是虚高的</del>）</p>
</blockquote>
<h2 id="1801A-The-Very-Beautiful-Blanket-1600-构造"><a href="#1801A-The-Very-Beautiful-Blanket-1600-构造" class="headerlink" title="1801A-The Very Beautiful Blanket *1600 构造"></a>1801A-The Very Beautiful Blanket <strong>*1600</strong> 构造</h2><ul>
<li>嘿嘿，我直接看样例发现这样构造可以满足：</li>
</ul>
<script type="math/tex; mode=display">0\ 1 \ 4\ 5</script><script type="math/tex; mode=display">2\ 3 \ 6 \ 7</script><script type="math/tex; mode=display">512 \ 513 \ 516 \ 517</script><script type="math/tex; mode=display">514 \ 515 \ 518 \ 518</script><ul>
<li>这个也很容易证明：$a\oplus a+1 \oplus a+2 \oplus a+3 =0$（<del>这个非常重要，很多时候都会用到</del>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;n*m&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    w[1][1]=0,w[1][2]=1,w[2][1]=2,w[2][2]=3;</span><br><span class="line"></span><br><span class="line">    FOR2(i,3,n)&#123;</span><br><span class="line">        w[i][1]=w[i-2][1]+512,w[i][2]=w[i-2][2]+512;</span><br><span class="line">        w[i+1][1]=w[i-1][1]+512,w[i+1][2]=w[i-1][2]+512;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR2(j,3,m)&#123;</span><br><span class="line">        FOR(i,1,n)&#123;</span><br><span class="line">            w[i][j]=w[i][j-2]+4;</span><br><span class="line">            w[i][j+1]=w[i][j-1]+4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            cout&lt;&lt;w[i][j]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造题哈哈哈。</p>
</blockquote>
<h2 id="1707A-Doremy’s-IQ-1600-贪心-正难则反思想"><a href="#1707A-Doremy’s-IQ-1600-贪心-正难则反思想" class="headerlink" title="1707A-Doremy’s IQ *1600 贪心+正难则反思想"></a>1707A-Doremy’s IQ <strong>*1600</strong> 贪心+正难则反思想</h2><ul>
<li>这道题一上来其实可以知道对于每个物品有 <strong>选</strong> 和 <strong>不选</strong> 两种情况，对于这种情况，通常的方法有：<code>dfs</code> ，<code>01背包</code>，<code>贪心</code>。</li>
<li>发现数据规模大，因此选择贪心。</li>
<li>如果选择正向贪心的话，可以发现后效性非常严重，根本不确定某个比赛到底要不要选，因此考虑反向贪心。</li>
<li>可以无脑先选最后一个，然后往前推，直到智商增加到了 $k$。</li>
</ul>
<blockquote>
<p>Q：那为什么这样贪心能保证没有后效性呢？</p>
<p>A：1. 反向能使得智商没有得到浪费。</p>
<ol>
<li><p>能使得智商不减的操作（见代码的注释 <code>//</code> 处）变得更多。</p>
</li>
<li><p>如果正着来的话起点的选择是多样的。</p>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i];</span><br><span class="line">    </span><br><span class="line">    int k=0;</span><br><span class="line">    string ans;</span><br><span class="line">    ans.resize(n+1);</span><br><span class="line">    </span><br><span class="line">    FORD(i,1,n)&#123;</span><br><span class="line">        if(k&gt;=w[i])ans[i]=&#x27;1&#x27;;//这个会更多</span><br><span class="line">        else if(k&lt;q)ans[i]=&#x27;1&#x27;,k++;</span><br><span class="line">        else if(k&gt;q)break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cout&lt;&lt;(ans[i]?1:0);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1137B-Camp-Schedule-1600-KMP"><a href="#1137B-Camp-Schedule-1600-KMP" class="headerlink" title="1137B-Camp Schedule *1600 KMP"></a>1137B-Camp Schedule <strong>*1600</strong> KMP</h2><ul>
<li>如果纯纯贪心得考虑一种情况 <code>10101</code>，这个是被算作两次的 <code>101</code>。</li>
<li>如果单纯贪心的话这种情况是考虑不到的。</li>
<li>因此就得用 kMP 的 <code>next</code> 数组了。</li>
<li>此时如果匹配到了 <code>101</code>，那么就用 <code>next</code> 数组，此时 <code>next=1</code>，这样就不会出现输出结果为：<code>101101</code> 了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    scanf(&quot;%s %s&quot;,a+1,b+1);</span><br><span class="line"></span><br><span class="line">    n=strlen(a+1),m=strlen(b+1);</span><br><span class="line"></span><br><span class="line">    int j=0;</span><br><span class="line">    FOR(i,2,m)&#123;</span><br><span class="line">        while(j&amp;&amp;b[j+1]!=b[i])j=ne[j];</span><br><span class="line">        if(b[j+1]==b[i])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cnt[a[i]]++;</span><br><span class="line"></span><br><span class="line">    int t=1;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        if(cnt[b[t]])ans[i]=b[t],cnt[ans[i]]--;</span><br><span class="line">        else ans[i]=(b[t]^1),cnt[ans[i]]--;</span><br><span class="line">        if(t==m)t=ne[t];</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cout&lt;&lt;ans[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有想到 KMP 还可以这样被应用，<code>next</code> 数组用法。</p>
</blockquote>
<h2 id="346C-Lucky-Common-Subsequence-2000-dp-KMP"><a href="#346C-Lucky-Common-Subsequence-2000-dp-KMP" class="headerlink" title="346C-Lucky Common Subsequence *2000 dp+KMP"></a>346C-Lucky Common Subsequence <strong>*2000</strong> dp+KMP</h2><ul>
<li>如果没有 $virus$ 数组的话，那么这道题就是很典型的 <code>LCS</code> 的题目，dp 方程也就很好写了：<code>f[i][j]</code> 表示 $s_1$ 前 $i$ 个字符和 $s_2$ 前 $j$ 个字符能匹配的最长公共子序列，转移也就很好写了。</li>
<li>这道题多一个匹配，匹配就得请 KMP 出场了，此时 <code>f[i][j][k]</code> 表示：设当第一个串匹配到 $i$ 位，第二个串匹配到 $j$ 位时，能匹配到第三个串的 $k$ 位的最长公共子序列的方案。</li>
<li>状态转移方程：</li>
<li>$f<em>{i,j,t}=max{f</em>{i,j,t},f<em>{i-1,j-1,k}+s_1{_i}}f</em>{i,j,k}=max{f<em>{i-1,j,k},f</em>{i,j-1,k},f_{i,j,k}}$</li>
<li>这里特别要注意一下范围，范围是 $[0,virus.size()-1]$，为什么呢？因为可以不匹配也可以最多匹配到最后一个字母的前一个字母。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string max(string a,string b)&#123;</span><br><span class="line">    if(a.sz&gt;b.sz)&#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3;</span><br><span class="line">    </span><br><span class="line">    la=s1.sz,lb=s2.sz,lc=s3.sz;</span><br><span class="line">    s1=&#x27; &#x27;+s1,s2=&#x27; &#x27;+s2,s3=&#x27; &#x27;+s3;</span><br><span class="line"></span><br><span class="line">    if(la&gt;lb)&#123;</span><br><span class="line">        swap(la,lb);</span><br><span class="line">        swap(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int j=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,lc)&#123;</span><br><span class="line">        while(j&amp;&amp;s3[j+1]!=s3[i])j=ne[j];</span><br><span class="line">        if(s3[j+1]==s3[i])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,la)&#123;</span><br><span class="line">        FOR(j,1,lb)&#123;</span><br><span class="line">            FOR(k,0,lc-1)&#123;</span><br><span class="line">                if(s1[i]==s2[j])&#123;</span><br><span class="line">                    int t=k;</span><br><span class="line">                    while(t&gt;0&amp;&amp;s1[i]!=s3[t+1])&#123;</span><br><span class="line">                        t=ne[t];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(s1[i]==s3[t+1])t++;</span><br><span class="line">                    f[i][j][t]=max(f[i][j][t],f[i-1][j-1][k]+s1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                f[i][j][k]=max(f[i][j][k],f[i-1][j][k]);</span><br><span class="line">                f[i][j][k]=max(f[i][j][k],f[i][j-1][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string ans;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,lc-1)&#123;</span><br><span class="line">        if(f[la][lb][i].sz&gt;=ans.sz)&#123;</span><br><span class="line">            ans=f[la][lb][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans.sz==0)&#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类似这种匹配的还是得把 KMP 放在考虑的范围上。</p>
</blockquote>
<h2 id="59E-Shortest-Path-2000-最短路-hash-路径记录"><a href="#59E-Shortest-Path-2000-最短路-hash-路径记录" class="headerlink" title="59E-Shortest Path *2000 最短路+hash+路径记录"></a>59E-Shortest Path <strong>*2000</strong> 最短路+hash+路径记录</h2><ul>
<li>就是一个最短路，因为边权为 $1$，直接用 <code>bfs</code> 做。</li>
<li>还有就是得记录路径（<strong>这部分是难点</strong>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        g[b].emplace_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,k)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        S.insert(&#123;a,b,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PII ans=&#123;-1,-1&#125;;</span><br><span class="line"></span><br><span class="line">    queue&lt;array&lt;int,2&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    q.push(&#123;1,1&#125;);</span><br><span class="line"></span><br><span class="line">    while(q.sz)&#123;</span><br><span class="line">        auto [u,v]=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        if(v==n)&#123;</span><br><span class="line">            ans=&#123;u,v&#125;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(auto j:g[v])&#123;</span><br><span class="line">            if(S.count(&#123;u,v,j&#125;)||p[v][j])continue;</span><br><span class="line">            p[v][j]=u;</span><br><span class="line">            q.push(&#123;v,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans.fi==-1)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    VI res;</span><br><span class="line"></span><br><span class="line">    while(ans.se!=1)&#123;</span><br><span class="line">        res.push_back(ans.se);</span><br><span class="line">        ans=&#123;p[ans.fi][ans.se],ans.fi&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res.sz&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    res.push_back(1);</span><br><span class="line">    reverse(ALL(res));</span><br><span class="line"></span><br><span class="line">    for(auto x:res)cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最关键是路径记录。</p>
</blockquote>
<h2 id="653E-Bear-and-Forgotten-Tree-2-2400-bfs-思维"><a href="#653E-Bear-and-Forgotten-Tree-2-2400-bfs-思维" class="headerlink" title="653E- Bear and Forgotten Tree 2 *2400 bfs+思维"></a>653E- Bear and Forgotten Tree 2 <strong>*2400</strong> bfs+思维</h2><ul>
<li>不满足条件的特判很好写，略。</li>
<li>此时把 $1$ 去掉，看其它的点相互连边（排除掉禁止连边的边），如果其他点相互连接的产生的连通块比 $k$ 大，此时就说明 $1$ 就得向这些连通块连超过 $k$ 条边的边。</li>
<li>这里用 <code>bfs</code> 去算连通块，这里偷个懒，直接用 <code>set</code> 把所有的点加进去，如果在一个连通块内，就把这些点全部删掉，如果删掉剩下的点跟 $1$ 有边相连，说明这个连通块是靠近 $1$ 相邻点，此时这个点就不能被 $1$ 访问到，此时就不是一棵树了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bfs(int u)&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    VI t;</span><br><span class="line">    q.push(u);</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int v=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(auto j:S)&#123;</span><br><span class="line">            if(!g[v].count(j))&#123;</span><br><span class="line">                t.pb(j);</span><br><span class="line">                q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(t.sz)S.erase(t.back()),t.pop_back();</span><br><span class="line">        if(!g[v].count(1))f=false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int d=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b]=1;</span><br><span class="line">        g[b][a]=1;</span><br><span class="line">        if(a==1||b==1)d++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(n-d-1&lt;k)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        S.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        if(S.count(i))&#123;</span><br><span class="line">            S.erase(i);</span><br><span class="line">            f=1;</span><br><span class="line">            bfs(i);</span><br><span class="line">            cnt++;</span><br><span class="line">            if(f)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cnt&lt;=k)cout&lt;&lt;&quot;possible&quot;&lt;&lt;endl;</span><br><span class="line">    else cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>典型的连通块问题，可以用 <code>bfs</code> 、 并查集 、<code>targin</code> 等来做。</p>
</blockquote>
<h2 id="1923A-Moving-Chips"><a href="#1923A-Moving-Chips" class="headerlink" title="1923A-Moving Chips"></a>1923A-Moving Chips</h2><ul>
<li>水题：就是简单统计 $1$ 直接 $0$ 的个数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s[i]=s[i-1]+(w[i]==0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int l=0,r=n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        if(w[i]==1)&#123;</span><br><span class="line">            l=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FORD(i,1,n)&#123;</span><br><span class="line">        if(w[i]==1)&#123;</span><br><span class="line">            r=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1879A-Rigged"><a href="#1879A-Rigged" class="headerlink" title="1879A-Rigged!"></a>1879A-Rigged!</h2><ul>
<li>水题，直接让答案等于第一个数的第一个数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i].fi&gt;&gt;w[i].se;</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        if(w[i].se&gt;=w[1].se&amp;&amp;w[i].fi&gt;=w[1].fi)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;w[1].fi&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Fire-Again-1500-多路bfs"><a href="#Fire-Again-1500-多路bfs" class="headerlink" title="Fire Again *1500 多路bfs"></a>Fire Again <strong>*1500</strong> 多路bfs</h2><ul>
<li>很好写的，本题最坑的就是得用 <code>freopen(&quot;&quot;,&quot;&quot;,stdin/stdout)</code>，因为在文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    queue&lt;array&lt;int,3&gt;&gt;q;</span><br><span class="line">    </span><br><span class="line">    FOR(i,1,k)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        vis[x][y]=1;</span><br><span class="line">        q.push(&#123;x,y,0&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            w[i][j]=1e9;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(q.sz)&#123;</span><br><span class="line">        auto [x,y,step]=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        w[x][y]=min(w[x][y],step);</span><br><span class="line">        FOR(i,0,3)&#123;</span><br><span class="line">            int a=dx[i]+x,b=dy[i]+y;</span><br><span class="line">            if(a&lt;1||b&lt;1||a&gt;n||b&gt;m||vis[a][b])continue;</span><br><span class="line">            vis[a][b]=1;</span><br><span class="line">            q.push(&#123;a,b,step+1&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int t=0;</span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            t=max(t,w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            if(t==w[i][j])&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有的不是标准输入输出，就得用 <code>freopen</code>。</p>
</blockquote>
<h2 id="Gym-100866A-Anti-factorial-高精度-小技巧"><a href="#Gym-100866A-Anti-factorial-高精度-小技巧" class="headerlink" title="Gym-100866A-Anti factorial 高精度/小技巧"></a>Gym-100866A-Anti factorial 高精度/小技巧</h2><ul>
<li>哈哈哈，其实不用高精度也可以做，可以：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    int t=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,s.sz-1)&#123;</span><br><span class="line">        t=(t*10+s[i]-&#x27;0&#x27;)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[0]=1;</span><br><span class="line">    FOR(i,1,255)&#123;</span><br><span class="line">        fac[i]=fac[i-1]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,255)&#123;</span><br><span class="line">        if(t==fac[i])&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>高精度做法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solbve()&#123;</span><br><span class="line">    VI p;</span><br><span class="line">    p.pb(1);</span><br><span class="line">    VI pd;</span><br><span class="line">    for(auto x:s)&#123;</span><br><span class="line">        pd.push_back(x-&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,255)&#123;</span><br><span class="line">        int t=0;</span><br><span class="line">        VI c;</span><br><span class="line">        for(int j=0;j&lt;p.sz||t;j++)&#123;</span><br><span class="line">            if(j&lt;p.sz)t+=p[j]*i;</span><br><span class="line">            c.pb(t%10);</span><br><span class="line">            t/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        p=c;</span><br><span class="line">        reverse(ALL(c));</span><br><span class="line">        if(c==pd)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1735D-Meta-set-1700-思维"><a href="#1735D-Meta-set-1700-思维" class="headerlink" title="1735D-Meta-set *1700 思维"></a>1735D-Meta-set <strong>*1700</strong> 思维</h2><ul>
<li><p>可以很容易发现，对于 <script type="math/tex">a:\ 0 \ 1 \ 2</script> <script type="math/tex">b:\ 0 \ 2 \ 1</script></p>
</li>
<li><p>那么 $c$ 串也就可以很容易判断出来是 $0 \ 0 \ 0$。</p>
</li>
<li><p>题目说只要 $&gt;1$ 个满足这样的，就可以认为是符合条件的。</p>
</li>
<li><p>因为 $n\le 10^3$ ，所以可以直接先枚举其中的两个，由于这些数字最大也就 $2$，因此可以想到三进制，由于要定位第三个串，所以必须要让每个串能被十进制数表示，因此就得用三进制来维护。</p>
</li>
<li><p>那么为了使该五元集合法，五元集中必须能提取出至少两个的合法三元集。我们之前已经求出 $sum$ 数组，记录含有 $i$ 串的合法三元集的个数。于是当前第 $i$ 串对结果的贡献就是 $C_{sum_i}^2$。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calc(int x,int y)&#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=1,t=1;i&lt;=m;i++,t*=3)&#123;</span><br><span class="line">        if(w[x][i]==w[y][i])&#123;</span><br><span class="line">            res+=w[x][i]*t;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res+=(3-w[x][i]-w[y][i])*t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        int t=1,s=0;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">            a[i]+=w[i][j]*t;</span><br><span class="line">            t*=3;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-2)&#123;</span><br><span class="line">        FOR(j,i+1,n-1)&#123;</span><br><span class="line">            int t=calc(i,j);</span><br><span class="line">            if(mp[t]&gt;j)&#123;</span><br><span class="line">                sum[i]++;</span><br><span class="line">                sum[j]++;</span><br><span class="line">                sum[mp[t]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        ans+=sum[i]*(sum[i]-1)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数字不大，要定位第三个的话，可以考虑进制。</p>
</blockquote>
<h2 id="803D-Magazine-A-1900-二分"><a href="#803D-Magazine-A-1900-二分" class="headerlink" title="803D-Magazine A *1900 二分"></a>803D-Magazine A <strong>*1900</strong> 二分</h2><ul>
<li>这道题就是直接二分答案就可以了，如果遇到 <code>-</code> 或 ``的话，考虑换行，然后贪心就可以了。</li>
<li>题目具有单调性，二分生效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    int c1=1,c2=0,c3=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,s.sz-1)&#123;</span><br><span class="line">        if(s[i]==&#x27; &#x27;||s[i]==&#x27;-&#x27;)c3=i;</span><br><span class="line">        c2++;</span><br><span class="line">        if(c2&gt;=x&amp;&amp;i!=s.sz-1)&#123;</span><br><span class="line">            if(!c3)return false;</span><br><span class="line">            c1++;</span><br><span class="line">            c2=i-c3;</span><br><span class="line">            c3=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return c1&lt;=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    int mx=0;</span><br><span class="line">    </span><br><span class="line">    cin.ignore();</span><br><span class="line">    getline(cin,s);</span><br><span class="line"></span><br><span class="line">    int l=0,r=1e12;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="883I-Photo-Processing-1900-二分-dp"><a href="#883I-Photo-Processing-1900-二分-dp" class="headerlink" title="883I-Photo Processing *1900 二分+dp"></a>883I-Photo Processing <strong>*1900</strong> 二分+dp</h2><ul>
<li>题目说了<strong>最大值最小</strong>，所以就是二分没错了。</li>
<li>然后现在是二分，此时也就是给定了答案，如果贪心去分配的话，感觉是有后效性的，因此就得用 <code>dp</code> 去做。</li>
<li>因为题目只要求分组，不需要具体方案，可以将输入的数排序，然后定义一个 $f_i$ 存的是前 $i$ 个数能满足条件的最后一个数的位置，那么只需判断 <code>f[n]</code> 是否等于 $n$。</li>
<li>转移：从前往后枚举，因为要求每组至少 $m$ 个数，对于当前的第 $i$ 个数，要使每个数都明确得分到一个组，看 <code>f[i−m]</code> 存的前一位，即没分到组的第一个数，如果 <code>a[i]−a[t+1]</code> 小于 <code>mid</code> 则可以分为一组更新 <code>f[i]=i</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    VI f(n+1,0);</span><br><span class="line"></span><br><span class="line">    int pos=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,m,n)&#123;</span><br><span class="line">        int t=f[i-m];</span><br><span class="line">        if(w[i]-w[t+1]&lt;=x)pos=i;</span><br><span class="line">        f[i]=pos;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[n]==n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    sort(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    int l=-1,r=w[n]-w[1]+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    if(check(l))r=l;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>到这里一天又结束了，感慨时间过得真快，我花了 $2$ 小时也终于写到了这里。</p>
<hr>
<h1 id="2-9-2-14-26"><a href="#2-9-2-14-26" class="headerlink" title="2.9-2.14  26"></a>2.9-2.14  <sup>26</sup></h1><p><del>期间发生了许多事情，其中有 $3$ 天时间把这个刷题给搁置了，因为流感是真的严重，在修养身体。</del></p>
<p>2.14统一更新：</p>
<h2 id="706B-Interesting-drink-1100"><a href="#706B-Interesting-drink-1100" class="headerlink" title="706B-Interesting drink *1100"></a>706B-Interesting drink <strong>*1100</strong></h2><ul>
<li>没什么说的，二分的水题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">upper_bound</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n,x)-w<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1198B-Welfare-State-1600-思维-值得重构"><a href="#1198B-Welfare-State-1600-思维-值得重构" class="headerlink" title="1198B-Welfare State *1600 思维 值得重构"></a>1198B-Welfare State <strong>*1600</strong> 思维 值得重构</h2><ul>
<li><p>看题目，有单点修改和区间修改以及查询，因此很容易可以想到线段树。</p>
</li>
<li><p>但我们可以仔细考虑一下，发现有的操作是无用的，这样的思维就可以让我们离线处理查询。</p>
</li>
<li><p>比如补平均以下的 $2$，然后我此时的值是 $5$，那么此时这种操作就失效了。</p>
</li>
<li><p>还有一个性质就是：数字单调不降，除修改外。</p>
</li>
<li><p>综合以上性质，可以很容易写出：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].fi;</span><br><span class="line">        w[i].se=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,Q)&#123;</span><br><span class="line">        <span class="type">int</span> opt,p,x;</span><br><span class="line">        cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;p&gt;&gt;x;</span><br><span class="line">            w[p]=&#123;x,i&#125;;</span><br><span class="line">            q[i]=<span class="number">-1e18</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">0</span>,Q)&#123;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,q[i]);</span><br><span class="line">        pre[i]=mx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(pre[w[i].se],w[i].fi)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线段树做法更容易。</p>
<p>反思：本来有这种离线处理的思想，但总是往排序那边想了，可能是被分块的题目误导了，分块的题目经常要把查询进行排序。<br>这道题其实只需要倒叙来做就可以了，倒叙维护最大值。</p>
</blockquote>
<h2 id="1239A-Ivan-the-Fool-and-the-Probability-Theory-1700-找规律"><a href="#1239A-Ivan-the-Fool-and-the-Probability-Theory-1700-找规律" class="headerlink" title="1239A-Ivan the Fool and the Probability Theory *1700 找规律"></a>1239A-Ivan the Fool and the Probability Theory <strong>*1700</strong> 找规律</h2><ul>
<li><p>如果只有一行的情况，如果是 $1\times1$ ，答案为 $2$，如果是 $1\times 2$ ，答案为 $4$。</p>
</li>
<li><p>那么可以很容易发现如果是 $1\times n$ 的情况，答案就是斐波那契数列的 $2f<em>1+2f</em>{n}-2$。</p>
</li>
<li><p>至于证明，<del>其实不太会</del>。</p>
</li>
<li><p>简略证明为什么是斐波那契数列：</p>
</li>
</ul>
<p>令 $f<em>{i,0}$ 为第 $i$ 行涂黑色的方案数， $f</em>{i,1}$ 为第 $i$ 行涂白色的方案数。</p>
<p>由于同一个颜色的最多只能有 $1$ 个相邻，那么看前面几行可以得出：</p>
<script type="math/tex; mode=display">f_{i,0}=f_{i-1,0}+f_{i-2,0}</script><script type="math/tex; mode=display">f_{i,1}=f_{i-1,1}+f_{i-2,1}</script><p>所以：</p>
<script type="math/tex; mode=display">f_{i}=f_{i-1}+f_{i-2}</script><p>证明完毕。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,<span class="built_in">max</span>(n,m)<span class="number">+2</span>)&#123;</span><br><span class="line">        f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">2</span>*(f[n]+f[m]<span class="number">-1</span>)%mod&lt;&lt;endl;<span class="comment">//-1就是同色相邻的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果出什么求方案数，它很有可能是排列组合或者通过找规律来得出结论的。</p>
</blockquote>
<h2 id="1364C-Ehab-and-Prefix-MEXs-1600-构造题"><a href="#1364C-Ehab-and-Prefix-MEXs-1600-构造题" class="headerlink" title="1364C-Ehab and Prefix MEXs *1600 构造题"></a>1364C-Ehab and Prefix MEXs <strong>*1600</strong> 构造题</h2><ul>
<li><p>这是一道 $mex$ 的题目，mex的性质有单调不降，然后当 $w_i \le i$，其中 $w_i$ 指的是当前 mex 值。</p>
</li>
<li><p>特判很容易，关键是构造，这里直接采用如果 $w<em>i=w</em>{i-1}$，此时就找下一个的下一个（不是下一个的最小的下一个），这里的原始答案默认按照 $0,1,…,n-1$ 的方式来。</p>
</li>
<li><p>如果 $w<em>i\not= w</em>{i-1}$ ，那么就取 $w_{i-1}$，可以很容易证明这样一定是最优的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;i)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        vis[w[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(w[<span class="number">1</span>]==<span class="number">1</span>)vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]==w[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">while</span>(p&lt;=n<span class="number">+1</span>&amp;&amp;vis[p])p++;</span><br><span class="line">            vis[p]=<span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;p&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;w[i<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mex的性质得多掌握，mex如果是连续的情况下，往往跟上一个mex的差值是1。</p>
</blockquote>
<h2 id="1514C-Product-1-Modulo-N-1600-构造-数学"><a href="#1514C-Product-1-Modulo-N-1600-构造-数学" class="headerlink" title="1514C-Product 1 Modulo N *1600 构造+数学"></a>1514C-Product 1 Modulo N <strong>*1600</strong> 构造+数学</h2><ul>
<li><p>设乘积为 $s$，那么 $s\equiv 1 \ (\mod n)$。</p>
</li>
<li><p>此时可以设除 $a_i$ 外其他数的乘积是 $p$，那么：$a_ip\equiv 1\ (\mod n)$，根据裴蜀定理，此时 $gcd(a_i,n)=1$。</p>
</li>
<li><p>之后把所有与 $n$ 互质的数在模 $n$ 意义下乘起来，可以得到一个小于 $n$ 的数 $ans$ ， $ans$ 一定与 $n$ 互质。（辗转相除的原理）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(i,n)==<span class="number">1</span>)&#123;</span><br><span class="line">            w[i]=<span class="number">1</span>;</span><br><span class="line">            s=s*i%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="number">1</span>)w[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i])cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最关键的就是得知道裴蜀定理的应用。</p>
</blockquote>
<h2 id="1548B-Integers-Have-Friends-1800-数学"><a href="#1548B-Integers-Have-Friends-1800-数学" class="headerlink" title="1548B- Integers Have Friends *1800 数学"></a>1548B- Integers Have Friends <strong>*1800</strong> 数学</h2><ul>
<li><p>要让 $a<em>i \mod m =a</em>{i+1} \mod m=…a<em>j \mod m$，此时很容易知道，对于相邻两项，有：$|a_i-a</em>{i+1}| \mod m=0$，然后前面的式子有 $j-i$ 个，此时要让所有数 $\mod m=0$，就是得让 $\gcd(|a<em>i-a</em>{i+1}|,|a<em>{i+1}-a</em>{i+2}|,…)&gt;1$。</p>
</li>
<li><p>那个 $\gcd$ 的值是自定义的并且是寻找最长的区间使得 $\gcd&gt;1$，因此可以采用<strong>取尺法</strong>。</p>
</li>
<li><p>区间的 $\gcd$ 值可以用 st 表维护。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">20</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)f[i][j]=c[i];</span><br><span class="line">            <span class="keyword">else</span> f[i][j]=__gcd(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> __gcd(f[l][len],f[r-(<span class="number">1</span>&lt;&lt;len)<span class="number">+1</span>][len]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],c[i]=<span class="built_in">abs</span>(w[i]-w[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">query</span>(l<span class="number">+1</span>,r)&lt;=<span class="number">1</span>)l++;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,r-l<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;mx&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>求最长区间满足某个条件的题目可以考虑取尺法。取尺法本质就是两个同向指针。<br><strong>尺取法处理是问题是一段连续的区间，区间是单调的。</strong></p>
<p><a href="https://www.acwing.com/blog/content/4409/">引用</a></p>
<p>使用尺取法时应清楚以下四点：</p>
<p>1、  什么情况下能使用尺取法?  2、何时推进区间的端点？ 3、如何推进区间的端点？ 3、何时结束区间的枚举？</p>
<p>尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步</p>
<p>得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。</p>
</blockquote>
<h2 id="1633D-Make-Them-Equal-1600-dp-数学"><a href="#1633D-Make-Them-Equal-1600-dp-数学" class="headerlink" title="1633D-Make Them Equal *1600 dp+数学"></a>1633D-Make Them Equal <strong>*1600</strong> dp+数学</h2><ul>
<li><p>对于每个数 $a_i$，有 $a_i+\lfloor \frac{a_i}{x} \rfloor$，又因为数组的数最大也就 $10^3$，因此可以预处理出最小操作次数，即： $i=i+i/j$，这个可以暴力取枚举。</p>
</li>
<li><p>对于后面的操作就是直接 <code>01背包</code>，因为每个数可以操作和不操作两种情况，对于 <code>01背包</code> 也就是选和不选两种情况。</p>
</li>
<li><p>特判：如果操作次数大于等于 $a$ 数组的和，此时说明所有的数都可以被遍历到。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">1000</span>)g[i]=<span class="number">1e18</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">            <span class="type">int</span> k=i+i/j;</span><br><span class="line">            g[k]=<span class="built_in">min</span>(g[k],g[i]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>,tc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i],tot+=a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i],tc+=b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&gt;=tot)&#123;</span><br><span class="line">        cout&lt;&lt;tc&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,k<span class="number">+1</span>)f[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORD</span>(j,g[a[i]],k)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-g[a[i]]]+b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[k]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数小的时候多考虑预处理和dp，题目中是操作次数有选和不选两种情况。</p>
<p><strong>卡：没有想到去预处理，然后想了非常复杂的贪心，<del>太菜了</del></strong></p>
</blockquote>
<h2 id="1758D-Range-√Sum-1800-构造"><a href="#1758D-Range-√Sum-1800-构造" class="headerlink" title="1758D-Range = √Sum *1800 构造"></a>1758D-Range = √Sum <strong>*1800</strong> 构造</h2><ul>
<li><p>可以很容易想到偶数的构造是：<script type="math/tex">...,n-2,n-1,n+1,n+2,...</script>，这个的和是 $n^2$，而且最大值减最小值就是 $n$。</p>
</li>
<li><p>奇数考虑：<script type="math/tex">\frac{n}{2}+2,...,n,...,n+3,...,\frac{3n}{2}+3</script>。这个的和是 $(n+1)^2$，最大值减最小值是 $(n+1)$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,n/<span class="number">2</span><span class="number">+2</span>,n)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,n<span class="number">+3</span>,n+n/<span class="number">2</span><span class="number">+3</span>)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,n-n/<span class="number">2</span>,n+n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=n)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造的题还是多多举例，有的时候很经常要 <strong>奇偶分讨</strong>。</p>
</blockquote>
<h2 id="1774B-Coloring-1500-数学"><a href="#1774B-Coloring-1500-数学" class="headerlink" title="1774B-Coloring *1500 数学"></a>1774B-Coloring <strong>*1500</strong> 数学</h2><ul>
<li><p>本题要求构造一个序列，要求连续 $k$ 个数不能重复。</p>
</li>
<li><p>可以将每 $k$ 个数看作一组，显然有 $(n + k - 1) / k$ 组，一个数最多只能在每组中出现一次，<br>因此如果存在 $a_i &gt; (n + k - 1) / k$，则一定无解。</p>
</li>
<li><p>最后一组并不一定有 $k$ 个，而是有 $(n - 1) % k + 1$（最后一组不可能为 $0$，特殊处理一下），<br>这意味着只有 $(n - 1) % k + 1$ 能出现 $(n + k - 1) / k$ 次，因此统计一下出现 $(n + k - 1) / k$<br>次的数的个数 $cnt$，如果 $cnt &gt; (n - 1) % k + 1$，则也一定无解。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=(n+k<span class="number">-1</span>)/k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;t)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w[i]==t)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;=(n<span class="number">-1</span>)%k<span class="number">+1</span>)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有想到平均分组，当时想的太混乱了。如果想到平均分组的话，那这道题就很简单了。<del>qwq</del></p>
</blockquote>
<h2 id="1774D-Same-Count-One-1600-思维"><a href="#1774D-Same-Count-One-1600-思维" class="headerlink" title="1774D-Same Count One *1600 思维"></a>1774D-Same Count One <strong>*1600</strong> 思维</h2><ul>
<li><p>就是先把横向统计一下，然后看纵向的 $1$ 的个数，这里有维护每一行的 $1$ 的个数。</p>
</li>
<li><p>特判比较容易，这里就不强调了。</p>
</li>
<li><p>然后就把某一列多余平均的给少于平均的，然后更新一下它们的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">w</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">col</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">            <span class="keyword">if</span>(w[i][j])&#123;</span><br><span class="line">                tot++;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        col[i]=s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tot%n!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tot/=n;</span><br><span class="line"></span><br><span class="line">    VI zero,one;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt;res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        one.<span class="built_in">clear</span>(),zero.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[j]&gt;tot&amp;&amp;w[j][i]==<span class="number">1</span>)one.<span class="built_in">pb</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(col[j]&lt;tot&amp;&amp;w[j][i]==<span class="number">0</span>)zero.<span class="built_in">pb</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(one.sz,zero.sz)<span class="number">-1</span>)&#123;</span><br><span class="line">            res.<span class="built_in">pb</span>(&#123;zero[j],one[j],i&#125;);</span><br><span class="line">            col[one[j]]--;</span><br><span class="line">            col[zero[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res.sz&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y,z]:res)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是很单纯的贪心，个人已经想到预处理每一行 $1$ 的个数，然后肯定跟平均值有关，然后肯定是从多余平均的转移到少于平均的。然后就不想去了。<del>服了，就差一步。</del></p>
</blockquote>
<h2 id="1776L-Controllers-1500-数学"><a href="#1776L-Controllers-1500-数学" class="headerlink" title="1776L-Controllers *1500 数学"></a>1776L-Controllers <strong>*1500</strong> 数学</h2><ul>
<li>因为给定的数只有两个 $a,b$，因此可以很容易的建立如下方程组：</li>
</ul>
<p>设 $a$ 的 <code>+</code> 使用次数为 $u$，<code>-</code> 使用次数为 $v$，设使用字符串中的 <code>+</code> 的数量是 $x$， <code>-</code> 的数量是 $y$，那么有：</p>
<script type="math/tex; mode=display">au-av+b(x-u)-b(y-v)=0</script><script type="math/tex; mode=display">(u−v)⋅(a−b)=−(x−y)⋅b</script><ul>
<li><p>接下来是分类讨论一下：</p>
</li>
<li><ul>
<li>当 $a-b=0$，，$x−y$ 必为 $0$，否则无解。</li>
</ul>
</li>
<li><ul>
<li>当 $a−b\not=0$ 时，显然 $u−v=a−b−(x−y)⋅b$​。根据，$0≤u≤x，0≤v≤y$，通过这两个不等式解得 $−y≤u−v≤x$。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==y)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m=x-y;</span><br><span class="line">        <span class="keyword">if</span>(b*m%(b-a))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> k=b*m/(b-a);</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=-y&amp;&amp;k&lt;=x)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考的就是方程组，还是解不等式的。</p>
</blockquote>
<h2 id="1868B1-Candy-Party-Easy-Version-1700-位运算"><a href="#1868B1-Candy-Party-Easy-Version-1700-位运算" class="headerlink" title="1868B1-Candy Party (Easy Version) *1700 位运算"></a>1868B1-Candy Party (Easy Version) <strong>*1700</strong> 位运算</h2><ul>
<li><p>由于题目说什么转移 $2^x$ 颗糖果，此时就得考虑二进制——位运算了。</p>
</li>
<li><p>对于每一个数与平均数的差值 $b_i$，可以将它拆成 $2^x-2^y$ 的形式。</p>
</li>
<li><p>如果 $b_i$ 变不成这种形式，那么不可能满足条件——得到和付出 $2^x$ 颗糖果。</p>
</li>
<li><p>此时存储满足的 $x$ 和 $y$ 值，如果所有的 $x=y$，那么满足条件。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],sum+=w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum%n!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum/=n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m1,m2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> k=w[i]-sum;</span><br><span class="line">        <span class="keyword">if</span>(!k)<span class="keyword">continue</span>;<span class="comment">//bi=2^x-2^y</span></span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">abs</span>(k);</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">log2</span>(c)<span class="number">+1</span>,y=<span class="built_in">log2</span>((<span class="number">1</span>&lt;&lt;x)-c);</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;x)-(<span class="number">1</span>&lt;&lt;y)!=c)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;nO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        m1[x]++,m1[y]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">32</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m1[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;yEs&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>想到了位运算，但卡在：没有把形式很清晰的拆成 $2^x-2^y$ 的形式来做。</p>
<p>以后遇到类似的话，可以考虑某一个东西（比如差值，变化量等）有一种比较清晰的形式去表示。</p>
</blockquote>
<h2 id="1948C-Arrow-Path-1300"><a href="#1948C-Arrow-Path-1300" class="headerlink" title="1948C-Arrow Path *1300"></a>1948C-Arrow Path <strong>*1300</strong></h2><ul>
<li>大型 <code>bfs</code> 水题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x,y]=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=dx[i]+x,b=dy[i]+y;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>||b&lt;<span class="number">1</span>||a&gt;<span class="number">2</span>||b&gt;n)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[a][b]==<span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vis[a][b])<span class="keyword">continue</span>;</span><br><span class="line">            vis[a][b]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            vis[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;s[<span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;s[<span class="number">2</span>][i];</span><br><span class="line"></span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(vis[<span class="number">2</span>][n]?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1948D-Tandem-Repeats-1700-贪心-模拟"><a href="#1948D-Tandem-Repeats-1700-贪心-模拟" class="headerlink" title="1948D-Tandem Repeats? *1700 贪心+模拟"></a>1948D-Tandem Repeats? <strong>*1700</strong> 贪心+模拟</h2><ul>
<li>由于这个数组长度不大，直接暴力枚举就可以了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.sz;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x=i,mx=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+x&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==s[j+x]||s[j]==<span class="string">&#x27;?&#x27;</span>||s[j+x]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;=i)ans=<span class="built_in">max</span>(ans,<span class="number">2</span>*i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>刚开始还想着二分答案，没想到答案不具有单调性，比如 <code>c?csadasihd</code>，可能后面还能让它更优但二分不下去了。</p>
</blockquote>
<h2 id="1954B-Make-It-Ugly-1200"><a href="#1954B-Make-It-Ugly-1200" class="headerlink" title="1954B-Make It Ugly *1200"></a>1954B-Make It Ugly <strong>*1200</strong></h2><ul>
<li><p>其实总的思路就是从两端往中间靠，就是得注意这种情况：<code>1 2 2 1</code> ，此时答案为 <code>0</code>。</p>
</li>
<li><p>因此考虑的情况有：</p>
</li>
<li><ul>
<li>删除持续删除队尾。</li>
</ul>
</li>
<li><ul>
<li>删除持续删除队头。</li>
</ul>
</li>
<li><ul>
<li>删除中间元素。</li>
</ul>
</li>
<li><p>综上所述，只需要当 $a_i=a_1$ 的时候，再删除。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[w[<span class="number">1</span>]]==n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=n,len=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]==w[<span class="number">1</span>])&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,len);</span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=<span class="built_in">min</span>(ans,len);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>漏了考虑中间元素的删除情况。</p>
</blockquote>
<h2 id="1969C-Minimizing-the-Sum-1700-dp"><a href="#1969C-Minimizing-the-Sum-1700-dp" class="headerlink" title="1969C-Minimizing the Sum *1700 dp"></a>1969C-Minimizing the Sum <strong>*1700</strong> dp</h2><ul>
<li><p>题目说用相邻的元素去替换，那么当把时间范围拉长，此时就是一段区间一段区间的了。</p>
</li>
<li><p>由于一个数可以更新多个之相邻的连续的数，最终效果就是这一段的数都变成了这一段的最小值。</p>
</li>
<li><p>所以不妨枚举每个段，使之变为最小值，再进行转移。</p>
</li>
<li><p>所以设 $f_{i,j}$ 为在前 $i$ 个元素，最多操作 $k$ 次的最小总和。</p>
</li>
<li><p>状态转移：$f<em>{i+l,j+l}=\min(f</em>{i-1,j}+(l-1)*minv)$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;K;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,K)&#123;</span><br><span class="line">            f[i][j]=<span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,K)&#123;</span><br><span class="line">            <span class="type">int</span> minv=<span class="number">1e18</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l+j&lt;=K&amp;&amp;l+i&lt;=n;l++)&#123;<span class="comment">//固定长度去枚举最小值</span></span><br><span class="line">                minv=<span class="built_in">min</span>(minv,w[i+l]);</span><br><span class="line">                f[i+l][l+j]=<span class="built_in">min</span>(f[i+l][l+j],f[i<span class="number">-1</span>][j]+(l<span class="number">+1</span>)*minv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,K)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是想到dp了，但没有想到优化，就是按照固定长度去枚举最小值放入。而且如果不按照区间的转移，转移方程很难写。（就是卡在对于相邻问题没有考虑区间进行转移）。</p>
</blockquote>
<h2 id="1971G-XOUR-1700-构造"><a href="#1971G-XOUR-1700-构造" class="headerlink" title="1971G-XOUR *1700 构造"></a>1971G-XOUR <strong>*1700</strong> 构造</h2><ul>
<li><p>要让 $a_i \oplus a_j&lt;4$，此时：$\lfloor \frac{a_i}{4}\rfloor = \lfloor \frac{a_j}{4} \rfloor$。</p>
</li>
<li><p>也就是：所有除四下取整相同的 $a_i$​ 都可以按照原来的位置排序。</p>
</li>
<li><p>此时就用小堆来维护 $\lfloor \frac{a_i}{4}\rfloor$ 的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt;&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        S[w[i]/<span class="number">4</span>].<span class="built_in">push</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;S[w[i]/<span class="number">4</span>].<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        S[w[i]/<span class="number">4</span>].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有想到 $\lfloor \frac{a_i}{4}\rfloor = \lfloor \frac{a_j}{4} \rfloor$。</p>
</blockquote>
<h2 id="1983A-Array-Divisibility-水题"><a href="#1983A-Array-Divisibility-水题" class="headerlink" title="1983A-Array Divisibility 水题"></a>1983A-Array Divisibility 水题</h2><ul>
<li>思路就是直接输出 $1,2,3,…,n$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1983B-Corner-Twist-1200-思维"><a href="#1983B-Corner-Twist-1200-思维" class="headerlink" title="1983B-Corner Twist *1200 思维"></a>1983B-Corner Twist <strong>*1200</strong> 思维</h2><ul>
<li>首先得发现一个性质：每次变化每行和每列模 $3$ 的值都是不变的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            s[i][j]=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sa[i]=<span class="number">0</span>,ta[i]=<span class="number">0</span>;</span><br><span class="line">            tb[j]=<span class="number">0</span>,sb[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            t[i][j]=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            sa[i]=(sa[i]+s[i][j])%<span class="number">3</span>;</span><br><span class="line">            ta[i]=(ta[i]+t[i][j])%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            sb[i]=(sb[i]+s[j][i])%<span class="number">3</span>;</span><br><span class="line">            tb[i]=(tb[i]+t[j][i])%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sa[i]!=ta[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sb[i]!=tb[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1983C-Have-Your-Cake-and-Eat-It-Too-1400-双指针"><a href="#1983C-Have-Your-Cake-and-Eat-It-Too-1400-双指针" class="headerlink" title="1983C-Have Your Cake and Eat It Too *1400 双指针"></a>1983C-Have Your Cake and Eat It Too <strong>*1400</strong> 双指针</h2><ul>
<li><p>就直接枚举每一种情况，然后如果有这种情况，就直接输出即可。</p>
</li>
<li><p>枚举的每一种情况就是用双指针维护。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b[],<span class="type">int</span> c[],<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z,<span class="type">int</span> tot)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;<span class="built_in">res</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>,sc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sa&lt;tot)sa+=a[l++];</span><br><span class="line">    <span class="keyword">while</span>(sc&lt;tot)sc+=c[r--];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,l,r)&#123;</span><br><span class="line">        sb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27; &#x27;&lt;&lt;sa&lt;&lt;&#x27; &#x27;&lt;&lt;sb&lt;&lt;&#x27; &#x27;&lt;&lt;sc&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sb&lt;tot)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    res[<span class="number">1</span>]=&#123;<span class="number">1</span>,l<span class="number">-1</span>&#125;;</span><br><span class="line">    res[<span class="number">2</span>]=&#123;l,r&#125;;</span><br><span class="line">    res[<span class="number">3</span>]=&#123;r<span class="number">+1</span>,n&#125;;</span><br><span class="line">    </span><br><span class="line">    id[x]=<span class="number">1</span>,id[y]=<span class="number">2</span>,id[z]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res[id[<span class="number">1</span>]].fi&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;res[id[<span class="number">1</span>]].se&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;res[id[<span class="number">2</span>]].fi&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;res[id[<span class="number">2</span>]].se&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;res[id[<span class="number">3</span>]].fi&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;res[id[<span class="number">3</span>]].se&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i],s+=a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    s=(s<span class="number">+2</span>)/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(a,b,c,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(a,c,b,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(b,a,c,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(b,c,a,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(c,a,b,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(c,b,a,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有正确处理好对应关系，就是 <code>f</code> 函数里面的对应关系。<br>以后就多考虑，自己先写认真考虑一遍再写。</p>
</blockquote>
<h2 id="2001A-Make-All-Equal-水题"><a href="#2001A-Make-All-Equal-水题" class="headerlink" title="2001A-Make All Equal 水题"></a>2001A-Make All Equal 水题</h2><ul>
<li>不说了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        S[w[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:S)&#123;</span><br><span class="line">        t=<span class="built_in">max</span>(t,y);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2001B-Generate-Permutation-水题"><a href="#2001B-Generate-Permutation-水题" class="headerlink" title="2001B-Generate Permutation 水题"></a>2001B-Generate Permutation 水题</h2><ul>
<li>可以很容易发现规律就是：如果是偶数就不行，奇数的话按照这种输出：$\lceil \frac{n}{2} \rceil+1,…,n,1,\lceil \frac{n}{2} \rceil$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(n&amp;<span class="number">1</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> t=(n<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FORD</span>(i,t<span class="number">+1</span>,n)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,t)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2001C-Guess-The-Tree-1500-交互题-分治思想"><a href="#2001C-Guess-The-Tree-1500-交互题-分治思想" class="headerlink" title="2001C-Guess The Tree *1500 交互题+分治思想"></a>2001C-Guess The Tree <strong>*1500</strong> 交互题+分治思想</h2><ul>
<li><p>本质上就是先从 $1$ 开始猜，如果这里有边的话，就递归 $a,mid$ 和 $mid,b$。</p>
</li>
<li><p>这样的时间复杂度是优秀的。</p>
</li>
</ul>
<p>递归的总思路：<a href="https://www.luogu.com.cn/article/dwk0k5zu">来源</a></p>
<blockquote>
<p>总的思路：每次询问树根与一个未被标记的点 。然后递归处理：</p>
<p>先把询问的 b 点标记，并得到中点 x。现在需要处理 x 到 b 的路径和 a 到 x 的路径。</p>
<p>对于前者，直接递归下去即可。</p>
<p>对于后者，分类讨论一下：若 x 已被标记，说明 x 到根上的路径已经被确定，不需要处理；如果未被标记，则递归处理 a 到 x 的路径。</p>
<p>递归的终止条件为询问的点 a 与得到的点 x 相同（因为这时询问的 a,b 两点相邻），此时要把 a,b 连边。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="comment">//分治思想</span></span><br><span class="line">    vis[b]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid=<span class="built_in">query</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(mid==a)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;a,b&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!vis[mid])<span class="built_in">dfs</span>(a,mid);</span><br><span class="line">    <span class="built_in">dfs</span>(mid,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;! &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:ans)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有想到用分治去优化时间复杂度，如果按照暴力的话时间复杂度是 $O(n^2)$，如果是分治的话，时间复杂度可以降到 $O(n\sqrt n)$。</p>
</blockquote>
<h2 id="2005B2-The-Strict-Teacher-Hard-Version-1200-水题二分"><a href="#2005B2-The-Strict-Teacher-Hard-Version-1200-水题二分" class="headerlink" title="2005B2-The Strict Teacher (Hard Version) *1200 水题二分"></a>2005B2-The Strict Teacher (Hard Version) <strong>*1200</strong> 水题二分</h2><p><del>这道题是我最开始刷codeforces的比赛题目，我记得当时我连这种题目做的都很困难，现在看来我当时是真傻。</del></p>
<ul>
<li>不说了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> lt=<span class="built_in">upper_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+m,x)-b<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rt=lt<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!lt)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,b[<span class="number">1</span>]<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rt&gt;m)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,n-b[lt])&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t=(b[lt]+b[rt])/<span class="number">2</span>;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">min</span>(<span class="built_in">abs</span>(b[lt]-t),<span class="built_in">abs</span>(b[rt]-t))&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2032C-Trinity-1400-双指针-思维"><a href="#2032C-Trinity-1400-双指针-思维" class="headerlink" title="2032C-Trinity *1400 双指针+思维"></a>2032C-Trinity <strong>*1400</strong> 双指针+思维</h2><ul>
<li><p>这道题就先排序，因为排序不会影响答案的个数。</p>
</li>
<li><p>其次把问题转化，题目问三角形数组的个数，此时就转化成总的个数减去不满足三角形数组的个数。</p>
</li>
<li><p>不满足三角形个数的可以直接用双指针维护。</p>
</li>
<li><p>为什么可以呢？因为不满足的个数有两个指针就是相邻的，这样可以把三维的变量转化成二维的变量，然后二维的变量就可以用双指针算法去解决。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=n&amp;&amp;w[l]+w[l<span class="number">+1</span>]&lt;=w[r])l++;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,r-l<span class="number">+1</span>);</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;n-ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三维变量转化为二位变量可以采取：CDQ分治、排序、转化题意（变成双指针形式）。</p>
</blockquote>
<h2 id="Gym-102992F-Fireworks-三分-概率"><a href="#Gym-102992F-Fireworks-三分-概率" class="headerlink" title="Gym-102992F Fireworks 三分+概率"></a>Gym-102992F Fireworks 三分+概率</h2><ul>
<li><p>假设一个 $E(x)$，表示多次造 $k$ 个烟花后燃放，出现至少一个完美烟花的概率最大的最小期望，简称最优。</p>
</li>
<li><p>形象的讲（不保证正确，但是好理解）：每次都造 $k$ 个后燃放出现完美烟花的概率是最大的，所以每次我们都只造 $k$ 个烟花后燃放。</p>
</li>
<li><p>因此：</p>
</li>
</ul>
<script type="math/tex; mode=display">E(x)=(k×n+m)×(1−(1−p)^k)+(k×n+m)×(1−p)^k+E(x)×(1−p)^k</script><ul>
<li>化简：</li>
</ul>
<script type="math/tex; mode=display">E(x)=\frac{1−(1−p)^k}{k×n+m}​</script><ul>
<li>求导可以看出该函数是个具有波谷的函数，用三分找到 $k$ 次就可求出 $E(x)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">EK</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n*x+m)/(<span class="number">1</span>-<span class="built_in">pow</span>((<span class="number">1</span>-p),x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">    p=p/<span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l=<span class="number">1</span>,r=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((r-l)&gt;eps)&#123;</span><br><span class="line">        <span class="type">double</span> midl=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="type">double</span> midr=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">EK</span>(midl)&gt;<span class="built_in">EK</span>(midr))l=midl;</span><br><span class="line">        <span class="keyword">else</span> r=midr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,<span class="built_in">EK</span>(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>具有波谷或波峰的函数可以采用三分来维护。</p>
</blockquote>
<p>这几天总结与评价：刷题还是得看重质量，往后还是按照 $+100$ <code>rating</code> $2-5$ 题的模式做，最重要的是认真总结。接下来大概花2-3天去把我之前把牛客的专题的题给总结了。</p>
<h1 id="2-15-2-17"><a href="#2-15-2-17" class="headerlink" title="2.15-2.17"></a>2.15-2.17</h1><p><del>妈的，怎么又感冒了，服了，才好几天哪。</del></p>
<h2 id="abc190-f-Shift-and-Inversions-逆序对；好题"><a href="#abc190-f-Shift-and-Inversions-逆序对；好题" class="headerlink" title="abc190-f Shift and Inversions 逆序对；好题"></a>abc190-f Shift and Inversions 逆序对；好题</h2><ul>
<li><p>如果没有移动的话，就是经典的逆序对，逆序对的求法有<strong>分治法</strong>和<strong>树状数组法</strong>。</p>
</li>
<li><p>如果有移动操作，那么逆序对的变化量就是 $n-w_i-(w_i-1)$，其中 $n-w_i$ 是 $w_i$ 移到第一位产生新的逆序对数，$w_i-1$ 是 $w_i$ 去掉损失的逆序对数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],w[i]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        res+=i<span class="number">-1</span>-<span class="built_in">query</span>(w[i]);</span><br><span class="line">        <span class="built_in">add</span>(w[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        res=res+(n-w[i])-w[i]<span class="number">+1</span>;<span class="comment">//把数字移动到前面逆序对变化量</span></span><br><span class="line">        <span class="comment">//n-w[i] 为增加逆序对的个数（比该数大的到该数前面，形成逆序对）</span></span><br><span class="line">		<span class="comment">//w[i]-1 为减少逆序对的个数（比该数到该数小的后面，拆散逆序对）</span></span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逆序对的应用题目，数字移动到端点逆序对的变化。</p>
</blockquote>
<h2 id="1714D-Color-with-Occurrences-1600-dp"><a href="#1714D-Color-with-Occurrences-1600-dp" class="headerlink" title="1714D-Color with Occurrences *1600 dp"></a>1714D-Color with Occurrences <strong>*1600</strong> dp</h2><ul>
<li><p>因为这里的数都是在 $100$ 以内，因此可以用 dp 来解决，那么此时状态表示很容易：$f_{i}$ 表示已经匹配好了前 $i$ 个字母需要花费的最小步数。</p>
</li>
<li><p>状态转移：$f<em>i=\min(f</em>{i-|s|}+1)$。</p>
</li>
<li><p>这里的匹配直接用 <code>strsub</code> 来做即可。（因为字符串不长）</p>
</li>
<li><p>然后要统计方案数，那就在转移的时候记录这个状态是从哪里来的，最后倒着遍历即可。（一般求方案都是这样）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=s.sz;</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;p[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)ans[i]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n<span class="number">+2</span>,<span class="number">1e18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=p[j].sz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j]==s.<span class="built_in">substr</span>(i-p[j].sz<span class="number">+1</span>,p[j].sz))&#123;</span><br><span class="line">                    <span class="built_in">FOR</span>(k,i-p[j].sz,i<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(f[i]&gt;f[k]<span class="number">+1</span>)&#123;</span><br><span class="line">                            f[i]=f[k]<span class="number">+1</span>;</span><br><span class="line">                            ans[i]=&#123;k,j&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[n]==<span class="number">1e18</span>)&#123;</span><br><span class="line">        f[n]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> x=n;</span><br><span class="line">    <span class="keyword">while</span>(ans[x].first!=<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans[x].second&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;x-p[ans[x].second].sz<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">        x=ans[x].fi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以后遇到数比较小的时候又不至于太小的时候可以考虑dp来做。（非常重要）</p>
</blockquote>
<h2 id="1848C-Binary-String-Copying-1600-找规律"><a href="#1848C-Binary-String-Copying-1600-找规律" class="headerlink" title="1848C- Binary String Copying *1600 找规律"></a>1848C- Binary String Copying <strong>*1600</strong> 找规律</h2><ul>
<li>首先发现：<script type="math/tex">00110011</script></li>
</ul>
<p>如果选区间 $[1,8]$，那么它的操作结果其实跟 $[3,6]$ 是一样的。换句话说，就是：对区间 $[1,8]$ 排序也就是对 $[3,6]$ 排序。</p>
<ul>
<li><p>所以可以记录下每一个 $0$ 右边第一个 $1$ 的位置 $L$​ 和每一个 $1$ 左边第一个 $0$ 的位置 $R​$，那么对区间 $[l,r]$ 排序就相当于对区间 $[L​,R​]$ 排序。对于一组数据，最终的答案就是不同的 $[L,R​​]$ 的数量。</p>
</li>
<li><p>只不过就是得注意，如果一个区间的 $0$ 右边的第一个 $1$ 的位置是大于 $1$ 左边第一个 $0$ 的位置，此时说明无需排序。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    S.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)pos=i;</span><br><span class="line">        L[i]=pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos=n<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)pos=i;</span><br><span class="line">        R[i]=pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        x=R[x];</span><br><span class="line">        y=L[y];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)x=<span class="number">1</span>,y=<span class="number">1</span>;<span class="comment">//无需排序</span></span><br><span class="line">        <span class="keyword">if</span>(!S[<span class="built_in">make_pair</span>(x,y)])&#123;</span><br><span class="line">            S[<span class="built_in">make_pair</span>(x,y)]=<span class="number">1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种题就是得去发现规律，发现什么是变的什么是不变的，然后发现二者的关系。所以这种低于 $2000$ 的题得多发现规律。</p>
<p>这道题很容易发现只有 $1$ 在前 $0$ 在后才会产生新的串。</p>
</blockquote>
<h2 id="1857F-Sum-and-Product-1600-数学；水题"><a href="#1857F-Sum-and-Product-1600-数学；水题" class="headerlink" title="1857F-Sum and Product *1600 数学；水题"></a>1857F-Sum and Product <strong>*1600</strong> 数学；水题</h2><ul>
<li><p>当你看到 $a_i\times a_j=y$ 和 $a_i+a_j=x$，你肯定会想到韦达定理。</p>
</li>
<li><p>那么 $a_i,a_j$ 就是 $a^2-xa+y=0$ 的两个解。</p>
</li>
<li><p>然后根据求根公式算出答案就可以了。只不过这边要把所有数的个数放入桶中，然后从桶中取出来算方案数（组合数知识）。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],mp[w[i]]++;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> t=x*x<span class="number">-4</span>*y;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;0 &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">int</span>)<span class="built_in">sqrt</span>(t)*(<span class="type">int</span>)<span class="built_in">sqrt</span>(t)!=t)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;0 &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> p=x/<span class="number">2</span>;</span><br><span class="line">                cout&lt;&lt;(mp[p]*(mp[p]<span class="number">-1</span>)/<span class="number">2</span>)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;0 &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x1=(x-<span class="built_in">sqrt</span>(t))/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> x2=(x+<span class="built_in">sqrt</span>(t))/<span class="number">2</span>;</span><br><span class="line">        cout&lt;&lt;mp[x1]*mp[x2]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1867D-Cyclic-Operations-1800-找规律，拓扑排序"><a href="#1867D-Cyclic-Operations-1800-找规律，拓扑排序" class="headerlink" title="1867D-Cyclic Operations *1800 找规律，拓扑排序"></a>1867D-Cyclic Operations <strong>*1800</strong> 找规律，拓扑排序</h2><ul>
<li><p>根据 $a<em>{l_i}$​​ 改变为 $l</em>{(i\%k)+1}$，当 $k=1$ 时，就是：$a<em>{l_i}$​​ 改变为 $l</em>{1}$，此时就是说明 $a_1=1,a_2=2$ 这样的。</p>
</li>
<li><p>当 $k=1$ 的时候类似自环，那么此时当 $k&gt;=2$ 时，能否类比 $k=1$ 的时候呢？</p>
</li>
<li><p>发现可以的，此时把 $i\rightarrow w_i$，如果环的大小为 $k$，那么满足条件。</p>
</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/epb7iias.png" alt=""></p>
<p><a href="https://cdn.luogu.com.cn/upload/image_hosting/epb7iias.png">参考图片来源</a></p>
<ul>
<li><p>那么只要缩点，然后看缩点的联通块的大小即可。</p>
</li>
<li><p><strong>这里得注意：<code>targin</code> 是算不了自环的情况，这个得单独判断。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="function">VII <span class="title">g</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        g[i].<span class="built_in">emplace_back</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=w[i])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//注意targin无法统计自环的</span></span><br><span class="line">        <span class="keyword">if</span>(i==w[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">dfn</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">low</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> tmd=<span class="number">0</span>,top=<span class="number">0</span>,scc_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="function">VI <span class="title">scc_size</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">stk</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">in_stk</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; targin=[&amp;](<span class="type">int</span> u)&#123;</span><br><span class="line">        dfn[u]=low[u]=++tmd;</span><br><span class="line">        stk[++top]=u,in_stk[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[j])&#123;</span><br><span class="line">                <span class="built_in">targin</span>(j);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            scc_cnt++;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                y=stk[top--];</span><br><span class="line">                in_stk[y]=<span class="literal">false</span>;</span><br><span class="line">                scc_size[scc_cnt]++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">targin</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,scc_cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(scc_size[i]!=<span class="number">1</span>&amp;&amp;scc_size[i]!=k)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(scc_size[i]==k)f=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(f?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>有的时候规律都是从特殊情况类比到一般情况的。</p>
</blockquote>
<h2 id="1870D-Prefix-Purchase-1800-贪心；好题"><a href="#1870D-Prefix-Purchase-1800-贪心；好题" class="headerlink" title="1870D-Prefix Purchase *1800 贪心；好题"></a>1870D-Prefix Purchase <strong>*1800</strong> 贪心；好题</h2><ul>
<li><p>可以很容易有个贪心策略：价格越便宜的多买；尽量买越靠后的。</p>
</li>
<li><p>也就是：如果满足 $a<em>i​&gt;a</em>{i+1}$​ 的话，那么选 $i+1$ 位置一定比选 $i$ 位置更优。所以我们就可以先将 $a<em>i$​ 赋值为 $\min(a_i​,a</em>{i+1}​)$，这样就可以避免掉上面所说的这种情况了。</p>
</li>
<li><p>题目要求字典序最大，所以我们肯定要贪心的去先选前面的。但是我们会发现选完 $a_1$​ 之后 $k$ 还会剩下一些，如果直接不管的话肯定不是最优的。所以我们就可以用 $k$ 剩下的这些值去将一些选 $a_1$​ 的变成选 $a_2$​ 的，这样既可以保证当前的字典序不变（选 $1$ 的个数没变），还可以让后面的字典序变大（选 $2$ 的个数变多）。</p>
</li>
<li><p>那么就可以算出选 $a_2$​ 的数量就应该是：$(k−k÷a1​×a1​)÷(a2​−a1​)$。意思是用 $k$ 剩下的值除以每一次变化需要的代价。</p>
</li>
</ul>
<p><a href="https://www.luogu.com.cn/article/1kkd2zpq"><del>因为这道题我卡在第二步，没想出来，这里附一个参考解题</del></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">b</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">1e18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mi=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        mi=<span class="built_in">min</span>(mi,w[i]);</span><br><span class="line">        b[i]=mi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==b[i<span class="number">-1</span>])ans[i]=ans[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> ans[i]=<span class="built_in">min</span>(k/(b[i]-b[i<span class="number">-1</span>]),ans[i<span class="number">-1</span>]);</span><br><span class="line">        k-=(b[i]-b[i<span class="number">-1</span>])*ans[i];</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>卡在第二步，没有想到居然可以倒着维护最小值来解决最优解问题（意思就是<strong>价格越便宜的多买，尽量买越靠后的</strong>），这样倒着求最小值就能让价格便宜的靠后了。</p>
</blockquote>
<h2 id="1875D-Jellyfish-and-Mex-1600-dp"><a href="#1875D-Jellyfish-and-Mex-1600-dp" class="headerlink" title="1875D-Jellyfish and Mex *1600 dp"></a>1875D-Jellyfish and Mex <strong>*1600</strong> dp</h2><ul>
<li><p>看到数据规模比较小，考虑dp，特别注意是 $n$ 比较小，那么也就说 $mex$ 值不大，因此 dp 只能 dp $mex$ 值。</p>
</li>
<li><p>首先状态表示：$f_i$ 表示当前的 <strong>$mex$ 值</strong> 是 $i$ 的 $m$ 的最小值。</p>
</li>
<li><p>状态转移：$f<em>i=min(f</em>{j}+(c_i-1)*j+i)$，其中 $j&gt;i$。</p>
</li>
<li><p>答案就是 $f_0$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],cnt[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt[mex])mex++;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(mex<span class="number">+1</span>,<span class="number">1e18</span>)</span></span>;</span><br><span class="line">    f[mex]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,mex)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[i]+(cnt[j]<span class="number">-1</span>)*i+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没想到居然是用 $mex$ 来 dp 的，服了。</p>
</blockquote>
<h2 id="1879D-Sum-of-XOR-Functions-1700-套路题；位运算"><a href="#1879D-Sum-of-XOR-Functions-1700-套路题；位运算" class="headerlink" title="1879D-Sum of XOR Functions *1700 套路题；位运算"></a>1879D-Sum of XOR Functions <strong>*1700</strong> 套路题；位运算</h2><ul>
<li>上公式：</li>
</ul>
<script type="math/tex; mode=display">\sum_{l=1}^{n}\sum_{r=l}^{n}f(l,r)\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{l=1}^{r}f(l,r)\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{l=1}^{r}\sum_{i=0}^{32} s_{l,i} \operatorname{xor} s_{r,i}\times 2^i\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{i=0}^{32} \sum_{l=1}^{r}[ s_{r,i}\operatorname{xor}s_{l,i} =1]\times 2^i\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{i=0}^{32} 2^i\times\sum_{l=1}^{r}[ s_{r,i}\operatorname{xor}s_{l,i} =1]\times r-[ s_{r,i}\operatorname{xor}s_{l,i} =1] \times (l-1)</script><ul>
<li><p>此时把 $r$ 当作变量，后面的 $\sum<em>{l=1}^{r}[ s</em>{r,i}\operatorname{xor}s<em>{l,i} =1]\times r-[ s</em>{r,i}\operatorname{xor}s_{l,i} =1] \times (l-1)$ 可以直接算出来的，给它一个含义：前缀中与 $s_r$ 值相反的数的个数。</p>
</li>
<li><p>注意这里是 $l-1$，因此它的增幅会慢一拍。</p>
</li>
<li><p>在代码中体现就是: <code>cnt[i][j]</code>是中括号满足条件的，<code>sum[i][j]</code> 就是 $l-1$ 那一项的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]^w[i];</span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">0</span>,<span class="number">32</span>)&#123;</span><br><span class="line">            sep[i][j]=((s[i]&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">32</span>)cnt[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//固定r</span></span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">0</span>,<span class="number">32</span>)&#123;<span class="comment">//sep[i][j]^1就是与当前不同的前缀，这样能满足</span></span><br><span class="line">            ans=(ans+(cnt[j][sep[i][j]^<span class="number">1</span>]*i%mod-sum[j][sep[i][j]^<span class="number">1</span>]%mod<span class="number">+2</span>*mod)*(<span class="number">1</span>&lt;&lt;j))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">0</span>,<span class="number">32</span>)&#123;<span class="comment">//r扩展，个数也得扩展,因为是l-1,所以会慢一拍</span></span><br><span class="line">            sum[j][sep[i][j]]+=i;</span><br><span class="line">            cnt[j][sep[i][j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>公式推导牢记。</p>
</blockquote>
<h2 id="1889B-Doremy’s-Connecting-Plan-1700-排序，思维"><a href="#1889B-Doremy’s-Connecting-Plan-1700-排序，思维" class="headerlink" title="1889B-Doremy’s Connecting Plan *1700 排序，思维"></a>1889B-Doremy’s Connecting Plan <strong>*1700</strong> 排序，思维</h2><ul>
<li><p>要求 $\sum_{k \in S}a_k \ge i \cdot j\cdot c$ ，此时公式里面有三个变量，不好搞，此时就让 $i=1$，这样就能优化掉一个变量。</p>
</li>
<li><p>为什么选 $1$ 可以呢？</p>
</li>
</ul>
<p>证明：假设它们都不能和 1 连边，那么：</p>
<script type="math/tex; mode=display">\begin{aligned}
a_i + a_j \ge i \cdot j\cdot c \\
a_i + a_1 < i \cdot c \\
a_j + a_1 < j \cdot c
\end{aligned}</script><p>后两行相加与第一行比较，又由于 $a_1​≥0$，得出：</p>
<script type="math/tex; mode=display">(i + j) \cdot c \gt i\cdot j \cdot c</script><script type="math/tex; mode=display">i + j \gt i\cdot j</script><p>那么显然这个式子是矛盾的，因此必须跟 $1$ 相连。</p>
<ul>
<li>那么只需要考虑和 $1$ 连边的情况了，此时只需要算：$a_i - i \cdot c$ 即可。此时就按这个从大到小排序，只要 $sum+a_i&lt;i\cdot c$ 就输出 <code>NO</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; a,<span class="type">const</span> E&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x-c*a.y&gt;b.x-c*b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i].x,w[i].y=i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+2</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=w[<span class="number">1</span>].x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum+w[i].x&lt;w[i].y*c)&#123;</span><br><span class="line">            No;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=w[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    Yes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当出现多个变量，可以考虑去掉一个变量的方法去做。</p>
</blockquote>
<h2 id="1923D-Slimes-1800-二分；细节题"><a href="#1923D-Slimes-1800-二分；细节题" class="headerlink" title="1923D-Slimes *1800 二分；细节题"></a>1923D-Slimes <strong>*1800</strong> 二分；细节题</h2><ul>
<li><p>看某个点是否能被史莱姆吃掉，就看它前面或者后面是否能累加起来（必须只有严格大的才能累加）比当前大，因此这里可以用二分来判断存不存在以及最小值。</p>
</li>
<li><p>由于题目说一个史莱姆只能在严格大于其邻居的情况下吃掉该邻居，因此我这里处理相等情况以及前缀和。</p>
</li>
<li><p>然后就是愉快的二分过程了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],pre[i]=pre[i<span class="number">-1</span>]+w[i],c[i]=c[i<span class="number">-1</span>]+<span class="built_in">abs</span>(w[i]-w[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>((w[i<span class="number">-1</span>]&gt;w[i]&amp;&amp;i&gt;<span class="number">1</span>)||(w[i<span class="number">+1</span>]&gt;w[i]&amp;&amp;i&lt;n))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;1 &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&amp;&amp;pre[i<span class="number">-1</span>]&gt;w[i])&#123;</span><br><span class="line">            l=<span class="number">0</span>,r=i;</span><br><span class="line">            <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre[i<span class="number">-1</span>]-pre[mid<span class="number">-1</span>]&lt;=w[i]||(c[i<span class="number">-1</span>]-c[mid]==<span class="number">0</span>&amp;&amp;i<span class="number">-1</span>!=mid))r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,i-l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i-n&amp;&amp;pre[n]-pre[i]&gt;w[i])&#123;</span><br><span class="line">            l=i,r=n<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre[mid]-pre[i]&lt;=w[i]||(c[mid]-c[i<span class="number">+1</span>]==<span class="number">0</span>&amp;&amp;i<span class="number">+1</span>!=mid))l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r!=n<span class="number">+1</span>)&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,r-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;(ans==<span class="number">1e18</span>?<span class="number">-1</span>:ans)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二分思路其实很简单的，因为你要找最小值，那么此时二分一个答案，看看能不能满足，不能满足就继续二分，具备二段性和单调性。</p>
<p>但这道题的细节特别多，一不小心就错了。</p>
</blockquote>
<h2 id="1934C-Find-a-Mine-1700-猜答案"><a href="#1934C-Find-a-Mine-1700-猜答案" class="headerlink" title="1934C-Find a Mine *1700 猜答案"></a>1934C-Find a Mine <strong>*1700</strong> 猜答案</h2><ul>
<li><p>因为只有 $4$ 次查询机会，保证网格中恰好有 $2$ 个地雷。还可以发现对于一个地雷，它产生的最小曼哈顿距离在同一个对角线上都是相同的。</p>
</li>
<li><p>第一次查询：可以先查询 $(1,1)$ 这个点，把距离记为 $d_1$。</p>
</li>
<li><p>第二次查询和第三次查询：根据 $d_1$ 的值跟 $n$ 和 $m$ 进行比较，进而将坐标推进到对角线上。</p>
</li>
<li><p>第四次查询：现在已经查找到了对角线的两个端点 $(x_1,y_1)$ 和 $(x_2,y_2)$，此时根据 $d_2$ 和 $d_3$ 定位到一个地雷的位置，如果这个位置得到的 $d_4$ 是 $0$ 的话，那么就是答案了。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/chunyou_/article/details/136593611">图</a>：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/74a342d23c7cb4bfb36407435f5ae6bc.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? 1 1&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;d[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(d[<span class="number">0</span>]&lt;n)&#123;</span><br><span class="line">        x1=d[<span class="number">0</span>]<span class="number">+1</span>,y1=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x1=n,y1=d[<span class="number">0</span>]<span class="number">+2</span>-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[<span class="number">0</span>]&lt;m)x2=<span class="number">1</span>,y2=d[<span class="number">0</span>]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">else</span> x2=d[<span class="number">0</span>]<span class="number">+2</span>-m,y2=m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;d[<span class="number">1</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x2&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;d[<span class="number">2</span>];</span><br><span class="line">    d[<span class="number">1</span>]/=<span class="number">2</span>,d[<span class="number">2</span>]/=<span class="number">2</span>;</span><br><span class="line">    x1-=d[<span class="number">1</span>],y1+=d[<span class="number">1</span>];</span><br><span class="line">    x2+=d[<span class="number">2</span>],y2-=d[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;d[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(!d[<span class="number">3</span>])cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;x1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;x2&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>卡在：已经知道第一次查询，然后也知道扩展坐标到对角线的端点，但我无法确定第二次查询和第三次查询该如何操作。</p>
</blockquote>
<hr>
<p>又结束咯，题目不在于多，而在于精。</p>
<hr>
<p>这个后期改为好题归类，因为计划变更为：每天得VP一场古老cf。相信自己能变得越来越强吧</p>
<hr>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点系列——基本算法</title>
    <url>/2025/02/20/%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="2-2-尺取法"><a href="#2-2-尺取法" class="headerlink" title="2.2 尺取法"></a>2.2 尺取法</h1><h2 id="HDU-2029-Palindromes-easy-version"><a href="#HDU-2029-Palindromes-easy-version" class="headerlink" title="HDU-2029 Palindromes _easy version"></a>HDU-2029 Palindromes _easy version</h2><ul>
<li>回文数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string t=s;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(t));</span><br><span class="line">    <span class="keyword">if</span>(s==t) cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-5358-First-One"><a href="#HDU-5358-First-One" class="headerlink" title="HDU - 5358 First One"></a>HDU - 5358 First One</h2><ul>
<li>因为题目有 $\log$，然后又是双重循环，肯定得优化，因为存在 $\log$，那么又得考虑每一位了。这道题有个特殊的地方就是，我们可以令 $k=(\log_2{S(i,j)}+1)，我们可以枚举 $k$ 的值，尺取法选择区间 $[l,r]$ 满足的 $k$，然后固定 $i$ 找 $j$ 满足的区间 $[l,r]$，则在区间中的 $(i+j)=i<em>(r-l+1)+(r-l+1)</em>(l+r)/2$，最后再乘 $k$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(k,<span class="number">1</span>,<span class="number">34</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L=(<span class="number">1ll</span>&lt;&lt;(k<span class="number">-1</span>)),R=(<span class="number">1ll</span>&lt;&lt;k)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)L=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="number">1</span>,l=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            l=<span class="built_in">max</span>(l,i);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=n&amp;&amp;s[l]-s[i<span class="number">-1</span>]&lt;L)l++;</span><br><span class="line">            r=<span class="built_in">max</span>(r,l);</span><br><span class="line">            <span class="keyword">while</span>(r&lt;=n&amp;&amp;s[r]-s[i<span class="number">-1</span>]&gt;=L&amp;&amp;s[r]-s[i<span class="number">-1</span>]&lt;=R)r++;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">                ans+=((r-l)*i+(r-l)*(l+r<span class="number">-1</span>)/<span class="number">2</span>)*k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="580B-Kefa-and-Company"><a href="#580B-Kefa-and-Company" class="headerlink" title="580B-Kefa and Company"></a>580B-Kefa and Company</h2><ul>
<li>题意：给定一些人的钱和贡献，选取一些人让他们的钱之差不超过d，使贡献最大。</li>
<li>思路：先按工资升序排序，然后套上尺取就行了，时间复杂度 $O(n\log n)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].a&gt;&gt;w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w+n<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(l,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=n&amp;&amp;w[r].a-w[l].a&lt;m)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>……</p>
<hr>
<p>总结一下尺取法：尺取法的本质就是给定 $l$ ，然后去找满足条件的 $r$。应用：见到有单调性、有限制的区间问题，很自然地就会想到用尺取去做。</p>
<hr>
<h1 id="2-3-二分法"><a href="#2-3-二分法" class="headerlink" title="2.3 二分法"></a>2.3 二分法</h1><h2 id="洛谷-P1462-通往奥格瑞玛的道路"><a href="#洛谷-P1462-通往奥格瑞玛的道路" class="headerlink" title="洛谷 - P1462 通往奥格瑞玛的道路"></a>洛谷 - P1462 通往奥格瑞玛的道路</h2><h2 id="洛谷-P1824-进击的奶牛"><a href="#洛谷-P1824-进击的奶牛" class="headerlink" title="洛谷 - P1824 进击的奶牛"></a>洛谷 - P1824 进击的奶牛</h2><h2 id="洛谷-P1419-寻找段落"><a href="#洛谷-P1419-寻找段落" class="headerlink" title="洛谷 - P1419 寻找段落"></a>洛谷 - P1419 寻找段落</h2><h2 id="洛谷-P1083-借教室"><a href="#洛谷-P1083-借教室" class="headerlink" title="洛谷 - P1083 借教室"></a>洛谷 - P1083 借教室</h2><h2 id="洛谷-P2678-跳石头"><a href="#洛谷-P2678-跳石头" class="headerlink" title="洛谷 - P2678 跳石头"></a>洛谷 - P2678 跳石头</h2><h2 id="洛谷-P1314-聪明的质监员"><a href="#洛谷-P1314-聪明的质监员" class="headerlink" title="洛谷 - P1314 聪明的质监员"></a>洛谷 - P1314 聪明的质监员</h2><h2 id="洛谷-P1868-饥饿的奶牛"><a href="#洛谷-P1868-饥饿的奶牛" class="headerlink" title="洛谷 - P1868 饥饿的奶牛"></a>洛谷 - P1868 饥饿的奶牛</h2><h2 id="洛谷-P1493-分梨子"><a href="#洛谷-P1493-分梨子" class="headerlink" title="洛谷 - P1493 分梨子"></a>洛谷 - P1493 分梨子</h2><h2 id="HDU-6231-K-th-Number"><a href="#HDU-6231-K-th-Number" class="headerlink" title="HDU - 6231 K-th Number"></a>HDU - 6231 K-th Number</h2><h1 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h1><h2 id="洛谷-P3382-三分"><a href="#洛谷-P3382-三分" class="headerlink" title="洛谷-P3382 三分"></a>洛谷-P3382 三分</h2><h2 id="HDU-3400-Line-belt"><a href="#HDU-3400-Line-belt" class="headerlink" title="HDU-3400 Line belt"></a>HDU-3400 Line belt</h2><h2 id="洛谷-P3745-期末考试"><a href="#洛谷-P3745-期末考试" class="headerlink" title="洛谷-P3745 期末考试"></a>洛谷-P3745 期末考试</h2><h2 id="洛谷-P1883-三分-函数"><a href="#洛谷-P1883-三分-函数" class="headerlink" title="洛谷-P1883 三分 | 函数"></a>洛谷-P1883 三分 | 函数</h2><h1 id="2-5-倍增法与ST算法"><a href="#2-5-倍增法与ST算法" class="headerlink" title="2.5 倍增法与ST算法"></a>2.5 倍增法与ST算法</h1><h2 id="洛谷-P4155-国旗计划"><a href="#洛谷-P4155-国旗计划" class="headerlink" title="洛谷-P4155 国旗计划"></a>洛谷-P4155 国旗计划</h2><h2 id="洛谷-P2880-Balanced-Lineup-G"><a href="#洛谷-P2880-Balanced-Lineup-G" class="headerlink" title="洛谷-P2880 Balanced Lineup G"></a>洛谷-P2880 Balanced Lineup G</h2><h2 id="HDU-5443-The-Water-Problem"><a href="#HDU-5443-The-Water-Problem" class="headerlink" title="HDU-5443 The Water Problem"></a>HDU-5443 The Water Problem</h2><h2 id="HDU-6107-Typesetting"><a href="#HDU-6107-Typesetting" class="headerlink" title="HDU-6107 Typesetting"></a>HDU-6107 Typesetting</h2><h2 id="洛谷-P3865-ST-表-amp-amp-RMQ-问题"><a href="#洛谷-P3865-ST-表-amp-amp-RMQ-问题" class="headerlink" title="洛谷-P3865 ST 表 &amp;&amp; RMQ 问题"></a>洛谷-P3865 ST 表 &amp;&amp; RMQ 问题</h2><h2 id="洛谷-P2251-质量检测"><a href="#洛谷-P2251-质量检测" class="headerlink" title="洛谷-P2251 质量检测"></a>洛谷-P2251 质量检测</h2><h2 id="洛谷-P1816-忠诚"><a href="#洛谷-P1816-忠诚" class="headerlink" title="洛谷-P1816 忠诚"></a>洛谷-P1816 忠诚</h2><h2 id="洛谷-P1198-最大数"><a href="#洛谷-P1198-最大数" class="headerlink" title="洛谷-P1198 最大数"></a>洛谷-P1198 最大数</h2><h1 id="2-6-前缀和与差分"><a href="#2-6-前缀和与差分" class="headerlink" title="2.6 前缀和与差分"></a>2.6 前缀和与差分</h1><h2 id="HDU-1556-Color-the-ball"><a href="#HDU-1556-Color-the-ball" class="headerlink" title="HDU-1556 Color the ball"></a>HDU-1556 Color the ball</h2><h2 id="HDU-6273-Master-of-GCD"><a href="#HDU-6273-Master-of-GCD" class="headerlink" title="HDU-6273 Master of GCD"></a>HDU-6273 Master of GCD</h2><h1 id="2-7-离散化"><a href="#2-7-离散化" class="headerlink" title="2.7 离散化"></a>2.7 离散化</h1>]]></content>
      <tags>
        <tag>知识点系列</tag>
      </tags>
  </entry>
  <entry>
    <title>VP Educational Codeforces Round 1</title>
    <url>/2025/02/26/VP-Educational-Codeforces-Round-1/</url>
    <content><![CDATA[<p>成果：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3oooxrkj.png" alt=""></p>
<h1 id="A-Tricky-Sum"><a href="#A-Tricky-Sum" class="headerlink" title="A. Tricky Sum"></a>A. Tricky Sum</h1><ul>
<li><p>题意：给定正整数 $n(n\le 10^9)$， $i\in [1,n]$，如果 $i$ 是 $2$ 的幂次，则减去 $i$ ，否则加上 $i$。</p>
</li>
<li><p>思路：因为 $n$ 不大，所以在 $n$ 的范围内 $2$ 的幂次比较少，这里可以暴力做。然后我们可以先算 $1+2+…+n$，这里用等差数列前 $n$ 项和，然后再减去两倍的二次幂。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tot=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        p+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    tot-=<span class="number">2</span>*p;</span><br><span class="line">    cout&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Queries-on-a-String"><a href="#B-Queries-on-a-String" class="headerlink" title="B. Queries on a String"></a>B. Queries on a String</h1><ul>
<li><p>题意：给定长度为 $10000$ 的字符串，一共进行 $m(m\le 300)$ 次操作，每次操作给定 $l,r,k(k\le 10^6)$，字符串的区间 $[l,r]$ 想右移动 $k$ 次，求最终的字符串。</p>
</li>
<li><p>思路：我们可以知道，一个字符串向右移动 $r-l+1$ 就是原串，又因为 $r-l+1$ 不大，然后就暴力的拼接字符串即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    n=s.sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,k;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="type">int</span> len=r-l<span class="number">+1</span>;</span><br><span class="line">        k%=len;</span><br><span class="line">        string p1=s.<span class="built_in">substr</span>(l<span class="number">-1</span>,len-k);</span><br><span class="line">        string p2=s.<span class="built_in">substr</span>(l+len-k<span class="number">-1</span>,k);</span><br><span class="line">        string p3=p2+p1;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=l<span class="number">-1</span>&amp;&amp;i&lt;=r<span class="number">-1</span>)&#123;</span><br><span class="line">                s[i]=p3[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Nearest-vectors"><a href="#C-Nearest-vectors" class="headerlink" title="C. Nearest vectors"></a>C. Nearest vectors</h1><ul>
<li><p>题意：给定 $n$ 个向量，输出形成的夹角最小的两个向量的编号。</p>
</li>
<li><p>思路：我们可以用 <code>atan2(y,x)</code> 来计算极角，然后对极角从小到大进行排序，两个极角相减就是夹角，如果极角相减为负数，此时就得加上 $2\pi$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">double</span> angle,x,y;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(angle==t.angle)<span class="keyword">return</span> id&lt;t.id;</span><br><span class="line">        <span class="keyword">return</span> angle&lt;t.angle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">double</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">double</span> angle=<span class="built_in">atan2</span>(y,x);</span><br><span class="line">        w[i]=&#123;angle,x,y,i<span class="number">+1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w,w+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ans=<span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">double</span> angle=(w[(i<span class="number">+1</span>)%n].angle-w[i].angle);</span><br><span class="line">        <span class="keyword">if</span>(angle&lt;<span class="number">0</span>)angle+=<span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;angle)&#123;</span><br><span class="line">            ans=angle;</span><br><span class="line">            t1=w[(i<span class="number">+1</span>)%n].id,t2=w[i%n].id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;t1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;t2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Igor-In-the-Museum"><a href="#D-Igor-In-the-Museum" class="headerlink" title="D. Igor In the Museum"></a>D. Igor In the Museum</h1><ul>
<li><p>题意：给定 $1000\times 1000$ 的网格，每个格子为空地或墙壁。对于每一片连通的空地，求这片空地与多少个墙壁联通。</p>
</li>
<li><p>思路：这里算答案很容易想到用 <code>bfs</code> 来做。但由于查询次数很多，万一所有查询都是查同一个点的话，那么会超时的。因此我们把空地连成一个连通块，然后放在数组里面，当且仅当数组没有数的时候我们再去查询。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="keyword">while</span>(q.sz)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x,y]=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">pb</span>(&#123;x,y&#125;);</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a=dx[i]+x,b=dy[i]+y;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>||b&lt;<span class="number">1</span>||a&gt;n||b&gt;m||vis[a][b])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[a][b]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">            vis[a][b]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:res)&#123;</span><br><span class="line">        S[x][y]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(!S[x][y])&#123;</span><br><span class="line">            <span class="built_in">work</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;S[x][y]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Chocolate-Bar"><a href="#E-Chocolate-Bar" class="headerlink" title="E. Chocolate Bar"></a>E. Chocolate Bar</h1><ul>
<li>题意：对于一个由 $n$ 行 $m$ 列个小格子组成的矩形，我们称之为一块巧克力。对于一块巧克力，我们可以横向或纵向一刀切割为两块子巧克力（小格子是原子性的，无法切割成两部分），每次切割开需要切开长度的平方的代价。给定一块至多 $30 \times 30$ 的巧克力，我们可以多次切割得到很多子巧克力，从其中选择一些巧克力，使得选择的巧克力总共恰好含有  $k(k \leq 50)$ 个小格子。寻求合法方案的最小代价。</li>
<li>思路：因为这里的 $n,m,k$ 都是 $100$ 以内的数，又因为你切某一行或后一列会对后续产生影响，因此考虑dp。设 $f<em>{i,j,k}$ 表示大小为 $i\times j$ 的巧克力中取出 $k$ 块的代价。状态转移：$f</em>{i,j,k}=\min(f<em>{b,j,a}+f</em>{i-b,j,k-a}+j<em>j),b\in [1,b)，f<em>{i,j,k}=\min(f</em>{i,c,a}+f_{i,j-c,k-a}+i</em>i,c\in [1,j)$。</li>
</ul>
<p>当然可以用五重for循环，也可以用记忆化搜索。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k||x*y==k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x*y&lt;k)<span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[x][y][k]!=<span class="number">-1</span>)<span class="keyword">return</span> f[x][y][k];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,x<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,y*y+<span class="built_in">calc</span>(x-i,y,k-j)+<span class="built_in">calc</span>(i,y,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,y<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,x*x+<span class="built_in">calc</span>(x,y-i,k-j)+<span class="built_in">calc</span>(x,i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y][k]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m][k]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Task = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">30</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,<span class="number">30</span>)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(k,<span class="number">1</span>,<span class="number">50</span>)&#123;</span><br><span class="line">                f[i][j][k]=<span class="built_in">calc</span>(i,j,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (cin &gt;&gt; Task; Task; Task--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Cut-Length"><a href="#F-Cut-Length" class="headerlink" title="F. Cut Length"></a>F. Cut Length</h1><ul>
<li><p>题意：给定一个由 $n ( n ≤ 1000 )$ 个点构成的多边形（可凹可凸），给出 $m (m \leq 100)$ 次询问， 每次询问给定一条直线，求直线与多边形公共部分的长度。</p>
</li>
<li><p>思路：<a href="https://www.luogu.com.cn/article/g4yis80c">来源且参考</a></p>
</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9xqimomd.png" alt=""></p>
<ul>
<li><ul>
<li>如果我们最终计算得到的答案大于 $0$，这意味着给定的直线必然与多边形的某些边有交点。我们可以通过向量的叉积来判断点在直线的位置：</li>
</ul>
</li>
<li>叉积为正，点在直线左侧</li>
<li>叉积为负，点在直线右侧</li>
<li><p>叉积为零，点在直线上</p>
</li>
<li><ul>
<li>当一条线段的两个端点位于直线的不同侧时（即一个点的叉积为正，另一个点的叉积为负），这条线段必然与直线相交。</li>
</ul>
</li>
<li><ul>
<li>我们考虑向量 $\overrightarrow{AQ’}$ 与 $\overrightarrow{AP}$ 和 $\overrightarrow{AB}$ 的叉积关系：</li>
</ul>
</li>
</ul>
<ol>
<li>$\overrightarrow{AQ’}\times\overrightarrow{AP}=2S_{\triangle{APQ’}}$ </li>
<li>$\overrightarrow{AQ’}\times\overrightarrow{AB}=2S_{\triangle{ABQ’}}$</li>
</ol>
<ul>
<li><ul>
<li>由于三角形 $\triangle<em>{APQ’}$ 和 $\triangle</em>{ABQ’}$ 共用底边 $AQ’$，它们的面积比等于高的比值，即：</li>
</ul>
</li>
</ul>
<p>$\frac{S<em>{\triangle{APQ’}}}{S</em>{\triangle{ABQ’}}} = \frac{h_P}{h_B}$</p>
<p>其中 $h_P$ 和 $h_B$ 分别是点 $P$ 和点 $B$ 到直线 $AQ’$ 的距离。</p>
<ul>
<li><ul>
<li>因为 $AQ’$ 平行于 $PQ$（记作 $AQ’\parallel PQ$），所以点 $A$ 到直线 $AQ’$ 的距离等于点 $P$ 到直线 $PQ$ 的距离。根据相似三角形性质：</li>
</ul>
</li>
</ul>
<p>$\frac{|AM|}{|AB|} = \frac{\overrightarrow{AQ’}\times\overrightarrow{AP}}{\overrightarrow{AQ’}\times\overrightarrow{AB}}$</p>
<p>这个比值就是我们要记录的边 $PQ$ 的贡献值。</p>
<ul>
<li><ul>
<li>我们使用最小堆（小根堆）来存储所有有贡献的边，每条边用一个二元组（pair）表示：</li>
</ul>
</li>
<li><code>first</code>：表示该边的贡献值</li>
<li><code>second</code>：表示相对位置，计算方式为 $r_{i+1}-r_i$<ul>
<li>当点 $i$ 在直线左边时，$r_i=-1$</li>
<li>当点 $i$ 在直线右边时，$r_i=1$</li>
<li>当点 $i$ 在直线上时，$r_i=0$</li>
</ul>
</li>
</ul>
<p>维护一个变量 $sum$ 表示 <code>second</code> 的前缀和。当 $sum \neq 0$ 时，表示当前段落位于多边形内部。</p>
<ul>
<li><ul>
<li>设当前考虑的边的两个端点分别是 $M$ 和 $N$，则：</li>
</ul>
</li>
<li>$|AM| = first_i$</li>
<li>$|AN| = first_{i+1}$</li>
<li>边 $MN$ 的贡献值为 $first_{i+1}-first_i$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/uasuz2jm.png" alt=""></li>
<li><ul>
<li>将所有有效贡献值求和后，再乘以 $|AB|$ 即可得到最终答案。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    Point <span class="keyword">operator</span> +(Point t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x+t.x,y+t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-t.x,y-t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> *(<span class="type">int</span> t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x*t,y*t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="type">int</span> t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x/t,y/t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x-y)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dist</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx=a.x-b.x;</span><br><span class="line">    <span class="type">double</span> dy=a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getLineIntersection</span><span class="params">(Point p1,Point v1,Point p2,Point v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cross</span>(v2,p2-p1)/<span class="built_in">cross</span>(v1,v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">work</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">    Point v=B-A;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt;&gt;pos;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> s1=<span class="built_in">sign</span>(<span class="built_in">cross</span>(v,(w[i]-A)));</span><br><span class="line">        <span class="type">int</span> s2=<span class="built_in">sign</span>(<span class="built_in">cross</span>(v,(w[(i<span class="number">+1</span>)%n]-A)));</span><br><span class="line">        <span class="keyword">if</span>(s1==s2)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">double</span> p=<span class="built_in">getLineIntersection</span>(A,v,w[i],w[(i<span class="number">+1</span>)%n]-w[i]);</span><br><span class="line">        pos.<span class="built_in">pb</span>(&#123;p,s1-s2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(pos));</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,pos.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        t+=pos[i].se;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            res+=pos[i<span class="number">+1</span>].fi-pos[i].fi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res*(<span class="built_in">get_dist</span>(A,B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].x&gt;&gt;w[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        Point A,B;</span><br><span class="line">        cin&gt;&gt;A.x&gt;&gt;A.y&gt;&gt;B.x&gt;&gt;B.y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.20Lf\n&quot;</span>,<span class="built_in">work</span>(A,B));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
