<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024整理</title>
    <url>/2025/01/01/2024%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="1810C-Make-It-Permutation"><a href="#1810C-Make-It-Permutation" class="headerlink" title="1810C-Make It Permutation"></a><a href="https://codeforces.com/contest/1810/problem/C">1810C-Make It Permutation</a></h1><ul>
<li><p>题意：给定一个长为 n 的序列 a，你可以进行以下两个操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 删除 a 中的任意一个数字，花费为 c。</span><br><span class="line">2. 往 a 的任意位置插入一个数字，花费为 d。</span><br></pre></td></tr></table></figure>
<p>求最后得到一个任意长度的排列的最小花费。</p>
</li>
<li><p>思路：重复的要删掉，缺少的要补上，因此可以先对 $a$ 进行排序，去重。我们可以依次遍历整个数组，对于每个元素 $a_i$，构造一个 $[1,a_i]$ 的排列需要的花费是 $c\times(n-i)+d\times(a_i-i)$，取其中的最小值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">w</span>(n);</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=n*c+d;</span><br><span class="line">    <span class="built_in">sort</span>(w.<span class="built_in">begin</span>(),w.<span class="built_in">end</span>());</span><br><span class="line">    w.<span class="built_in">erase</span>(<span class="built_in">unique</span>(w.<span class="built_in">begin</span>(),w.<span class="built_in">end</span>()),w.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m=w.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,(n-i<span class="number">-1</span>)*c+(w[i]-i<span class="number">-1</span>)*d);<span class="comment">//排列排序之后都跟下标有关系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1381A2-Prefix-Flip-Hard-Version"><a href="#1381A2-Prefix-Flip-Hard-Version" class="headerlink" title="1381A2-Prefix Flip (Hard Version)"></a><a href="https://codeforces.com/contest/1381/problem/A2">1381A2-Prefix Flip (Hard Version)</a></h1><ul>
<li>题意：给定两个二进制字符串 $a$ 和 $b$ ，通过不超过 $2n$ 次操作，将字符串 $a$ 变成字符串 $b$。每一次操作将字符串 $a$ 的前 $p$ 个字符中 $0$ 变成 $1$，$1$ 变成 $0$，并将前 $p$ 个字符反转。</li>
<li>思路：如果每一个字符串只有 $1$ 或者 $0$ 那么只需要一次操作即可，所以，接下来的任务就是如何将每一个字符串变成只有一个字符的字符串这个可以从前面开始遍历，如果这个位置与后一个位置不同，那么就对这一个位置之前的进行操作，一直到最后就可以了。举个例子：<br>$01010→11010→00010→11110→00000$，而且，我们经过上面的操作之后，每一个字符串的字符与原字符串最后一个字符相同，所以我们就不需要在数组中修改了，这样就能减少时间复杂度。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;a,b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=s[i<span class="number">+1</span>])&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[i]!=t[i<span class="number">+1</span>])&#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[n<span class="number">-1</span>]!=t[n<span class="number">-1</span>])&#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>())&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:a)cout&lt;&lt;c&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:b)cout&lt;&lt;c&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大启发，转化成全部相同的数最优</p>
<h1 id="1684D-Traps"><a href="#1684D-Traps" class="headerlink" title="1684D Traps"></a><a href="https://codeforces.com/contest/1684/problem/D">1684D Traps</a></h1></blockquote>
</li>
<li>题意： 你的面前有 $n$ 个陷阱，第 $i(i≤n)$ 会对你造成 $a_i$ 点伤害。你可以选择跳过 $k$ 个陷阱来避免伤害，但代价是此后的每一个陷阱的伤害都加 $1$。</li>
<li>思路： 尽可能的通过 $k$ 次跳过陷阱的机会减小受到的伤害，对于每个陷阱 $ x $，跳过它可以直接减小的伤害为 $ a_x $，不过以后的每个没有被跳过的陷阱（共 $ n-x $ 个）所造成的伤害都要增加 $ 1 $ 点，所以跳过陷阱 $ x $ 能减少的伤害为 $ a_x -n+x $ ，然后从大到小排序，把减少伤害大的放在前面这样更优。 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,k;</span><br><span class="line">int w[N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int s=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(k==n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;0\n&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;a;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        w[i]=(w[i]-n+i);</span><br><span class="line">        a.push_back(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a.rbegin(),a.rend());</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;k;i++)s-=a[i];</span><br><span class="line"></span><br><span class="line">    ans=s-k*(k-1)/2;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把最大的变化值放在最前面</p>
<h1 id="739A-Alyona-and-mex"><a href="#739A-Alyona-and-mex" class="headerlink" title="739A Alyona and mex"></a><a href="https://codeforces.com/contest/739/problem/A">739A Alyona and mex</a></h1></blockquote>
<ul>
<li>题意：你有 m 个区间，要求构造一个长度为 n 的序列使得这 m 个区间中 mex 最小的最大（mex 定义为一个区间内没有出现过的最小自然数）。</li>
<li>思路：易知，$mex$ 的最小值与数列的长度有关，每个区间有 $r-l+1$ 个数，很明显，要满足题意，需要寻找每个序列长度的最小值即可，即 $mex= \min(r_i-l_i+1,mex)$，构造序列时循环输出 $0$ 到 $mex-1$。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m;</span><br><span class="line">int l[N],r[N];</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)&#123;</span><br><span class="line">        ans=min(ans,r[i]-l[i]+1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        cout&lt;&lt;i%ans&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>要让每个区间mex最大值最小，那么此时我们就放$r-l+1$ 即可。</p>
</blockquote>
<h1 id="93A-Frames"><a href="#93A-Frames" class="headerlink" title="93A-    Frames"></a><a href="https://codeforces.com/contest/93/problem/A">93A-    Frames</a></h1><ul>
<li>题意：给出 $n$ 个数，一行 $m$ 个，一共排成 $\left\lceil\dfrac{n}{m}\right\rceil$ 行。想给出连续的一些数字 $a \sim b$，求最少用几个矩形方框把它们都框起来。（可以参照Windows的文件管理器的文件夹）</li>
<li>思路：就简单的分类讨论，答案肯定也就只有 <code>1,2,3</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    int xa=(a-1)/m+1;</span><br><span class="line">    int ya=(a-1)%m+1;</span><br><span class="line">    int xb=(b-1)/m+1;</span><br><span class="line">    int yb=(b-1)%m+1;</span><br><span class="line"></span><br><span class="line">    if(xa==xb||(ya==1&amp;&amp;yb==m)||(ya==1&amp;&amp;b==n))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;1&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ya==1||yb==m||xb-xa==1||ya-yb==1||b==n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;2&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;3&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>神奇的分类讨论</p>
</blockquote>
</li>
</ul>
<h1 id="288B-Polo-the-Penguin-and-Houses"><a href="#288B-Polo-the-Penguin-and-Houses" class="headerlink" title="288B-Polo the Penguin and Houses"></a><a href="https://codeforces.com/contest/288/problem/B">288B-Polo the Penguin and Houses</a></h1><ul>
<li>题意：题目给你 $n$ 个点，有给你一个正整数 $k$。使得 $1$∼$k$ 任意一点都可以到达 $1$。$k+1$∼$n$ 的点都不能到 $1$。求满足这种情况的方案数对 $10^9+7$ 取模。</li>
<li>思路：首先手动模拟一下 $1 \rightarrow k$ 的情况。</li>
</ul>
<p>Ⅰ $k=1$,一种方案</p>
<script type="math/tex; mode=display">1→1</script><p>Ⅱ $k=2$，两种方案 </p>
<script type="math/tex; mode=display">1→1,2→1</script><script type="math/tex; mode=display">1→2,2→1</script><p> Ⅲ $k=3$$，九种方案 </p>
<script type="math/tex; mode=display">1→1,2→1,3→1</script><script type="math/tex; mode=display">1→1,2→1,3→2</script><script type="math/tex; mode=display">1→1,2→3,3→1</script><script type="math/tex; mode=display">1→2,2→1,3→1</script><script type="math/tex; mode=display">1→2,2→3,3→1</script><script type="math/tex; mode=display">1→2,2→1,3→2</script><script type="math/tex; mode=display">1→3,2→1,3→1</script><script type="math/tex; mode=display">1→3,2→1,3→2</script><script type="math/tex; mode=display">1→3,2→3,3→1</script><p> 找规律可知，方案数为$k^{k-1}$。<br>然后从 $k+1\rightarrow n$ ，因为任何一点都无法到达 $1$，那么对于每一个数都可以连向 $k+1\rightarrow n$ 的任何一个数，那么种类数也就是 $(n-k)^{n-k}$。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;qmi(m,m-1)%mod*qmi(n-m,n-m)%mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>很好的组合数学，震撼到我了，因为 $1\rightarrow k$ 是可以到达 $1$ 的，所以除 $1$ 以外其他点可以跟 $1 \rightarrow k$ 的任意一个点连接，然后就是剩下的 $k+1 \rightarrow n$ 这些不能跟 $1$ 连，那么就自己连自己，方案数是：$(n-k)^{n-k}$。</p>
</blockquote>
<h1 id="314A-Sereja-and-Contest"><a href="#314A-Sereja-and-Contest" class="headerlink" title="314A-Sereja and Contest"></a><a href="https://codeforces.com/contest/314/problem/A">314A-Sereja and Contest</a></h1><ul>
<li><p>题意：有 $n$ 个人参加了比赛，评分分别为 $a<em>1$，$a_2$，$…$ ，$a_n$ ，这个网站的评分是根据: $d_i=\sum\limits</em>{j=1}^{i-1}(a_j \cdot (j-1)-(n-i) \cdot a_i)$ 计算的。比赛结束后，评分为 $k$ 的将取消评分，并重新更新排行榜。   </p>
</li>
<li><p>思路：其实只用从头到尾进行删除，删除可能改变表中数据，问最后谁会被取消评分。最后更新排行榜，输出参与者的原始编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,k;</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int x=0,rating=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int p;</span><br><span class="line">        cin&gt;&gt;p;</span><br><span class="line">        rating++;</span><br><span class="line">        if(x-(i-1)*(n-i)*p&lt;k)&#123;</span><br><span class="line">            cout&lt;&lt;rating&lt;&lt;endl;</span><br><span class="line">            n--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            x+=p*(i-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给了你公式，叫你模拟一遍，我们就观察公式的特点即可：就比如这道题我们可以把 $d_i$ 前面的那个和提出来，设为 $x_i$，一旦发现 $d_i&lt;k$ 我们就让 $n$ 减小即可。</p>
<h1 id="1975D-Paint-the-Tree"><a href="#1975D-Paint-the-Tree" class="headerlink" title="1975D-Paint the Tree"></a><a href="https://codeforces.com/problemset/problem/1975/D">1975D-Paint the Tree</a></h1></blockquote>
</li>
<li><p>题意：给你一棵白色的树，只有 $a$ 为红色，$b$ 为蓝色，树上有两个棋子 $P_A,P_B$ 分别在节点 $a,b$ 上，在每一单位时间内，进行以下操作：</p>
</li>
<li><ul>
<li>将 $P_A$ 移动到相邻节点 $a’$，若 $a’$ 为白色，则将 $a’$ 变为红色；</li>
</ul>
</li>
<li><ul>
<li>将 $P_B$ 移动到相邻节点 $b’$，若 $b’$ 为红色，则将 $b’$ 变为蓝色。</li>
</ul>
</li>
</ul>
<p>求将整棵树染成蓝色的最短时间。</p>
<ul>
<li><p>思路：我们可以很容易想到把 $P_A$ 和 $P_B$ 集合到一个点，然后一起移动。假设这个集合的点为 $r$。接下来的问题转化成：一个棋子从 $r$ 出发，最少走几步能遍历完所有点。此时我们以 $r$ 为根，由于每条边要走 $2$ 次，即 $2(n-1)$，但是我们可以让棋子走到深度最深的叶子节点后停止，即答案为 $2(n−1)−maxdep_i$ 但是有可能 $P_A$ 和 $P_B$ 不能移动到一个点，该情况发生当且仅当 $a,b$ 路径上边的数量为奇数。不难发现我们可以让这个集合点在靠近 $a$ 的中点处。也就是此时我们要找 $r$，此时这个 $r$ 满足：$r$ 在 $a,b$ 路径上，因为 $a$ 是根，所以该条件即 $r$ 是 $b$ 的父亲，而且 $dep_r=⌈dep_b /2⌉$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;g(n+1);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;dep(n+1,0),f(n+1,0);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        g[b].emplace_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function&lt;void(int,int)&gt; dfs=[&amp;](int u,int fa)&#123;</span><br><span class="line">        dep[u]=dep[fa]+1;</span><br><span class="line">        f[u]=fa;</span><br><span class="line">        for(auto j:g[u])&#123;</span><br><span class="line">            if(j==fa)continue;</span><br><span class="line">            dfs(j,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    dfs(a,0);</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    if(a==b)&#123;</span><br><span class="line">        ans+=2*(n-1)-*max_element(dep.begin()+1,dep.end());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int p=b;</span><br><span class="line"></span><br><span class="line">        while(dep[p]!=(dep[b]+1)/2)p=f[p],ans++;</span><br><span class="line"></span><br><span class="line">        dfs(p,0);</span><br><span class="line">        </span><br><span class="line">        ans+=2*(n-1)-*max_element(dep.begin()+1,dep.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans+1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非常好的一道贪心+树形结构的题目（$P_a 、P_b$ 最好合并），一个指针遍历完整棵树的步数是 $2n-1$，并且我们是走到最深的节点停止（这样能节省步骤）。</p>
</blockquote>
</li>
<li><p><a href="https://codeforces.com/contest/229/problem/A">229A-Shifts</a> </p>
</li>
<li><p>题意：给您一个 $n×m$ 的矩阵，里面有 $0$ 或 $1$。您可以向左或向右移动一行（最后一个数会到最左（右）），问：最少要多少次操作才能够使某一列全部为 $1$？</p>
</li>
<li><p>思路：对于这种循环移动问题，很经常用扩展数组法（也就是开两倍的数组）。但这道题既有往左移也有往右移，因此可以开三倍的数组。又因为 $n,m$ 都比较小，因此可以考虑二分来找离 $i$ 最近的 $1$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dlc(int l,int r,int x,int k)&#123;</span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(g[k][mid]&gt;=x)r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return g[k][r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int tyb(int l,int r,int x,int k)&#123;</span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(g[k][mid]&lt;=x)l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return g[k][l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        bool f=false;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            if(s[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                f=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!f)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            if(s[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                g[i][++cnt[i]]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int pp=cnt[i];</span><br><span class="line">        //左移右移得扩大2倍数</span><br><span class="line">        for(int j=1;j&lt;=pp;j++)&#123;</span><br><span class="line">            g[i][++cnt[i]]=g[i][j]+m;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=pp;j++)&#123;</span><br><span class="line">            g[i][++cnt[i]]=g[i][j]+m+m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int ss=0;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            ss+=min(dlc(0,cnt[j],i+m,j)-i-m,m+i-tyb(0,cnt[j],i+m,j));//dlc左移，tyb右移</span><br><span class="line">        &#125;</span><br><span class="line">        // cout&lt;&lt;ss&lt;&lt;endl;</span><br><span class="line">        ans=min(ans,ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的一道循环左移和右移的题目，这种题目的策略是把数组复制2次，然后操作都在中间的地方进行；这道题还得用二分，左移的时候寻找 大于等于 x 的最小的数，右移的时候寻找小于等于 x 最大的数。</p>
</blockquote>
</li>
</ul>
<h1 id="1500A-Going-Home"><a href="#1500A-Going-Home" class="headerlink" title="1500A-Going Home"></a><a href="https://codeforces.com/contest/1500/problem/A">1500A-Going Home</a></h1><ul>
<li>题意：给定 $n$ 个正整数 $a_1, a_2\cdots, a_n$，求出任意一组 $x\neq y\neq z\neq w$ 使得 $a_x+a_y=a_z+a_w$。</li>
<li>思路：可以直接试试暴力，也就是枚举 $x,y$。因为本道题是这样的 $a_i\le 2.5\times 10^6$，而 $n\le2\times 10^5$，所以说明如果 $n$ 越大，根据<strong>鸽巢原理</strong>，肯定就会越多成对的，因此时间复杂度是 $O(\min(n^2,n+C))$<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            int s=w[i]+w[j];</span><br><span class="line">            if(S[s].x==0||S[s].y==0)&#123;</span><br><span class="line">                S[s]=&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            if(S[s].x!=i&amp;&amp;S[s].y!=j&amp;&amp;S[s].x!=j&amp;&amp;S[s].y!=i)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;S[s].x&lt;&lt;&#x27; &#x27;&lt;&lt;S[s].y&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以直接试试暴力，因为 $2s$ ，有的时候是跑不满的，因为本道题是这样的 $a_i\le 5\times 10^6$，而 $n\le2\times 10^5$，所以说明如果 $n$ 越大，根据<strong>鸽巢原理</strong>，肯定就会越多成对的，因此时间复杂度是 $O(\min(n^2,n+C))$，其中 $C$ 是 $a_i+a_j$ 的值域。注意不能用 map，因为用 map 的话会多一个常数 $\log n$。</p>
</blockquote>
</li>
</ul>
<h1 id="833B-The-Bakery-dp-线段树-贡献法优化"><a href="#833B-The-Bakery-dp-线段树-贡献法优化" class="headerlink" title="833B-The Bakery dp+线段树+贡献法优化"></a><a href="https://codeforces.com/problemset/problem/833/B">833B-The Bakery</a> dp+线段树+贡献法优化</h1><ul>
<li>题意：将一个长度为 $n$ 的序列分为 $k$ 段，使得总价值最大。其中一段区间的价值表示为区间内不同数字的个数。</li>
<li>思路：很容易想到dp，$f<em>{i,j}$ 表示已经遍历好了前 $i$ 个数且序列已经分为了 $j$ 段的最大总价值，$cnt</em>{i,j}$ 表示$i \rightarrow j$ 之间不同的颜色数。$dp[i][j]=\max(dp[k][j-1]+cnt[k+1][i]),i−1≤k≤j−1$，如果直接去暴力做的话，时间复杂度是 $O(n^3k)$ 的，因此得考虑优化，我们发现，如果我们把 dp 方程直接放到线段树中去查询（因为dp方程中的 $i$ 是在一个区间内变动的），那么可以降低到 $O(n^2lognk)$，那怎么维护 $cnt$ 数组呢？我们可以记录 $a<em>i$ 上一次出现的位置 $pos</em>{a<em>i}$，则 $a_i$ 在区间 $[pos</em>{a_i}+1,i-1]$ 的贡献都是 $1$。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,k;</span><br><span class="line">struct E&#123;</span><br><span class="line">    int l,r,v,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;2];</span><br><span class="line">int w[N];</span><br><span class="line">int f[110][N];</span><br><span class="line">int pos[N];</span><br><span class="line">int pre[N];</span><br><span class="line"></span><br><span class="line">void pushup(int u)&#123;</span><br><span class="line">    tr[u].v=max(tr[u&lt;&lt;1].v,tr[u&lt;&lt;1|1].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int u,int x)&#123;</span><br><span class="line">    tr[u].v+=x;</span><br><span class="line">    tr[u].tag+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pushdown(int u)&#123;</span><br><span class="line">    if(tr[u].tag)&#123;</span><br><span class="line">        add(u&lt;&lt;1,tr[u].tag),add(u&lt;&lt;1|1,tr[u].tag);</span><br><span class="line">        tr[u].tag=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int u,int l,int r,int now)&#123;</span><br><span class="line">    tr[u]=&#123;l,r,0,0&#125;;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        tr[u].v=f[now][l-1];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">    build(u&lt;&lt;1,l,mid,now),build(u&lt;&lt;1|1,mid+1,r,now);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(int u,int l,int r,int x)&#123;</span><br><span class="line">    if(tr[u].l&gt;r||tr[u].r&lt;l)return;</span><br><span class="line">    if(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].v+=x;</span><br><span class="line">        tr[u].tag+=x;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pushdown(u);</span><br><span class="line">    update(u&lt;&lt;1,l,r,x);</span><br><span class="line">    update(u&lt;&lt;1|1,l,r,x);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int u,int l,int r)&#123;</span><br><span class="line">    if(tr[u].l&gt;r||tr[u].r&lt;l)return 0;</span><br><span class="line">    if(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)return tr[u].v;</span><br><span class="line"></span><br><span class="line">    pushdown(u);</span><br><span class="line">    return max(query(u&lt;&lt;1,l,r),query(u&lt;&lt;1|1,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        pre[i]=pos[w[i]]+1,pos[w[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">        memset(tr,0,sizeof tr);</span><br><span class="line">        build(1,1,n,i-1);</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            update(1,pre[j],j,1);</span><br><span class="line">            f[i][j]=query(1,1,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[k][n]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一段区间的价值表示为区间内不同数字的个数居然可以这么写 <code>pre[i]=pos[t]+1,pos[t]=i</code></p>
</blockquote>
</li>
</ul>
<h1 id="P8183-USACO22FEB-Sleeping-in-Class-B-因数"><a href="#P8183-USACO22FEB-Sleeping-in-Class-B-因数" class="headerlink" title="P8183 [USACO22FEB] Sleeping in Class B 因数"></a><a href="https://www.luogu.com.cn/problem/P8183">P8183 [USACO22FEB] Sleeping in Class B</a> 因数</h1><ul>
<li>题意：每次合并两个相邻的数，问进行的最少修改次数，以使所有数字相等。</li>
<li>思路：因为你每次合并两个数字的时候，数组的总和是不会发生变化的，那么最后要让所有数字相等，肯定是和的因数，因此我们只需要枚举和的因数就可以了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    s=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],s+=w[i];</span><br><span class="line"></span><br><span class="line">    //和为定值，可以考虑它的因数</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        if(s%i==0)&#123;</span><br><span class="line">            int cur=0;</span><br><span class="line">            bool f=false;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                cur+=w[j];</span><br><span class="line">                if(cur&gt;s/i)&#123;</span><br><span class="line">                    f=true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur==s/i)&#123;</span><br><span class="line">                    cur=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!f)&#123;</span><br><span class="line">                cout&lt;&lt;(n-i)&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一道和为定值的操作问题的好题，对于和为定值，叫我们求方案数最少，我们可以考虑和的因数（对于分段的问题）</p>
</blockquote>
</li>
</ul>
<h1 id="P8474-「GLR-R3」立春-逆序对"><a href="#P8474-「GLR-R3」立春-逆序对" class="headerlink" title="P8474 「GLR-R3」立春 逆序对"></a><a href="https://www.luogu.com.cn/problem/P8474">P8474 「GLR-R3」立春</a> 逆序对</h1><ul>
<li>题意：<br>设 $\sigma$ 为任意一个长度为 $n$ 的排列，$\tau(\sigma)$ 表示其中的逆序对个数，求出</li>
</ul>
<script type="math/tex; mode=display">
\sum_\sigma 2^{\tau(\sigma)}</script><p>对 $(10^9+7)$ 取模的结果。</p>
<ul>
<li>思路：假设我们已经知道长度为 $n-1$ 的排列的答案，记为 $a<em>{n-1}$，对于长度为 $n$ 的排列，我们可以考虑第一个数字的位置。第一个数字可以是 $1$ 到 $n$ 中的任何一个。此时，如果第一个数字是 $k$ 的话，那么它会与后面的 $n-1$ 个数字中的 $k-1$ 个数字形成逆序对，因此第一个数字是 $k$ 时，贡献的逆序对数是 $k-1$，对应的 $2^{\tau(\sigma)}$ 就是 $2^{k-1}\times a</em>{n-1}$，最后将所有的 $k$ 的情况累加起来，得到 $a<em>n=(2^0+2^1+…+2^{n-1})\times a</em>{n-1}$。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int t=1,ans=1;</span><br><span class="line"></span><br><span class="line">    while(n--)&#123; </span><br><span class="line">        t=(t*2)%mod;</span><br><span class="line">        int tmp=(t-1+mod)%mod;</span><br><span class="line">        ans=(ans*tmp)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>结论：对于逆序对的题目，要求任意排列的逆序对的总数，可以值考虑第一位数的值即可。</strong></p>
<h1 id="P8685-蓝桥杯-2019-省-A-外卖店优先级"><a href="#P8685-蓝桥杯-2019-省-A-外卖店优先级" class="headerlink" title="P8685 [蓝桥杯 2019 省 A] 外卖店优先级"></a><a href="https://www.luogu.com.cn/problem/P8685">P8685 [蓝桥杯 2019 省 A] 外卖店优先级</a></h1></blockquote>
</li>
<li>题意：经过 $1$ 个时间单位，若外卖店没订单，优先级减 $1$，否则每接 $1$ 单优先级加 $2$。如果某家外卖店某时刻优先级大于 $5$，则会被系统加入优先缓存中。如果优先级小于等于 $3$，则会被清除出优先缓存。</li>
<li>思路：以每个外卖站点为对象，然后建立小顶堆，在进行判断之前，要先判断此时是否不符合优先缓存，这里一定要先更新判断，然后再加上订单再判断一下是否在优先缓存里。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m,t;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q[N];</span><br><span class="line">bool vis[N];</span><br><span class="line"></span><br><span class="line">void check(int i,int p)&#123;</span><br><span class="line">    if(p&gt;5)vis[i]=1;</span><br><span class="line">    if(p&lt;=3)vis[i]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        q[b].push(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int cur=0,last=0;</span><br><span class="line"></span><br><span class="line">        while(q[i].size())&#123;</span><br><span class="line">            int now=q[i].top();</span><br><span class="line">            q[i].pop();</span><br><span class="line"></span><br><span class="line">            if(!last||last==now)last=now;</span><br><span class="line">            else cur+=(last-now+1),last=now,cur=max(cur,0ll);</span><br><span class="line"></span><br><span class="line">            check(i,cur),cur+=2,check(i,cur);</span><br><span class="line"></span><br><span class="line">            if(!q[i].size())&#123;</span><br><span class="line">                cur+=(now-t);</span><br><span class="line">                check(i,cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>模拟题，一般都以要求的对象出发，如本道题我们可以以外卖站点出发来做，这样能减少思维量。</p>
</blockquote>
<h1 id="P8725-蓝桥杯-2020-省-AB3-画中漂流"><a href="#P8725-蓝桥杯-2020-省-AB3-画中漂流" class="headerlink" title="P8725 [蓝桥杯 2020 省 AB3] 画中漂流"></a><a href="https://www.luogu.com.cn/problem/P8725">P8725 [蓝桥杯 2020 省 AB3] 画中漂流</a></h1><ul>
<li>题意：你下游 $d$ 米处是峡谷，你的体力是 $m$，每向前划一米就要耗费一点体力，水速是一米每秒，你要保证在 $t$ 秒内你要花完所有体力，并且不能掉入峡谷，求方案个数。</li>
<li>思路：因为 $d,m,t$ 都比较小，此时就可以考虑dp，然后我们发现，这很像是 $01$ 背包问题，因为体力可以看作是背包容量，每一秒就是物品的选择。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;d&gt;&gt;t&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    f[0][m]=1;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=t;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            int len=d+(m-j)-(i-(m-j));</span><br><span class="line">            if(len&gt;0)&#123;</span><br><span class="line">                f[i][j]=(f[i-1][j]+f[i-1][j+1])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$d$ 如果本道题使用背包来做的话，会出现 $d$ 不确定的情况。因此得按时间和体力两个变量来确定距离（因为距离可以通过二者求出来的）</p>
</blockquote>
</li>
</ul>
<h1 id="Problem-339-D"><a href="#Problem-339-D" class="headerlink" title="Problem 339 D"></a><a href="https://codeforces.com/problemset/problem/339/D">Problem 339 D</a></h1><ul>
<li>题意：给出一个长度为 $2^n$ 的序列 $a$，并进行 $n$ 次更新操作。</li>
<li><ul>
<li>在第奇数次操作时，将每两个相邻的数 按位或，并将这些得到的值组成的序列代替序列 $a$。</li>
</ul>
</li>
<li><ul>
<li>在第偶数数次操作时，将每两个相邻的数 按位异或，并将这些得到的值组成的序列代替序列 $a$。</li>
</ul>
</li>
</ul>
<p>在 $n$ 次操作后，$a$ 序列中只剩下了一个数，我们称这个数为序列 $a$ 的键值。并且给出 $m$ 个询问，每次询问包含两个数 $p,b$，表示求当 $a_p=b$ （其他数不变）时序列 $a$ 的键值。</p>
<ul>
<li>思路：这个有直接给你公式，此时要查询我们直接用线段树就可以了。此时线段树维护深度 $d$，$d\%2=1$ 时或，$0$ 时异或。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct E&#123;</span><br><span class="line">    int l,r,v,step;</span><br><span class="line">&#125;tr[N&lt;&lt;2];</span><br><span class="line">int n,m;</span><br><span class="line">int w[N];</span><br><span class="line"></span><br><span class="line">void pushup(int u)&#123;</span><br><span class="line">    if(tr[u].step&amp;1)tr[u].v=tr[u&lt;&lt;1].v|tr[u&lt;&lt;1|1].v;</span><br><span class="line">    else tr[u].v=tr[u&lt;&lt;1].v^tr[u&lt;&lt;1|1].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int u,int l,int r,int step)&#123;</span><br><span class="line">    tr[u]=&#123;l,r,0,step&#125;;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        tr[u].v=w[l];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">    build(u&lt;&lt;1,l,mid,step-1),build(u&lt;&lt;1|1,mid+1,r,step-1);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(int u,int p,int x)&#123;</span><br><span class="line">    if(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].v=x;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=tr[u].l+tr[u].r&gt;&gt;1;</span><br><span class="line">    if(p&lt;=mid)update(u&lt;&lt;1,p,x);</span><br><span class="line">    else update(u&lt;&lt;1|1,p,x);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int len=(1ll&lt;&lt;n);</span><br><span class="line">    for(int i=1;i&lt;=len;i++)cin&gt;&gt;w[i];</span><br><span class="line">    build(1,1,len,n);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        update(1,x,y);</span><br><span class="line">        cout&lt;&lt;tr[1].v&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于有通式，而且是单点修改然后查询的话，我们可以用线段树进行操作。（代码453）</p>
</blockquote>
</li>
</ul>
<h1 id="P2072-宗教问题"><a href="#P2072-宗教问题" class="headerlink" title="P2072 宗教问题"></a><a href="https://www.luogu.com.cn/problem/P2072">P2072 宗教问题</a></h1><ul>
<li>题意：现在要按顺序把这N个教徒分成一些集体，每个集体的危险值定义为这个集体中的宗教种数，且一个集体的宗教种类不能超过K种。问： 1.这N个教徒至少要分为几个集体，2.这些集体的危险值总和至少为多少。</li>
<li>思路：由于这里的 $n\le 1000$，然后这道题又是集合的分段问题，可以考虑dp，其实可以更深入考虑就是一个区间dp，$f<em>{i,j}$ 表示在区间 $[i,j]$ 的集体数，$g</em>{i,j}$ 表示在区间 $[i,j]$ 的最小危险数。状态转移：$f<em>{i,j}=\min(f</em>{i,v}+1)，g<em>{i,j}=\min(g</em>{i,v}+val)，u[v+1][j]&lt;=k$， 其中 $u$ 可以预处理，它算的是区间 $[i,j]$ 有多少个不同的宗教数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m,k;</span><br><span class="line">int w[N];</span><br><span class="line">int f[N][N],g[N][N];</span><br><span class="line">bool b[N];</span><br><span class="line">int u[N][N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int l=0;</span><br><span class="line">        for(int j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            if(!b[w[j]])&#123;</span><br><span class="line">                l++,b[w[j]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            u[i][j]=l,f[i][j]=g[i][j]=1e18;</span><br><span class="line">        &#125;        </span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            b[j]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i]=g[i][i]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int l=1;l&lt;=n-1;l++)&#123;</span><br><span class="line">        for(int r=l+1;r&lt;=n;r++)&#123;</span><br><span class="line">            if(u[l][r]&lt;=k)g[l][r]=min(g[l][r],u[l][r]);</span><br><span class="line">            if(u[l][r]&lt;=k)f[l][r]=min(f[l][r],1ll);</span><br><span class="line">            for(int v=l;v&lt;=r;v++)&#123;</span><br><span class="line">                if(u[v+1][r]&lt;=k)&#123;</span><br><span class="line">                    g[l][r]=min(g[l][r],g[l][v]+u[v+1][r]);</span><br><span class="line">                    f[l][r]=min(f[l][r],f[l][v]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[1][n]&lt;&lt;endl&lt;&lt;g[1][n]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的区间dp，非常特殊的区间dp，此时的区间dp是用来解决分段问题。分段问题可以考虑二分、贪心、区间dp等。</p>
</blockquote>
</li>
</ul>
<h1 id="P3848-TJOI2007-跳棋"><a href="#P3848-TJOI2007-跳棋" class="headerlink" title="P3848 [TJOI2007] 跳棋"></a><a href="https://www.luogu.com.cn/problem/P3848">P3848 [TJOI2007] 跳棋</a></h1><ul>
<li>题意：给你一个 $n×n$ 的跳棋棋盘和一个棋子位置。格子为 $0$ 被认为是可以到达的，格子为 $1$ 的则不能，而棋子只能上下左右 $4$ 个方向跳。 能到达的两个格子间不能相邻，即起点和终点最少要隔一格。显然，跳过的格子不能再跳。求最远跳跃总距离。</li>
<li>思路：因为 $n\le 100$，因此可以考虑 dfs。此时需要注意的就是它会一直朝着一个方向走很多步才会到 $0$ 的格子。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,x,y;</span><br><span class="line">int ans;</span><br><span class="line">int w[N][N];</span><br><span class="line">bool vis[N][N];</span><br><span class="line">int dx[]=&#123;-1,0,1,0&#125;,dy[]=&#123;0,1,0,-1&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y,int step)&#123;</span><br><span class="line">    vis[x][y]=true;</span><br><span class="line">    ans=max(ans,step);</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;   </span><br><span class="line">        int tx=x,ty=y,s=0;</span><br><span class="line">        while(tx+dx[i]&gt;0&amp;&amp;tx+dx[i]&lt;=n&amp;&amp;ty+dy[i]&gt;0&amp;&amp;dy[i]+ty&lt;=n)&#123;</span><br><span class="line">            tx+=dx[i];</span><br><span class="line">            ty+=dy[i];</span><br><span class="line">            s++;</span><br><span class="line">            if(!w[tx][ty])break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tx&lt;1||ty&lt;1||tx&gt;n||ty&gt;n||s==1||vis[tx][ty]||w[tx][ty]==1)continue;</span><br><span class="line">        vis[tx][ty]=1;</span><br><span class="line">        dfs(tx,ty,step+s);</span><br><span class="line">        vis[tx][ty]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(x,y,0);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一次性跳到有 $0$ 的地方。</p>
</blockquote>
</li>
</ul>
<h1 id="P1632-点的移动"><a href="#P1632-点的移动" class="headerlink" title="P1632 点的移动"></a><a href="https://www.luogu.com.cn/problem/P1632">P1632 点的移动</a></h1><ul>
<li><p>题意：平面上有 $N$ 个整数坐标点。如果将点 $(x_0,y_0)$ 移动到 $(x_1,y_1)$，则需要的代价为 $|x_0-x_1|+|y_0-y_1|$。求使得 $K(K=1, \cdots ,N)$ 个点在同一位置上最少需要的代价。</p>
</li>
<li><p>思路：我们得知道：给定一个序列 $a$，求一个数 $x$ 使得 $∑∣a_i−x∣$ 最小，那么这个数是序列 $a$ 的中位数，因此我们得维护中位数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].x&gt;&gt;w[i].y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;ans(n+1,1e18);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int p=1;p&lt;=n;p++)&#123;</span><br><span class="line">                a[p]=abs(w[p].x-w[i].x)+abs(w[p].y-w[j].y);</span><br><span class="line">                //至少有一个点在某个方向上不移动是最优的</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sort(a+1,a+1+n);</span><br><span class="line"></span><br><span class="line">            for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                a[i]+=a[i-1];</span><br><span class="line">                ans[i]=min(ans[i],a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中位数问题，得知道的就是把这些数因为 $ansx$ 如果是序列 $x$ 里的数，则<strong>至少</strong>有 $1$ 个点在水平方向上不需要移动。同理，ansy如果是序列y里的数，则<strong>至少</strong>有1个点在竖直方向上不需要移动。用这样的方法可以使代价最小。为什么呢？因为在曼哈顿距离中，<strong>中位数的坐标相当于两个点的坐标延展的交点</strong>。可见图:<img src="https://cdn.luogu.com.cn/upload/pic/32080.png" alt=""> </p>
<p>也就是优点1和优点2是等价的。</p>
</blockquote>
</li>
</ul>
<h1 id="gym103428G-Shinyruo-and-KFC"><a href="#gym103428G-Shinyruo-and-KFC" class="headerlink" title="gym103428G-Shinyruo and KFC"></a><a href="https://codeforces.com/gym/103428/problem/G">gym103428G-Shinyruo and KFC</a></h1><ul>
<li><p>题意：有 $n$ 种东西，第 $i$ 种有 $a_i$​ 个。有若干个相同的袋子，袋子里可以随便放物品，但是不能存在一个袋子里有两个或以上同一种物品的情况。<br>对于 $k=1,2,3…,m$，求当有 $k$ 个袋子，放物品的方案数。</p>
</li>
<li><p>思路：根据高中组合学知识，可以很容易推出答案是：$\Pi<em>{i=1}^{n} C</em>{i}^{a[j]}$，如果直接算的话，肯定会超时，因此我们得优化，我们可以考虑相同的直接用快速幂优化掉，因此我们用 $c$ 数组装个数，然后 $a$ 数组重新放去重后的数值。即把组合数算出来的相同的式子合并成指数式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        c[w[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=(int)(1e5);i++)&#123;</span><br><span class="line">        if(c[i])&#123;</span><br><span class="line">            w[++cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int res=1;</span><br><span class="line">        for(int j=1;j&lt;=cnt;j++)&#123;</span><br><span class="line">            res=(res*qmi(C(i,w[j]),c[w[j]]))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>组合数的好题，因为我们可以直接推出答案是 $\Pi<em>{i=1}^{n} C</em>{i}^{a[j]}$ ，肯定会超时，因此我们得优化，我们可以考虑相同的直接用快速幂优化掉，因此我们用 $c$ 数组装个数，然后 $a$ 数组重新放去重后的数值。</p>
</blockquote>
</li>
</ul>
<h1 id="gym103447I-Power-and-Zero"><a href="#gym103447I-Power-and-Zero" class="headerlink" title="gym103447I-Power and Zero "></a><a href="https://codeforces.com/gym/103447/problem/I">gym103447I-Power and Zero </a></h1><p>位运算好题，我们看到 $2^{i-1}$ 就得想到转化成二进制，但我想到二进制我就不知道怎么做了。</p>
<ul>
<li>题意：给定序列 $A<em>1,A_2 ​ ,⋯,A_n$ ​ ，其元素都是正整数。你需要进行一些操作使得序列中的所有元素都变为零。对于每次操作，你可以指定一个任意长度的序列 $𝐵_1 , 𝐵_2 , ⋯ , 𝐵</em>𝑚 ( 𝐵<em>𝑖 ∈ { 1 , 2 , ⋯ , 𝑛 } )$ ，并分别将 $𝐴</em>{𝐵_𝑖 }$​ 减少 $2^{𝑖− 1}$ 。特别地，给定序列中的一个元素可以在一次操作中被多次减少。确定将给定序列全部变为零所需的最小操作次数。</li>
<li>思路：对于每个操作都是减去 $2^{i-1}$，也就是 <code>1 2 4 8</code>，那么这个就可以想到二进制。可以发现将 $A_n$ 分别求出来每个数的二进制位为 $1$ 的数量每次操作等价为消除下标从 $0$ 开始的连续的 $1$。因此，问题等价为至少多少次操作将这些二进制的 $1$ 消除掉。问题也等价为：将二进制存起来，从高位向低位变成一个不下降序列，此时最低位次数即所需次数。注意： 而为了使得操作次数最少，就要二进制数 $1$ 的个数最少。那么从后往前遍历，如果发现当前位置大于前一个位置了，就匀到前一个位置些（匀出的个数*=2），以保证前一个位置个数 &gt;= 当前位置个数。<a href="https://www.cnblogs.com/kingwz/p/16691149.html#i-power-and-modulo-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%9D%E7%BB%B4%E4%BA%8C%E5%88%86">参考解题</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;bit(65,0);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        for(int j=0;j&lt;=63;j++)&#123;</span><br><span class="line">            if((w[i]&gt;&gt;j)&amp;1)&#123;</span><br><span class="line">                bit[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto check=[&amp;]()&#123;</span><br><span class="line">        for(int i=0;i&lt;=63;i++)&#123;</span><br><span class="line">            if(bit[i]&lt;bit[i+1])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    while(!check())&#123;</span><br><span class="line">        for(int i=63;i&gt;=1;i--)&#123;</span><br><span class="line">            if(bit[i]&gt;bit[i-1])&#123;</span><br><span class="line">                bit[i]--,bit[i-1]+=2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;bit[0]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>看了解题知道，这道题就是得把每一位分类，因为那个 $B$ 数组就是给定一个顺序。因为位数高的会被删掉，且操作次数不会比低位的多。直接暴力就可以过。位数越高的删掉肯定会比低位来的更优。 $cnt<em>0≥cnt_1≥⋯≥cnt</em>{32}$ 这种最优。</p>
</blockquote>
<h1 id="NC1004-tokitsukaze-and-Soldier"><a href="#NC1004-tokitsukaze-and-Soldier" class="headerlink" title="NC1004-tokitsukaze and Soldier"></a><a href="https://ac.nowcoder.com/acm/contest/22904/1004">NC1004-tokitsukaze and Soldier</a></h1><ul>
<li>题意：已知第 $i$ 个士兵的战力为 $v[i]$，团的战力是团内所有士兵的战力之和。但是这些士兵有特殊的要求：如果选了第 $i$ 个士兵，这个士兵希望团的人数不超过 $s[i]$。(如果不选第 $i$ 个士兵，就没有这个限制。)问：团的战力最大为多少。</li>
<li>思路：贪心策略：肯定是选越多士兵越好然后士兵的战斗力越强越好。因此我们可以先将士兵按照 $s$ 从大到小排序，然后按照这个顺序依次选取士兵，这样一来我们就能够选取更多的士兵。但是选取到后面的时候我们需要将剔除掉部分士兵，选择战力小的士兵依次剔除即可（这里用堆来实现）。（有点反悔贪心的感觉，因为这里是两个变量，很经常要反悔）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        w.push_back(&#123;y,x&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(w.begin(),w.end(),greater&lt;PII&gt;());</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    int ans=0,sum=0;</span><br><span class="line"></span><br><span class="line">    for(auto [s,v]:w)&#123;</span><br><span class="line">        q.push(v);</span><br><span class="line">        sum+=v;</span><br><span class="line">        while(q.size()&gt;s)&#123;</span><br><span class="line">            sum-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>贪心用堆实现的好题。</p>
</blockquote>
</li>
</ul>
<h1 id="C-Forsaken喜欢数论-HH"><a href="#C-Forsaken喜欢数论-HH" class="headerlink" title="C-Forsaken喜欢数论_HH"></a><a href="https://ac.nowcoder.com/acm/contest/95570/C">C-Forsaken喜欢数论_HH</a></h1><ul>
<li><p>题意： 对于任意一个数 $x$，$f(x)$ 会返回 $x$ 的最小质因子。如果这个数没有最小质因子，那么就返回 $0$。现在给定任意一个 $n$，问想知道 $∑_{i=1}^{n}f(i)$的值。</p>
</li>
<li><p>思路：这个就是最小的因数和，又因为<strong>线性筛本身即是用最小质因子筛质数，因此只需要在中间记录最小质因子即可</strong>。为了加速计算，我们可以在线性筛的时候把因数累加即可，<strong>这种性质可以使得我们可以线性求出积性函数的值</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init(int x)&#123;</span><br><span class="line">    for(int i=2;i&lt;=x;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            primes[cnt++]=i;</span><br><span class="line">            ans+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;i*primes[j]&lt;=x;j++)&#123;</span><br><span class="line">            vis[i*primes[j]]=true;</span><br><span class="line">            ans+=primes[j];</span><br><span class="line">            if(i%primes[j]==0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check(int x)&#123;</span><br><span class="line">    for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">        if(x%primes[i]==0)&#123;</span><br><span class="line">            return primes[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    init(n);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的求最小因数和，就是在线性筛的时候进行累加即可。</p>
</li>
</ul>
<h1 id="P9236-蓝桥杯-2023-省-A-异或和之和"><a href="#P9236-蓝桥杯-2023-省-A-异或和之和" class="headerlink" title="P9236 [蓝桥杯 2023 省 A] 异或和之和"></a><a href="https://www.luogu.com.cn/problem/P9236">P9236 [蓝桥杯 2023 省 A] 异或和之和</a></h1><ul>
<li>题意：算 <script type="math/tex">\sum_{l=1}^{n}\sum_{r=l}^{n}f(l,r)</script>其中 $f(l,r)=a<em>l\oplus a</em>{l+1}\oplus ….a_r$。</li>
<li>思路：类似 <a href="">1879D-Sum of XOR Functions</a> 这道题。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        pre[i]=pre[i-1]^x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=20;j&gt;=0;j--)&#123;</span><br><span class="line">            w[j][(pre[i]&gt;&gt;j)&amp;1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=20;i++)&#123;</span><br><span class="line">        ans+=w[i][0]*w[i][1]*(1ll&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种我们可以先前缀和优化下，但即便这样，还是会超时，因此我们把二进制拆位，算每个的贡献，对于每一个 $p<em>i$，我们将其按位拆分，并将结果存入计数数组 $w</em>{i,j}$ 中。其中 $i$ 表示第 $i$ 个二进制位，$j$ 表示这一位上为 $j$（只能为 $0$ 或 $1$），$w<em>{i,j}$ 表示在所有数中，第 $i$ 个二进制位上为 $j$ 的有 $w</em>{i,j}$ 个。由于这些数中必定两两异或，所以可以直接用乘法原理，求出该位最终为 $1$ 的个数，最后乘上该位的权值就可以了。所以最后的答案为：（公式中 $i$ 的范围上界到 $20$ 是因为题目中说 $A<em>i\le2^{20}$，最多只有 $21$ 个二进制位）$$\sum</em>{i=0}^{20}w<em>{i,0}\times w</em>{i,1}\times 2^i$$</p>
</blockquote>
</li>
</ul>
<h1 id="众数"><a href="#众数" class="headerlink" title="众数"></a><a href="https://www.luogu.com.cn/problem/P9460">众数</a></h1><ul>
<li>题意：给定一个长度为 $n$ 的序列 $a$，修改 $k$ 次，求其所有可能的众数的数量。</li>
<li>思路：这里有个贪心策略：我们每次可以把一个数替换为另外一个数。比如我们要把 $a$ 序列的众数变为 $q$，我们可以每次把序列 $a$ 中的众数中的一个改成 $q$。因而我们可以想到使用优先队列来维护，每次维护 $a$ 中每个数字出现最多的数量。当开始操作时，将这个数字改成想要的数字，所以这个数字的出现次数会减少 $1$。我们把原来的数字弹出优先队列，修改后再弹入优先队列。那么到最后，我们得到的优先队列的顶部元素就是：如果 $q$ 想成为众数，则它修改 $k$ 次后在 $a$ 中至少出现的次数，我们将这个次数称为 $x$，也就是它在修改前在 $a$ 中至少出现 $x−k$ 次。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;int&gt;q;</span><br><span class="line"></span><br><span class="line">    for(auto [a,b]:S)&#123;</span><br><span class="line">        q.push(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">        int t=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        q.push(t-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t=q.top()-k;</span><br><span class="line">    int m=q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    if(k&gt;=m)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;pigstd&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto [a,b]:S)&#123;</span><br><span class="line">        if(b&gt;=t)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>堆来维护每个数出现的个数，因为每一次改变我们肯定是把出现最多数的数减 $1$，然后我们直接执行 $k$ 次操作，最后看出现最多的个数是多少，如果比我们的 $k$ 小的话，说明可以变成很多数，因此答案是无限。反之的话，我们得到的优先队列的顶部元素就是如果 $q$ 想成为众数，则它修改 $k$ 次后在 $a$ 中至少出现的次数，我们将这个次数称为 $x$，也就是它在修改前在 $a$ 中至少出现 $x - k$ 次。</p>
</blockquote>
</li>
</ul>
<h1 id="USACO20JANBerry-Picking-S"><a href="#USACO20JANBerry-Picking-S" class="headerlink" title="USACO20JANBerry Picking S "></a><a href="https://www.luogu.com.cn/problem/P6002">USACO20JANBerry Picking S </a></h1><ul>
<li>题意：给定 $n$ 颗树，分别有 $a_i$ 个果子，求选出 $m$ 篮果子使得最少的 $m/2$ 篮最多，要求每篮的果子都必须来自同一棵树。</li>
<li>思路：题目要求的是求较小的 $K / 2 $ 的最大值。那么我们可以设较小的 $K / 2 $ 中最大的篮子装了 $v$ 个。在前 $K / 2$ 中，果子的数量就要尽可能地小，最小为 $v$。在后 $K / 2$ 中，果子的数量就要尽可能地大，最大也为 $v$。那么就可以直接先分前 $K / 2$ ，每个篮子 $v$ 个。如果分不了，就直接无解。再去计算后 $K / 2$ ，每个篮子 $v$ 个，剩下的篮子继续装当前剩下的中最大的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    k&gt;&gt;=1ll;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line">    //前k个篮子取小的，后面k个取大的</span><br><span class="line">    for(int i=1;;i++)&#123;</span><br><span class="line">        int t=0;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;// 计算采满i的篮子数</span><br><span class="line">            t+=w[j]/i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t&lt;k)break;</span><br><span class="line">        t=min(t-k,k);// 多出的篮子</span><br><span class="line"></span><br><span class="line">        sort(w+1,w+1+n,[&amp;](int a,int b)&#123;</span><br><span class="line">            return a%i&gt;b%i;// 按照剩下的数量排序</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int v=t*i;// 采满篮子的总量</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=min(n,k-t);j++)&#123;// 采够k个篮子</span><br><span class="line">            v+=w[j]%i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的贪心，题目说 $K/2$ 的要给她，因此我们取的时候前 $K/2$ 取少点，后面取多点。</p>
</blockquote>
</li>
</ul>
<h1 id="P5199-USACO19JAN-Mountain-View-S"><a href="#P5199-USACO19JAN-Mountain-View-S" class="headerlink" title="P5199 [USACO19JAN] Mountain View S"></a><a href="https://www.luogu.com.cn/problem/P5199">P5199 [USACO19JAN] Mountain View S</a></h1><ul>
<li>题意：给定 $n$ 个等腰直角三角形的直角顶点坐标，求能看见多少个直角三角形（即求被覆盖了多少三角形，然后用 $n$ 去减）。</li>
<li>思路：注意到等腰三角形，那么等腰三角形能覆盖到的范围是 $[x_i-y_i,x_i+y_i]$。此时需要注意的是，<strong>本道题可能会出现一个山峰完全覆盖掉另一个山峰</strong>，此时就不能更新答案。所有说肯定得先按左端点排个序，然后当左端点相同的时候，按右端点降序排列。</li>
</ul>
<blockquote>
<p>为什么是降序呢？</p>
<p>答：因为当左端点相同的时候，矮的会被高的覆盖掉。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct E&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator&lt;(const E&amp; t)const&#123;</span><br><span class="line">        if(l==t.l)return r&gt;t.r;</span><br><span class="line">        return l&lt;t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line">int x[N],y[N];</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">        e[i]=&#123;x[i]-y[i],x[i]+y[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(e+1,e+1+n);</span><br><span class="line"></span><br><span class="line">    int ans=0,last=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(last&lt;e[i].r)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            last=e[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意，本道题可能会出现一个山峰完全覆盖掉另一个山峰，此时就不能更新答案。所有说肯定得先按左端点排个序，然后当左端点相同的时候，按右端点降序排列。为什么是降序呢？因为当左端点相同的时候，矮的会被高的覆盖掉。</p>
</blockquote>
<h1 id="P2678-NOIP-2015-提高组-跳石头"><a href="#P2678-NOIP-2015-提高组-跳石头" class="headerlink" title="P2678 [NOIP 2015 提高组] 跳石头"></a><a href="https://www.luogu.com.cn/problem/P2678">P2678 [NOIP 2015 提高组] 跳石头</a></h1><ul>
<li>题意：给你 $n$ 个石头，此时你站在坐标为 $0$ 的位置。现在会移走 $m$ 个石头，问最短跳跃距离的最大值。</li>
<li>思路：很典型的二分答案。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool check(int x)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt=0,now=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(w[i]-w[now]&lt;x)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;else now=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnt&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;L&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    w[++n]=L+1;</span><br><span class="line"></span><br><span class="line">    int l=0,r=L+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>好的二分答案的题，因为得考虑后效性，也就是会出现相邻多项的时候仍不满足大于给定答案，此时就得一直删，但如果我们只考虑相邻两项的话，很可能会多删（因为很有可能出现的情况是：相邻两项很小，但之前已经被移除了，所以下次就不要再移除了）</p>
</blockquote>
</li>
</ul>
<h1 id="P4090-USACO17DEC-Greedy-Gift-Takers-P"><a href="#P4090-USACO17DEC-Greedy-Gift-Takers-P" class="headerlink" title="P4090 [USACO17DEC] Greedy Gift Takers P"></a><a href="https://www.luogu.com.cn/problem/P4090">P4090 [USACO17DEC] Greedy Gift Takers P</a></h1><ul>
<li>题意：给你一个队列，第一个牛插到从队尾数第 $c_i+1$ 的位置。求不动的牛有多少个。</li>
<li>思路：二分能动的奶牛的分界线（因为能动奶牛比较好维护），我们会发现在分界线以外的奶牛一定会动，即序列可以分成两段一段循环另一段是完全不动的。首先我们要查找的范围就是这个队列的长度，所以去循环就可以了。这里也是要特判一下，因为如果这头牛在队首的话，那它就一定是拿得到礼物的。接下来就把拿不到的牛算出来，即总数减拿得到的牛。每次查完一头牛的情况之后就从下一头牛开始枚举，这里枚举的是在二分循环之外的牛，如果一旦找到这个牛，那么不论循环多少次，它都拿不到礼物，直接排除，那么后面的牛就往前进一位。也就是某个数如果小于该循环的位置，那么它永远也拿不了礼物。注意：check函数里面的x是可以移动的奶牛。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=1;i&lt;x;i++)b[i]=w[i];</span><br><span class="line">    sort(b+1,b+x);</span><br><span class="line"></span><br><span class="line">    int lim=n-x;</span><br><span class="line">    //序列分成两段，一段是循环，一段是完全不动的</span><br><span class="line">    for(int i=1;i&lt;x;i++)&#123;</span><br><span class="line">        if(b[i]&gt;lim)&#123;//有排在外面的就轮不到它了</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        lim++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    int l=0,r=n+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;n-l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的二分题，这个二分答案是二分位置，也就是不满足条件的分界线。首先我们要查找的范围就是这个队列的长度，所以去循环就可以了。这里也是要特判一下，因为如果这头牛在队首的话，那它就一定是拿得到礼物的。接下来就把拿不到的牛算出来，即总数减拿得到的牛。每次查完一头牛的情况之后就从下一头牛开始枚举，这里枚举的是在二分循环之外的牛，如果一旦找到这个牛，那么不论循环多少次，它都拿不到礼物，直接排除，那么后面的牛就往前进一位。也就是某个数如果小于该循环的位置，那么它永远也拿不了礼物。</p>
</blockquote>
</li>
</ul>
<h1 id="括号序列匹配"><a href="#括号序列匹配" class="headerlink" title="括号序列匹配"></a><a href="https://codeforces.com/problemset/problem/380/C">括号序列匹配</a></h1><ul>
<li>题意：每次询问一个区间的最大合法括号子序列长度。</li>
<li>思路：一般遇到合法括号序列，很多时候可以直接转化：<strong>每个左括号视为 $1$，右括号视为 $−1$。合法的序列中每个前缀和不为负数，且以 $0$ 结束</strong>。所以对于一段前缀和，先考虑是否存在负数，如果存在，就去掉相应数量的右括号。不以 $0$ 结束，就去掉相应数量的左括号。因为题目要求最大值，那么我们删除的部分要最小，那么这部分可以直接用st表求最小值来维护。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int j=0;j&lt;=20;j++)&#123;</span><br><span class="line">        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;</span><br><span class="line">            if(!j)f[i][j]=w[i];</span><br><span class="line">            else f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ask(int l,int r)&#123;</span><br><span class="line">    int len=log(r-l+1);</span><br><span class="line"></span><br><span class="line">    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;q;</span><br><span class="line">    n=s.size();</span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;)w[i]=w[i-1]+1;</span><br><span class="line">        else w[i]=w[i-1]-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        int p=r-l+1;</span><br><span class="line">        int t=ask(l,r);</span><br><span class="line">        cout&lt;&lt;p-abs(w[r]-t)-abs(w[l-1]-t)&lt;&lt;endl;//一个是删左括号，一个是删右括号</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于括号序列，我们常用 $+1$ 来表示左括号，右括号则 $-1$，那么只要匹配好了答案就是 $0$，本道题要求我们求子序列，那么我们先对右括号进行操作，如果右括号多我们就删掉（此时右括号就得看 $l-1$ 内的左括号），然后如果左括号多我们就删掉左括号。</p>
</blockquote>
</li>
</ul>
<h1 id="CF448D-Multiplication-Table"><a href="#CF448D-Multiplication-Table" class="headerlink" title="CF448D Multiplication Table"></a><a href="https://codeforces.com/problemset/problem/448/D">CF448D Multiplication Table</a></h1><ul>
<li>题意：给出n,m,k，请输出在n*m的乘法表中第k小的数。</li>
<li>思路：求第 $k$ 小有时候可以考虑二分，即二分一个数，看这个数是不是第 $k$ 大的即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cnt+=min(m,x/i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnt&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int l=0,r=n*m+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的二分题，二分某个数，看某个数前面的数有没有 $k$ 个。</p>
</blockquote>
</li>
</ul>
<h1 id="Problem-1247D-Codeforces"><a href="#Problem-1247D-Codeforces" class="headerlink" title="Problem - 1247D - Codeforces"></a><a href="https://codeforces.com/problemset/problem/1247/D">Problem - 1247D - Codeforces</a></h1><ul>
<li>题意：找 $a_i\times a_j=x^k$ 的数量。</li>
<li>思路：它们的值是 $x^k$，那么对于能乘出他们的数来说，它们的质因子的质数个数必然是 $k$ 的倍数。此时把他们两个分解成 $P_1^{x_1}+P_1^{x_1}…$ 的形式，然后我们只需要分析指数即可。显然意味着每一个质因数的指数和要是 $k$ 的倍数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int t[N];</span><br><span class="line">int p;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    map&lt;vector&lt;PII&gt;,int&gt;S;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int t=w[i];</span><br><span class="line">        vector&lt;PII&gt;a,b;</span><br><span class="line">        for(int j=2;j&lt;=t/j;j++)&#123;</span><br><span class="line">            int s=0;</span><br><span class="line">            while(t%j==0)&#123;</span><br><span class="line">                s++;</span><br><span class="line">                t/=j;</span><br><span class="line">                s%=k;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!s)continue;</span><br><span class="line">            a.push_back(&#123;j,s&#125;);</span><br><span class="line">            b.push_back(&#123;j,k-s&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(t&gt;1)&#123;</span><br><span class="line">            a.push_back(&#123;t,1&#125;);</span><br><span class="line">            b.push_back(&#123;t,k-1&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=S[b];</span><br><span class="line">        S[a]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的最小分解定理的题目，你要让 $A\times B=x^k$ ，那么把他们两个分解成 $P_1^{x_1}+P_1^{x_1}…$ 的形式，然后我们只需要分析指数即可。显然意味着每一个质因数的指数和要是 $k$ 的倍数，所以我们用 <code>map&lt;vector&lt;PII&gt;,int&gt;</code> 来维护重复出现的次数。</p>
</blockquote>
</li>
</ul>
<h1 id="P8782-蓝桥杯-2022-省-B-X-进制减法"><a href="#P8782-蓝桥杯-2022-省-B-X-进制减法" class="headerlink" title="P8782 [蓝桥杯 2022 省 B] X 进制减法"></a><a href="https://www.luogu.com.cn/problem/P8782">P8782 [蓝桥杯 2022 省 B] X 进制减法</a></h1><ul>
<li>题意：给你 $2$ 个同一进制规则的 $X$ 进制数 $A,B$，但是其具体每一数位的进制还不确定，试求出 $A−B$ 的最小值。</li>
<li>思路：题目保证 $A≥B$，所以想要 $A−B$ 的值尽量小，每一位的权值也得尽量小，因为如果让 $B$ 变大，$A$ 就会比 $B$ 变大得更快，从而让 $A−B$ 的值变得更大。那么，如果想让每一位的权值尽量小，每一位的进制也得尽量小，因为每一位的权值是和它低的位的进制有关系的，把每一位的进制减小，那么它的高位的权值也会变小。所以本题的贪心策略就是每一位取最小的进制值。所以对应到代码就是 <code>max(a[i],b[i])+1</code>。</li>
</ul>
<blockquote>
<p>为什么是 <code>max(a[i],b[i])+1</code>？</p>
<p>答：因为进制数越小越好，因此只取它们两个的最大值即可。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;m1;</span><br><span class="line"></span><br><span class="line">    for(int i=m1;i&gt;=1;i--)cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;m2;</span><br><span class="line">    for(int i=m2;i&gt;=1;i--)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    for(int i=max(m1,m2);i;i--)&#123;</span><br><span class="line">        c[i]=max(a[i],b[i])+1;</span><br><span class="line">        c[i]=(c[i]&gt;2)?c[i]:2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=max(m1,m2);i++)&#123;</span><br><span class="line">        d[i]=(d[i-1]*c[i-1])%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans1=0,ans2=0;</span><br><span class="line"></span><br><span class="line">    for(int i=m1;i;i--)&#123;</span><br><span class="line">        (ans1+=a[i]*d[i]%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=m2;i;i--)&#123;</span><br><span class="line">        (ans2+=b[i]*d[i]%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(ans1-ans2+mod)%mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的进制考法，具体思路就是：我们得发现：$321=3\times 10\times 2+2\times 1+1$。</p>
</blockquote>
<h1 id="P6278-USACO20OPEN-Haircut-G"><a href="#P6278-USACO20OPEN-Haircut-G" class="headerlink" title="P6278 [USACO20OPEN] Haircut G"></a><a href="https://www.luogu.com.cn/problem/P6278">P6278 [USACO20OPEN] Haircut G</a></h1><ul>
<li>题意：有一个序列，长度为 $n$，且 $1 ≤ A[i] ≤ n$， 现在要求把大于 $j(j ≤ 0 &lt; n)$ 的 $A[i]$ 变为 $j$ 后有几个逆序对，每行输出一个。</li>
<li>思路：可以考虑在剪头发时，哪些逆序对会留下来，哪些逆序对会消失，易得：<br>（假设有一个逆序对 $(i,j)$,$k$ 表示目前减到的长度）当 $A<em>j\lt k$ 时，此时 $A_i$ 仍然大于 $A_j$，逆序对 $(i,j)$ 可以留下来。当 $A_j\ge k$ 时，此时 $A_i=A_j$，逆序对 $(i,j)$ 会消失。那么每当 $k$ 下降 $1$，所有 $A_j=k$ 的逆序对 $(i,j)$ 都会消失。我们可以开一个 $cnt$ 数组，$cnt_k$ 记录上述值。容易想到在树状数组求逆序对时进行维护（注意此时已经求出来了以当前位置结尾的逆序对个数），设当前位置为 $j$，逆序对个数为 $x$，则 $cnt</em>{Aj}+=x$。最后依次输出 $cnt$ 的前缀和即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int x,int c)&#123;</span><br><span class="line">    for(int i=x;i&lt;N;i+=lowbit(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ask(int x)&#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=x;i;i-=lowbit(i))res+=tr[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        w[i]++;</span><br><span class="line">        t[w[i]]+=i-1-ask(w[i]);</span><br><span class="line">        add(w[i],1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        ans+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的用树状数组求解逆序对的方法。我们用的是贡献法，就是可以考虑在剪头发时，哪些逆序对会留下来，哪些逆序对会消失。当 $A_j&lt;k$ 的时候，如果仍然满足逆序对的要求的话，那么此时的逆序对就得算上，反之逆序对就要减小。因此我们知道：那么每当 $k$ 下降 $1$，所有 $A_j=k$ 的逆序对 $(i,j)$ 都会消失，而且当头发长度为 $A_i$ 时逆序对的数量 = 到 $A_i$ 之前的逆序对数量 + 这个数所能贡献的逆序对的数量。</p>
</blockquote>
<h1 id="P6146-USACO20FEB-Help-Yourself-G"><a href="#P6146-USACO20FEB-Help-Yourself-G" class="headerlink" title="P6146 [USACO20FEB] Help Yourself G"></a><a href="https://www.luogu.com.cn/problem/P6146">P6146 [USACO20FEB] Help Yourself G</a></h1><ul>
<li>题意：给定 $n$ 条线段 $[l_i,r_i ]$，每次对于一条线段可以选或不选，求形成的 $2^n$ 种选择情况形成的连通块个数之和。</li>
<li>思路：为了方便计算，先按照 $l<em>i$ 升序排序。由于每条线段可选和不选，又因为数据规模不大，因此可以考虑dp。设 $f_i$ 为截止到第 $i$ 条边的答案。状态转移：不选第 $i$ 条线段，为 $f</em>{i-1}$。选第 $i$ 条线段。如果有前面的线段 $[l<em>i,r_i]$ 满足 $l_i \le r_j \le r_i$，那么它们将合并为同一线段，不会产生新的联通块。又因为此时我们对 $l_i$ 升序排序，所以计算有多少个线段 $[l_j,r_j]$ 满足，只需要 $r_j&lt;l_i$。暴力时间复杂度高，因此考虑桶排序的方式优化，定义 $cnt[i]$ 为有多少个满足 $r_j&lt;l_i$ 的线段，那么这条线段对答案的贡献为 $f</em>{i-1}+2^{cnt[i]}$。这个 $cnt[i]$ 可以搞成一个通排记录 $r_i$ 个数的前缀和。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct E&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator&lt;(const E&amp; t)const&#123;</span><br><span class="line">        return l&lt;t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        w[i]=&#123;l,r&#125;;</span><br><span class="line">        s[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=2*n;i++)s[i]+=s[i-1];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        (f[i]+=2*f[i-1]%mod+qmi(2,s[w[i].l-1])%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子集选取问题，我们可以用dp来写，就是对于每个线段，可选可不选，如果选的话，则要算上贡献，反之不要。因此得看每个区间跟上个区间是否有交集，我们可以用 $s$ 数组来存储所有右端点的个数。</p>
</blockquote>
</li>
</ul>
<h1 id="P6154"><a href="#P6154" class="headerlink" title="P6154"></a><a href="https://www.luogu.com.cn/problem/P6154">P6154</a></h1><ul>
<li>题意：给定一个有向无环图，求其中一条路径长度的期望。一条路径长度的期望 $=\frac{sum}{cnt}$。其中 $sum$ 代表所有路径长度的总和， $cnt$ 代表路径的个数。</li>
<li>思路：令 $f<em>i$ 表示从 $i$ 开始的路径长度和， $g_i$ 表示从 $i$ 开始的路径条数。则 $f_i=\sum\limits</em>{edge(i,j)}f<em>j+g_j$，$g_i=1+\sum\limits</em>{edge(i,j)}g_j$ ，那么此时的答案即为 $\dfrac{\sum f_i}{\sum g_i}$。这里我们采取的是拓扑排序，因为考虑 $DAG$ 中的一个点 $x$，定义一个点 from，那么根据 $DAG$ 的定义，$x$ 无法回到 from，也就是说，from对 $x$ 有影响， $x$ 对 from 无影响。</li>
</ul>
<blockquote>
<p>疑问：为什么状态转移是那样的？</p>
<p>答：很好理解，即 $j$ 到 $i$ 有边时，$f_i$ 为所有以 $j$ 为结尾的路径长度上均加上 $1$。而这样的路径有 $g _j$ 条，所以总的就是 $f_j+g_j$。至于边界值，显然 $∀i∈G,g_i=1$，因为每个点的路径条数至少为 $1$。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m;</span><br><span class="line">vector&lt;int&gt;g[N];</span><br><span class="line">int f[N],p[N];//f表示以节点i为结尾的总路径长度，p表示以节点i为结尾的路径个数</span><br><span class="line">int din[N];</span><br><span class="line"></span><br><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void topsort()&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!din[i])q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        for(auto&amp; j:g[t])&#123;</span><br><span class="line">            --din[j];</span><br><span class="line">            if(din[j]==0)&#123;</span><br><span class="line">                q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">            (f[j]+=(f[t]+p[t]))%=mod;</span><br><span class="line">            (p[j]+=p[t])%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        din[b]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topsort();</span><br><span class="line"></span><br><span class="line">    int ans1=0,ans2=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)(ans1+=f[i])%=mod;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)(ans2+=p[i])%=mod;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans1*qmi(ans2,mod-2)%mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很好的一道数学期望题，我们发现：所以选择的路径都是等概率的，因此对于等概率的，它的期望是： $\frac{路径长度}{路径总个数}$ ，那么本道题就是这样的求的。具体的状态转移内容可以看<a href="https://www.luogu.com.cn/article/m4npggjj">文章</a>。</p>
</blockquote>
<h1 id="指纹锁"><a href="#指纹锁" class="headerlink" title="指纹锁"></a><a href="https://ac.nowcoder.com/acm/contest/19850/L">指纹锁</a></h1><blockquote>
<p>很好的一道 STL 的题目，我们可以对set的排序进行自定义，具体的写法如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator()(const int&amp; a,const int&amp; b)const&#123;</span><br><span class="line">        if(labs(a-b)&lt;=k)return false;</span><br><span class="line">        return a&lt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;int,cmp&gt;S;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思就是：如果差值小于 $k$ 的话，就弹出，反之的话按从小到大排序。</p>
<h1 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a><a href="https://ac.nowcoder.com/acm/contest/19851/1001">四舍五入</a></h1><blockquote>
<p>这里要注意一下，如果我们对 <code>string</code> 类型进行操作取那个 <code>\0</code> 的操作的话，我们就得用 c 语言的输出方式输出，怎么输出呢？用转换器：<code>s.c_str()</code>。还有就是 <code>resize</code> 的用法，如果 <code>resize</code> 里面的 $n$ 小于本来的长度，前面 $n$ 元素是会 <strong>保留</strong> 的，如果其他元素在它的外面，就会被删掉。还有就是 <code>s.npos</code> 的用法，其实它指的是 <code>string</code> 中不存在位置的位置（是个常量）。</p>
</blockquote>
<h1 id="强迫症的序列"><a href="#强迫症的序列" class="headerlink" title="强迫症的序列"></a><a href="https://ac.nowcoder.com/acm/contest/19851/1022">强迫症的序列</a></h1><blockquote>
<p>题目说对 $n-1$ 加 $1$，那么我们可以对 $1$ 个数减 $1$。</p>
<h1 id="兔子的逆序对"><a href="#兔子的逆序对" class="headerlink" title="兔子的逆序对"></a><a href="https://ac.nowcoder.com/acm/contest/21763/1008">兔子的逆序对</a></h1><p>很好的一道逆序对的题目，我们采用的是用树状数组求逆序对的方式：<code>add(w[i],1),ans+=i-query(w[i])</code> 即可。拓展结论：假设有一个长度为 $m$ 的序列，它的逆序对的个数是 $x$，经过翻转，它的逆序对数是 $\frac{(r-l+1)(r-l)}{2}-x$。为什么是这样的呢？因为在翻转的过程中，正序变成逆序，逆序变成正序，由于没有想要的数，容易发现：$x+顺序对的个数=总对数$。或者也可以：交换偶数次，奇偶性不变； 交换奇数次，奇变偶，偶变奇； 翻转$[l,r]$，需要交换$(r−l+1)/2$次。</p>
<h1 id="P8898-USACO22DEC-Feeding-the-Cows-B"><a href="#P8898-USACO22DEC-Feeding-the-Cows-B" class="headerlink" title="P8898 [USACO22DEC] Feeding the Cows B"></a><a href="https://www.luogu.com.cn/problem/P8898">P8898 [USACO22DEC] Feeding the Cows B</a></h1><ul>
<li>题意：选出最少的草地，使得所有同品种的奶牛离这些草地的任意一个距离不超过 $k$，并输出方案。</li>
<li>思路：要让更多奶牛吃草，肯定在第 $i$ 个奶牛的时候尽量后放到最后一个力所能及的位置，即放到 $i+k$ 的位置，如果 $i+k&gt;n$，那么放在第 $n$ 个位置，因为所有 $i$ 互不相同，所以除非放在第 $n$ 块草坪，否则没有冲突，如果冲突，就每次判断略前的位置，一直到一个未冲突的位置。由于往后放，所以放过一次之后 $i$ 必须直接跳到 $i+2×k$。（此时还有一个策略就是尽可能先满足其中一头牛了之后再满足另外一头牛）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    string ans,s;</span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    if(!k)&#123;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans.resize(n,&#x27;.&#x27;);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;G&#x27;)&#123;</span><br><span class="line">            ans[min(i+k,n-1)]=&#x27;G&#x27;;</span><br><span class="line">            i+=2*k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;H&#x27;)&#123;</span><br><span class="line">            if(i+k&lt;n-1)&#123;</span><br><span class="line">                ans[i+k]=&#x27;H&#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                for(int j=n-1;j&gt;=0;j--)&#123;</span><br><span class="line">                    if(ans[j]==&#x27;.&#x27;)&#123;</span><br><span class="line">                        ans[j]=&#x27;H&#x27;;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=2*k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto c:ans)&#123;</span><br><span class="line">        if(c!=&#x27;.&#x27;)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    for(auto c:ans)cout&lt;&lt;c;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于两个变量的题目，我们可以先满足其中一个的，然后再满足另一个的。</li>
</ul>
</blockquote>
<h1 id="1324E-Sleeping-Schedule"><a href="#1324E-Sleeping-Schedule" class="headerlink" title="1324E Sleeping Schedule"></a><a href="https://codeforces.com/problemset/problem/1324/E">1324E Sleeping Schedule</a></h1><ul>
<li>题意：给定一个数组 $a$，可以选择将其中一些减 $1$（也可以不减），问前缀和数组对 $h$ 取模后在区间 $[L,R]$ 内的元素最多有多少个。</li>
<li>思路：因为数据规模不大，而且每个数可以选也可以不选，因此我们设 $dp[i][j]$ 表示在前 $i$ 个数中，所有数之和对 $h$ 取模的值为 $j$ 时，答案最大为多少。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;h&gt;&gt;l&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">    memset(f,-0x3f,sizeof f);//为什么要这样呢，因为我们不能从非法状态转移，这样也就保证每次只能从[0,0]转移过来</span><br><span class="line">    f[0][0]=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;h;j++)&#123;</span><br><span class="line">            if(j&gt;=l&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">                f[i][j]=max(f[i-1][(j-w[i]+h)%h]+1,f[i-1][(j-w[i]+1+h)%h]+1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                f[i][j]=max(f[i-1][(j-w[i]+h)%h],f[i-1][(j-w[i]+1+h)%h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;h;i++)ans=max(ans,f[n][i]);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这道题是一道很典型的 $DP$ 问题，就是它的状态不能从非 $0$ 开始的状态转移过来，因为不可能存在起始时刻不为 0 的情况，因而我们可以通过对 $f$ 数组赋最的值，这样就能保证不从其他非法状态转移。</p>
</blockquote>
</li>
</ul>
<h1 id="1368D-AND-OR-and-square-sum"><a href="#1368D-AND-OR-and-square-sum" class="headerlink" title="1368D AND, OR and square sum"></a><a href="https://codeforces.com/problemset/problem/1368/D">1368D AND, OR and square sum</a></h1><ul>
<li><p>题意：给定大小为 $n$ 的序列 $a$ ，定义一次操作为选择两个数 $i,j\in[1,n]$ ，设执行操作前 $a<em>i=x,a_j=y$ ，那么执行操作后 $a_i=x \operatorname{and} y,a_j=x \operatorname{or} y$ ，执行若干次操作后， $\sum</em>{i=1}^na_i^2$ 最大能为多少。</p>
</li>
<li><p>思路：首先得知道：$x+y=(x and y)+(x or y)$。（容斥显然得到的）<strong>也就是说，前后操作的总和是不变的</strong>。显然，当 $a$ 中较大的数越大时，$Σa^2$ 越大。又因为我们可以操作任意次，为了让大的尽量大，所以我们每次在二进制上取最多的位数，对于答案的贡献一定是最大的。于是做法就显然了，把所有二进制拆了扔进桶里，每次从取所有不为空的桶计入答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=20;j++)&#123;</span><br><span class="line">            cnt[j]+=(w[i]&gt;&gt;j)&amp;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int cur=0;</span><br><span class="line">        for(int j=0;j&lt;=20;j++)&#123;</span><br><span class="line">            if(cnt[j])&#123;</span><br><span class="line">                cnt[j]--;</span><br><span class="line">                cur+=(1ll&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=cur*cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的位运算题目，得让我知道 $x+y=(x and y)+(x or y)$，因此每次操作综合保持不变，因此要让平方和最大，就得让每次在二进制上取最多的位数，对于答案的贡献一定是最大的。（注意：综合不变的情况下，无论进行多少次操作，总的二进制的 $1$ 的个数不变）</p>
</blockquote>
</li>
</ul>
<h1 id="数位dp模板。值得每天写一下。"><a href="#数位dp模板。值得每天写一下。" class="headerlink" title="数位dp模板。值得每天写一下。"></a>数位dp模板。值得每天写一下。</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">int</span> k,len;</span><br><span class="line"><span class="type">int</span> f[<span class="number">110</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> cnt,<span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;len)&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt==k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[now][cnt][limit]!=<span class="number">-1</span>)<span class="keyword">return</span> f[now][cnt][limit];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxv=limit?num[now]:<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)&#123;</span><br><span class="line">        res+=<span class="built_in">dp</span>(now<span class="number">+1</span>,cnt+(i!=<span class="number">0</span>),limit&amp;(i==maxv));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[now][cnt][limit]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">110</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">110</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                f[i][j][k]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len=s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        num[i<span class="number">+1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AGC003C-BBuBBBlesort"><a href="#AGC003C-BBuBBBlesort" class="headerlink" title="[AGC003C] BBuBBBlesort!"></a><a href="https://www.luogu.com.cn/problem/AT_agc003_c">[AGC003C] BBuBBBlesort!</a></h1><ul>
<li>题意：给定一个序列 a，元素两两不同，可以使用两种操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 翻转相邻两个元素。</span><br><span class="line">2. 翻转相邻三个元素。</span><br></pre></td></tr></table></figure>
问怎么操作使这个序列变成升序，并使操作一的次数最少。输出这个最少的次数。</li>
<li>思路：注意到操作 $2$ 只能使下标奇偶相同的数的位置发生变化。然后操作 $1$ 能使下标奇偶不同的数的位置发生变化。由于所有数都不一样，所以每个数的最终位置都是确定的。那么如果最终位置和当前位置的奇偶性不一样，$ans←ans+1$。最后考虑到每次操作 $1$ 改变 $2$ 个数的位置的奇偶性，$ans← ans/2$。</li>
</ul>
<p>做法1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        b[i]=w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(b+1,b+1+n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)w[i]=lower_bound(b+1,b+1+n,w[i])-b;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if((i&amp;1)!=(w[i]&amp;1))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans/2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>做法2：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),x)-p.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;odd,even,t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        p.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">    p.<span class="built_in">erase</span>(<span class="built_in">unique</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>()),p.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)odd.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">        <span class="keyword">else</span> even.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(odd.<span class="built_in">begin</span>(),odd.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(even.<span class="built_in">begin</span>(),even.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;odd.<span class="built_in">size</span>()&amp;&amp;i&lt;even.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t.<span class="built_in">push_back</span>(odd[i]);</span><br><span class="line">        t.<span class="built_in">push_back</span>(even[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(odd.<span class="built_in">size</span>()&gt;even.<span class="built_in">size</span>())t.<span class="built_in">push_back</span>(odd.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        t[i<span class="number">-1</span>]=<span class="built_in">find</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        ans+=i<span class="number">-1</span>-<span class="built_in">query</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">add</span>(t[i<span class="number">-1</span>],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这道题很好的一道奇偶分析的题目，因为 $a<em>i=a</em>{i+2}$ ，所以奇数交换仍然是奇数，偶数也是。这种翻转问题得多多留意下标。</p>
</blockquote>
<h1 id="ABC238E-Range-Sums"><a href="#ABC238E-Range-Sums" class="headerlink" title="[ABC238E] Range Sums"></a><a href="https://www.luogu.com.cn/problem/AT_abc238_e">[ABC238E] Range Sums</a></h1><ul>
<li>题意：输入一个 $n$ 和 $q$ 分别表示数组长度为 $n$，有 $q$ 次输入：每次输入一个 $l$ 和 $r$，表示我们知道 $l$ 到 $r$ 区间的和问你最后能否知道数组的和。</li>
<li>思路：要求 $[l,r]$ 的和，此时得想到前缀和。而正向的前缀和公式是 $ans=s<em>r-s</em>{l-1}$，变形为 $s<em>{l-1}=s_r-ans$，对于题目给定的 $ans$，我们可以用 $s_r$ 来求粗 $s</em>{l-1}$，这个特点就很熟悉了，连一条边，然后判断 $0$ 和 $n$ 是否在同一个联通块中，如果在，那么就求的出 $s_n-s_0$  ，也就是所有数的和。联通块直接用并查集即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    if(x!=p[x])p[x]=find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)p[i]=i;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l=find(l-1),r=find(r);</span><br><span class="line">        p[l]=r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(find(0)==find(n)?&quot;Yes&quot;:&quot;No&quot;)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的一道并查集跟前缀和合并的一道题目，如果 $l$ 和 $r$ 是一个联通块的话，那么说明 $l-1\rightarrow r$ 的范围内的区间都能被表示。</p>
</blockquote>
</li>
</ul>
<h1 id="P2912-USACO08OCT-Pasture-Walking-G"><a href="#P2912-USACO08OCT-Pasture-Walking-G" class="headerlink" title="P2912 [USACO08OCT] Pasture Walking G"></a><a href="https://www.luogu.com.cn/problem/P2912">P2912 [USACO08OCT] Pasture Walking G</a></h1><ul>
<li>题意：求图上两个奶牛的距离。</li>
<li>思路：LCA模板题。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs(int u,int fa)&#123;</span><br><span class="line">    for(int i=1;i&lt;=20;i++)&#123;</span><br><span class="line">        f[u][i]=f[f[u][i-1]][i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto&amp; [j,w]:G[u])&#123;</span><br><span class="line">        if(j==fa)continue;</span><br><span class="line">        f[j][0]=u;</span><br><span class="line">        d[j]=d[u]+w;</span><br><span class="line">        dep[j]=dep[u]+1;</span><br><span class="line">        dfs(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int x,int y)&#123;</span><br><span class="line">    if(dep[x]&lt;dep[y])swap(x,y);</span><br><span class="line"></span><br><span class="line">    for(int i=20;~i;i--)&#123;</span><br><span class="line">        if(dep[f[x][i]]&gt;=dep[y])&#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(x==y)return x;</span><br><span class="line"></span><br><span class="line">    for(int i=20;~i;i--)&#123;</span><br><span class="line">        if(f[x][i]!=f[y][i])&#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[x][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].emplace_back(b,c);</span><br><span class="line">        G[b].emplace_back(a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1,0);</span><br><span class="line"></span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        int p=lca(x,y);</span><br><span class="line">        cout&lt;&lt;d[x]+d[y]-2*d[p]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
很好的一道 $lca$ 题目，是一道模板题，值得看看。</li>
</ul>
<h1 id="NOI2014-起床困难综合症"><a href="#NOI2014-起床困难综合症" class="headerlink" title="[NOI2014] 起床困难综合症  "></a><a href="https://www.luogu.com.cn/problem/P2114">[NOI2014] 起床困难综合症  </a></h1><ul>
<li>题意：给定 $n$ 个事件 $(opi,ti)$，其中 $opi$ 为$and/or/xor$ 三种位运算之一，$ti$ 为非负整数，要求在 $[0,m]$ 中选择一个数 $x$，最大化对 $x$ 依次执行 $n$ 个事件后的结果。</li>
<li>思路：由于要最大化结果，因此我们可以考虑贪心：能用 $0$ 换 $1$ 就一定能换，能用 $1$ 换 $1$ 也换，不能换就不换。注意到这道题的 $1$ 是怎么来的？它可能是从 $0$ 来的，也可能从 $1$ 来的，因此我们的初始值为全 $0$ 和全 $1$ 来计算。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,m;</span><br><span class="line">string s;</span><br><span class="line">int a1=0,a2=-1;//全0和全1</span><br><span class="line">//尽可能变成1</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1,x;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;x;</span><br><span class="line">        if(s==&quot;AND&quot;)a1&amp;=x,a2&amp;=x;</span><br><span class="line">        if(s==&quot;OR&quot;)a1|=x,a2|=x;</span><br><span class="line">        if(s==&quot;XOR&quot;)a1^=x,a2^=x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=30;i&gt;=0;i--)&#123;</span><br><span class="line">        if(a1&gt;&gt;i&amp;1ll)ans+=(1ll&lt;&lt;i);//0-&gt;1</span><br><span class="line">        else if(a2&gt;&gt;i&amp;1ll&amp;&amp;(1ll&lt;&lt;i)&lt;=m)&#123;//1-&gt;1</span><br><span class="line">            ans+=(1ll&lt;&lt;i),m-=(1ll&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很好的一道位运算题目：位运算只针对二进制下的每一位，也就是说每一位经过 $n$ 次位运算以后，不会影响别的位。如果最后选 1 比选 0 更好，并且选完 1 过后 val≤m 那么选择 1。<strong>因此对于这种要选 $1$ 更好，我们就得想1是怎么来的，比如这道题1可以从0或者1来，因此我们就设a1=0,a2=-1。</strong> </p>
</blockquote>
</li>
<li>题意：给定一个长度为 n 的非负整数序列 A ，求一个平均数最大的，长度不小于 L 的子段。</li>
<li>思路：直接二分答案，然后对于二分答案中又有长度限制此时就考虑单调队列。然后这边需要注意的是，我们二分的是平均值，然后把每个数减去平均值就是每个数离平均数的差值，如果单调队列找到为 $0$ 的，此时说明满足条件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(double x)&#123;</span><br><span class="line">    vector&lt;double&gt;p(n+1,0);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]=w[i]-x;</span><br><span class="line">        p[i]+=p[i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double t=0;</span><br><span class="line"></span><br><span class="line">    deque&lt;int&gt;q;</span><br><span class="line"></span><br><span class="line">    for(int i=L;i&lt;=n;i++)&#123;</span><br><span class="line">        while(q.size()&amp;&amp;p[q.back()]&gt;p[i-L])q.pop_back();</span><br><span class="line">        q.push_back(i-L);</span><br><span class="line">        if(q.size()&amp;&amp;p[i]-p[q.front()]&gt;=0)return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    double l=0,r=2e9;</span><br><span class="line"></span><br><span class="line">    while(r-l&gt;eps)&#123;</span><br><span class="line">        double mid=(l+r)/2.0;</span><br><span class="line">        if(check(mid))l=mid;</span><br><span class="line">        else r=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(int)(r*1000)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="USACO03MAR-Best-Cow-Fences-G"><a href="#USACO03MAR-Best-Cow-Fences-G" class="headerlink" title="[USACO03MAR] Best Cow Fences G  "></a><a href="https://www.luogu.com.cn/problem/P10450">[USACO03MAR] Best Cow Fences G  </a></h1></li>
</ul>
<blockquote>
<p>对于平均数的问题，我们往往可以把原数全部减去平均数来判断多少大于平均数和小于平均数，然后这道题是长度只说明 $&gt;=L$ ，那么我们直接用单调队列即可，就是不需要长度太长弹出的操作（考察单调队列维护固定长度区间的最大值）。</p>
</blockquote>
<h1 id="ABC346D-Gomamayo-Sequence"><a href="#ABC346D-Gomamayo-Sequence" class="headerlink" title="[ABC346D] Gomamayo Sequence"></a><a href="https://www.luogu.com.cn/problem/AT_abc346_d">[ABC346D] Gomamayo Sequence</a></h1><ul>
<li>题意：有一个长为 N 的 01 串 S。定义好字符串：有且仅有一个 $1≤i&lt;N$，满足 $S<em>i=S</em>{i+1}$，把每个字符修改（0 变 1，1 变 0）需要 $c_i$ 块钱。问你把 S 改成好字符串需要几块钱。</li>
<li>思路：因为数字只有 $01$ 两个数，因此可以考虑dp。此时是三个维度的，$f_{i,j,k}$ 表示已经到第 $i$ 个地方，第 $i$ 位的状态是 $j$ 情况，且整个字符串的状态是 $k$ 的最小方案数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    f[2][0][0]=(s[1]==&#x27;0&#x27;)*w[1]+(s[2]==&#x27;1&#x27;)*w[2];</span><br><span class="line">    f[2][1][0]=(s[1]==&#x27;1&#x27;)*w[1]+(s[2]==&#x27;0&#x27;)*w[2];</span><br><span class="line">    f[2][0][1]=(s[1]==&#x27;1&#x27;)*w[1]+(s[2]==&#x27;1&#x27;)*w[2];</span><br><span class="line">    f[2][1][1]=(s[1]==&#x27;0&#x27;)*w[1]+(s[2]==&#x27;0&#x27;)*w[2];</span><br><span class="line"></span><br><span class="line">    for(int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i][0][0]=f[i-1][1][0]+(s[i]==&#x27;1&#x27;)*w[i];</span><br><span class="line">        f[i][1][0]=f[i-1][0][0]+(s[i]==&#x27;0&#x27;)*w[i];</span><br><span class="line">        f[i][0][1]=min(f[i-1][1][1],f[i-1][0][0])+(s[i]==&#x27;1&#x27;)*w[i];</span><br><span class="line">        f[i][1][1]=min(f[i-1][0][1],f[i-1][1][0])+(s[i]==&#x27;0&#x27;)*w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;min(f[n][0][1],f[n][1][1])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HAOI2008-糖果传递"><a href="#HAOI2008-糖果传递" class="headerlink" title="[HAOI2008] 糖果传递"></a><a href="https://www.luogu.com.cn/problem/P2512">[HAOI2008] 糖果传递</a></h1><ul>
<li>题意：有 $n$ 个小朋友坐成一圈，每人有 $a_i$ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $1$。</li>
<li>思路：我们算出 $ans=\sum_{i=1}^{n}|c_i-(-p_1)|$，这个也就是说，要找到一点到所有 $c_1,c_2,…,c_n$ 的距离最短，这样就转化成了货仓选址。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int sum=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        sum+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(sum%n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ave=sum/n;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        c[i]=(w[i]-ave);</span><br><span class="line">        c[i]+=c[i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(c+1,c+1+n);</span><br><span class="line"></span><br><span class="line">    int t=c[(n+1)&gt;&gt;1];</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=abs(t-c[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ABC327D-Good-Tuple-Problem"><a href="#ABC327D-Good-Tuple-Problem" class="headerlink" title="[ABC327D] Good Tuple Problem"></a><a href="https://www.luogu.com.cn/problem/AT_abc327_d">[ABC327D] Good Tuple Problem</a></h1><ul>
<li>题意：给定 $n$ 个值为 $0$ 或 $1$ 的点和 $m$ 条关系，每一条关系表示两个点的值不能相同，问是否有合法构造方案满足所有条件。</li>
<li>思路：对于这种一个取 $0$ 另一个必须取 $1$ 的情况，说明什么？说明我们可以用种类并查集来做（就是扩展域），就是 $x$ 跟 $y’$ 连边，然后 $y’$ 跟 $x$ 连边。（当然也可以用 <a href="https://www.luogu.com.cn/article/q5mxbvg9">2——SAT做法</a>）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    if(x!=p[x])p[x]=find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=m;i++)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n*2;i++)p[i]=i;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        x=find(a[i]),y=find(b[i]);</span><br><span class="line">        if(x==y)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        p[find(a[i]+n)]=y,p[find(b[i]+n)]=x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="1626C-Monsters-And-Spells"><a href="#1626C-Monsters-And-Spells" class="headerlink" title="1626C Monsters And Spells"></a><a href="https://codeforces.com/problemset/problem/1626/C">1626C Monsters And Spells</a></h1><ul>
<li>题意：有 $n$ 个怪兽，第 $i$ 个怪兽在第 $k_i$ 秒出现，血量为 $h_i$，你可以在每一秒提升战斗力，假设你上一秒的战斗力是 $x$，那么你这一秒战斗力可以选择 $x+1$ 或 $1$ 或 $0$。你要保证对于每个怪兽，在第 $k_i$ 秒时，战斗力至少是 $h_i$。每一秒消耗的魔力就是那一秒的战斗力，求能够打败所有怪兽所消耗的魔力值最小值。</li>
<li>思路：对于一个怪兽，如果要在第 $k_i$ 秒战斗力达到 $h_i$，那么你就至少在第 $k_i-h_i+1$ 秒开始积累战斗值。这样我们可以记一个怪兽转换为要求占用的区间 $[k_i-h_i+1,k_i]$。显然对于一个区间 $[l,r]$，这个区间的魔力值消耗就是 $1+2+3+\dots+(r-l+1)=(r-l+1)(r-l+2)/2$。那么，如果两个区间相交了，会发生什么事呢？假设两个区间 $[l_1,r_1],[l_2,r_2]$ 有相交。那么，在第 $r_1$ 秒的时间你的战斗力已经是一个很大的数了，而又无法在此时重新积累战斗力，不然就打败不了第二个怪兽，所以战斗力要继续累积。因此我们可以这两个区间的魔力值最小消耗就等价于合并成一个大区间。包含的情况也是一样。所以我们只需要把这些区间合并成若干个区间，然后再统计每个区间的答案即可。这一题的 $n$ 奇小，所以每次合并暴力把一个区间删掉都可以。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n;</span><br><span class="line">int k[N],h[N];</span><br><span class="line">struct E&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator&lt;(const E&amp; t)const&#123;</span><br><span class="line">        if(l!=t.l)return l&lt;t.l;</span><br><span class="line">        return r&lt;t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N];</span><br><span class="line"></span><br><span class="line">void del(int x)&#123;</span><br><span class="line">    for(int i=x;i&lt;n;i++)seg[i]=seg[i+1];</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;k[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;h[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        seg[i]=&#123;k[i]-h[i]+1,k[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(seg+1,seg+1+n);</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(seg[i].l&lt;=seg[i-1].r)&#123;</span><br><span class="line">            seg[i-1].r=max(seg[i].r,seg[i-1].r);</span><br><span class="line">            del(i);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=(seg[i].r-seg[i].l+1)*(seg[i].r-seg[i].l+2)/2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>区间很少的区间合并问题，此时可以用暴力删除的方式做题。</p>
</blockquote>
<h1 id="219D-Choosing-Capital-for-Treeland"><a href="#219D-Choosing-Capital-for-Treeland" class="headerlink" title="219D-Choosing Capital for Treeland  "></a><a href="https://www.luogu.com.cn/problem/CF219D">219D-Choosing Capital for Treeland  </a></h1><ul>
<li>题意：给定 $n$ 个点，$n−1$ 条有向边，求到达所有其他点需要更换方向最小的次数，及符合这类条件的点的升序序列</li>
<li><p>思路：换根dp的典型题目。（换根dp简单来说就是先算出任意一个点出发的情况，然后再通过从任意一个点出发算出的答案来更新特定根出发的答案）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs1(int u,int fa)&#123;//求出u到子节点需要逆转的边数</span><br><span class="line"></span><br><span class="line">    for(auto&amp; [j,w]:G[u])&#123;</span><br><span class="line">        if(j==fa)continue;</span><br><span class="line">        dfs1(j,u);</span><br><span class="line">        f[u]+=(f[j]+w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs2(int u,int fa)&#123;//求出u到全树需要逆转的边数</span><br><span class="line">    for(auto&amp; [j,w]:G[u])&#123;</span><br><span class="line">        if(j==fa)continue;</span><br><span class="line">        f[j]=f[u]+(w?-1:1);</span><br><span class="line">        dfs2(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].emplace_back(b,0);//正向边</span><br><span class="line">        G[b].emplace_back(a,1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs1(1,0);</span><br><span class="line">    dfs2(1,0);</span><br><span class="line"></span><br><span class="line">    int minv=*min_element(f+1,f+1+n);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;minv&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(f[i]==minv)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于这种题目，我们都是采用换根dp，为什么呢？因为它要求找到最好的位置作为首都。这种题都有一个特点就是：第一遍求的是根节点跟子树的关系，第二遍求的是该节点跟全树的关系。而且对于这种正向边和反向边变换的问题，我们直接建立双向边，然后如果要改变的话就加上该边的代价。</p>
<h1 id="包含二进制优化的多重背包问题的代码。"><a href="#包含二进制优化的多重背包问题的代码。" class="headerlink" title="包含二进制优化的多重背包问题的代码。"></a>包含二进制优化的多重背包问题的代码。</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c[<span class="number">0</span>]&gt;&gt;d[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i]&gt;&gt;d[i];</span><br><span class="line">        s[i]=a[i]/b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[<span class="number">0</span>]=n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];s[i]-=j,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=j*c[i];k--)&#123;</span><br><span class="line">                f[k]=<span class="built_in">max</span>(f[k],f[k-j*c[i]]+j*d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=s[i]*c[i];k--)&#123;</span><br><span class="line">            f[k]=<span class="built_in">max</span>(f[k],f[k-s[i]*c[i]]+s[i]*d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>差分的前缀和就是修改好的序列。</p>
</blockquote>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P8807">P8807 [蓝桥杯 2022 国 C] 取模</a></p>
</li>
<li>题意：给定 n,m，问是否存在两个不同的数 x,y 使得 1≤x&lt;y≤m 且 n mod x=n mod ⁡y。</li>
<li>思路：每组数据中，若存在 $n \bmod x = n \bmod y$，那么 $n \bmod \operatorname{lcm}(x,y) \le \min (x,y)$。原因显然。<br>而且，当 $m \ge 23$ 时，由于 $\operatorname{lcm}(1,2,\cdots,23) - 1 \gt 10^9$，所以显然有解。我们的暴力只需要依次枚举 $1 \le x \lt y \le 12$ 就可以。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    if(m&gt;n+1)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            if(n%i!=i-1)&#123;//说明它肯定跟前面相等</span><br><span class="line">                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果出现 $n\ mod \ i \not= i-1$，说明肯定跟前面相等。（因为我们就是按顺序枚举的）</p>
</blockquote>
<hr>
<h1 id="注意点总结"><a href="#注意点总结" class="headerlink" title="注意点总结"></a>注意点总结</h1><blockquote>
<p>如果对于某个 $i$ 满足 $a<em>{2i-1}&lt;a</em>{2i}$ 的话，此时式子的第二项是正数的情况下，它对答案的贡献就是 $2*(a<em>{2i-1}-a</em>{2i})$。</p>
<p>multiset 代替线段树来维护增删过程。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;w&gt;&gt;h&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;lx,ly;<span class="comment">//存储切割位置</span></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;x,y;<span class="comment">//x,y储存碎块边长</span></span><br><span class="line"></span><br><span class="line">    x.<span class="built_in">insert</span>(w);</span><br><span class="line">    y.<span class="built_in">insert</span>(h);</span><br><span class="line">    lx.<span class="built_in">insert</span>(<span class="number">0</span>),lx.<span class="built_in">insert</span>(w);</span><br><span class="line">    ly.<span class="built_in">insert</span>(<span class="number">0</span>),ly.<span class="built_in">insert</span>(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            ly.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">auto</span> it=ly.<span class="built_in">find</span>(p);</span><br><span class="line">            --it;</span><br><span class="line">            <span class="type">int</span> l=*it;<span class="comment">//前一条的位置</span></span><br><span class="line">            ++it,++it;</span><br><span class="line">            <span class="type">int</span> r=*it;<span class="comment">//后一条的位置</span></span><br><span class="line">            it=y.<span class="built_in">find</span>(r-l);</span><br><span class="line"></span><br><span class="line">            y.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">            y.<span class="built_in">insert</span>(r-p);</span><br><span class="line">            y.<span class="built_in">insert</span>(p-l);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lx.<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="keyword">auto</span> it=lx.<span class="built_in">find</span>(p);</span><br><span class="line">            --it;</span><br><span class="line">            <span class="type">int</span> l=*it;</span><br><span class="line">            ++it,++it;</span><br><span class="line">            <span class="type">int</span> r=*it;</span><br><span class="line">            it=x.<span class="built_in">find</span>(r-l);</span><br><span class="line">            x.<span class="built_in">erase</span>(it);</span><br><span class="line">            x.<span class="built_in">insert</span>(r-p);</span><br><span class="line">            x.<span class="built_in">insert</span>(p-l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it=x.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">        <span class="type">int</span> l=*it;</span><br><span class="line">        it=y.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">        <span class="type">int</span> r=*it;</span><br><span class="line">        cout&lt;&lt;(l*r)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>连通性问题考虑方向： flood fill 并查集，dfs。</p>
<p>数字问题可以考虑数位dp和进制，特别注意有的时候如果不能有比如 $4$ 的存在，可以把它转化成九进制问题。</p>
<p>前缀和/异或和常见套路：如果异或和不为0，只要在数组内等于s的块数大于2就说明它可以合并每块使得最后异或和为0。</p>
<p>对于mex a=m，删除 $i（i&lt;m）$，那么代价就是$ (m(cnt-1)+i) $，此时我们的答案是ans=d1<em>(c1-1)+0+d2</em>(c2-1)+1+…+mex a<em>(c_{dk}-1)+dk，=d1</em>c1+d2<em>c2+…+mex a</em>ck-mex a。</p>
<p>gcd 和质数的关系：要使得删去的数最小，也就是保留的数越多，而且gcd要最大，我们可以枚举质数。<strong>拥有共同质数的数的gcd是最大的</strong>。</p>
<p><a href="https://codeforces.com/problemset/problem/1823/C">1823C</a> 当时认为比较难的数论题。</p>
<p>曼哈顿距离结论：曼哈顿距离内的数最多只能填(d+1)*(d+1)个。</p>
<p>倒相加可以规避段数系数限制，也就是：不知道多少段，可以把累乘变成累加。<a href="https://codeforces.com/problemset/problem/1903/C">1903C</a></p>
<p>最大子段区间异或和——tire树。</p>
<p>连续子串想前缀和，转化冒泡排序思想。比如：题目的描述可以改成 $s<em>{r}-s</em>{l-1}$，那么题目还可以转化成有 $k$ 对 $(i,j)$，使得 $s_i&lt;s_j$ 满足条件。</p>
<p>排序类问题要么想到冒泡排序，要么想到它的一些性质，比如本道题的性质就是分别位于首尾的 1 和 n 一定是在最后一次操作中归位的。</p>
<p>树状数组和最近配对点（树状数组可以优化）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> tr[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        v[w[i]+n].<span class="built_in">push_back</span>(i);</span><br><span class="line">        A.<span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">vis</span>(n+n<span class="number">+1</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n*<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;<span class="comment">//这边从右往左可以避免一些不必要的讨论</span></span><br><span class="line">    <span class="comment">//而且你从右往左还有个好处就是中间的一些没有配对的会被配对的移到前面去</span></span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        v[w[i]+n].<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="type">int</span> now=v[-w[i]+n].<span class="built_in">back</span>();</span><br><span class="line">        v[-w[i]+n].<span class="built_in">pop_back</span>();</span><br><span class="line">        vis[now]=<span class="literal">true</span>;</span><br><span class="line">        A.<span class="built_in">add</span>(now,<span class="number">-1</span>);</span><br><span class="line">        ans+=(A.<span class="built_in">query</span>(i<span class="number">-1</span>)-A.<span class="built_in">query</span>(now<span class="number">-1</span>));</span><br><span class="line">        cout&lt;&lt;(A.<span class="built_in">query</span>(i<span class="number">-1</span>)-A.<span class="built_in">query</span>(now<span class="number">-1</span>))&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;<span class="number">0</span>)ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自然数 $\gcd$ 的性质：自然数 $\gcd$ 的性质就是一半一半，一半是1，然后一半的一半是2…</p>
<p>序列配对可以考虑分治（这一部分得单独开专栏），例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ret=<span class="built_in">F</span>(l,mid)+<span class="built_in">F</span>(mid<span class="number">+1</span>,r);</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp1,mp2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&lt;=r;i++)pre[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">+1</span>;i&lt;=r;i++)pre[i]=<span class="built_in">max</span>(pre[i<span class="number">-1</span>],w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">+1</span>;i&lt;=r;i++)mp2[pre[i]-w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid,j=mid<span class="number">+1</span>,mx=<span class="number">0</span>;i&gt;=l;i--)&#123;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,w[i]);</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r&amp;&amp;pre[j]&lt;=mx)mp1[w[j]]++,mp2[pre[j]-w[j]]--,j++;</span><br><span class="line">        ret+=mp1[mx-w[i]]+mp2[w[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">F</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>树kruskal 删边变成树</p>
<p>有跳跃可以考虑dp、建图、dsu。</p>
</blockquote>
<hr>
<p>终于完结了，累死我了</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>CF各rating VP（1）</title>
    <url>/2025/03/10/CF%E5%90%84rating-VP%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h1><p><a href="https://vjudge.net/contest/700327">比赛链接</a></p>
<blockquote>
<p>我真服了，我居然会被 1200 的构造题给虐到了。</p>
</blockquote>
<h2 id="1947C-Swap-Game-1200-博弈"><a href="#1947C-Swap-Game-1200-博弈" class="headerlink" title="1947C-Swap Game *1200 博弈"></a>1947C-Swap Game <strong>*1200</strong> 博弈</h2><ul>
<li>题意：<code>Alice</code> 和 <code>Bob</code> 在玩一个游戏，其中 <code>Alice</code> 先手，每轮每个人可以将 $a_1-1$ 然后把这个数跟 $a_i$ 进行交换。如果 $a_1=0$ ，此时这一轮操作者输。问二者在最优的情况下，谁赢了。</li>
<li>思路：其实很容易，我前半部分想出来了，但后半部分就是没有深入去想 <code>Alice</code> 肯定是选较小的数，因为这样能让坏的情况留给 <code>Bob</code>（为什么呢？因为假如这个数是 $1$，然后 <code>Alice</code> 选这个 $1$，此时 <code>Bob</code> 再操作也得把这个 $1$ 减掉，最后 <code>Alice</code> 再选这个 $0$ 此时 <code>Bob</code> 就输了），所以 <code>Bob</code> 为了防止出现这种情况，就选比较大的。但我们通过枚举发现，只要我们在 $2$ 到 $n$ 出现比 $a_1$ 小的数此时 <code>Bob</code> 就不行了。 </li>
</ul>
<blockquote>
<p>卡在：做这道题的时候发现之前做过，然后老是调用以前的思路。我当时想到肯定得把数组分成 $1$ 和 $2\rightarrow n$，然后我就没有仔细想下去，就是我没有去具体分析谁会赢。<strong>以后做题的时候得继续分析，可以举特例进行下去</strong>。（<strong>博弈论欠缺，演算能力欠缺</strong>）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;w[<span class="number">1</span>])f=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Bob&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Alice&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="1853B-Fibonaccharsis-1200"><a href="#1853B-Fibonaccharsis-1200" class="headerlink" title="1853B-Fibonaccharsis *1200"></a>1853B-Fibonaccharsis <strong>*1200</strong></h2><ul>
<li>题意：给你需要构造的长度 $k$ 和 $a<em>k=n$，此时要求你计算满足 $a_i=a</em>{i-1}+a_{i-2}$ 并且 $a$ 数组非严格单调递增且非负的个数。</li>
<li>思路：思路很清楚，就是发现当 $k&gt;=30$ 的时候是无法构造出来的，因为根据斐波那契数列，我们会发现当 $k=30$ 的时候数很大了。是这个 $832040$，这个已经大于 $2\times 10^5$ 了。所以此时 $k$ 就比较小，因此我们可以考虑直接暴力来做就行，也就是从 $n$ 出发，枚举 $f_{k-1}$ 数的大小，此时就可以通过这两项就能确定下去了。</li>
</ul>
<blockquote>
<p>被这道题硬控 $50$ 分钟。我总是往通项公式的方面去想，然后越想越复杂。根本没有去想 $k$ 比较小的情况。<strong>以后做题就得先从特殊开始，数搞小一点先判断再搞大一些</strong>。（其实当时也想到暴力了，但我没有仔细发现如果这个数组已经确定两个数，那么这个数组就已经唯一确定了，因为它可以通过那两个数算下去），<del>也不知道怎么回事，我为什么会想着除了这两个数其他数会变，真的服了。</del></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&gt;=<span class="number">30</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">VI <span class="title">f</span><span class="params">(k<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        f[k]=n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            f[k<span class="number">-1</span>]=i;</span><br><span class="line">            <span class="built_in">FORD</span>(j,<span class="number">1</span>,k<span class="number">-2</span>)&#123;</span><br><span class="line">                f[j]=f[j<span class="number">+2</span>]-f[j<span class="number">+1</span>];</span><br><span class="line">                <span class="keyword">if</span>(f[j]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    f[<span class="number">1</span>]=<span class="number">-10000</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(f[<span class="number">1</span>]&gt;=<span class="number">0</span>&amp;&amp;f[<span class="number">2</span>]&gt;=f[<span class="number">1</span>])ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1957B-A-BIT-of-a-Construction-1100"><a href="#1957B-A-BIT-of-a-Construction-1100" class="headerlink" title="1957B-A BIT of a Construction *1100"></a>1957B-A BIT of a Construction <strong>*1100</strong></h2><ul>
<li>题意：要求你构造出 $a_i$ 使得它的和是 $k$，且构造出的 $a_i$ 的前置或中的 $1$ 的数量最多。</li>
<li>思路：直接把这个 $k$ 分解了，我们发现构造出 $2^{\log(k)-1}-1$ 是不错的，因为这里的 $1$ 的数量是最多的。（可以举几个例子）</li>
</ul>
<blockquote>
<p>想太久了，一个好好从小到大分析的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=k,s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        t/=<span class="number">2</span>;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k-=((<span class="number">1</span>&lt;&lt;(s<span class="number">-1</span>))<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;((<span class="number">1</span>&lt;&lt;(s<span class="number">-1</span>))<span class="number">-1</span>)&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;k&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">3</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1904B-Collecting-Game-1100"><a href="#1904B-Collecting-Game-1100" class="headerlink" title="1904B-Collecting Game *1100"></a>1904B-Collecting Game <strong>*1100</strong></h2><ul>
<li>题意：给定一个由 $n$ 位正整数组成的数组。你可以选择选择任意一个数作为你的判断值。然后任意一个 $\le$ 它的数可以被选中加入你的分数（注意判断值不算在里面），同时该数被移除数组。你的任务是，对于该数组中的每个数，都将其作为判断值并找出其所能移除的最大数量。</li>
<li>思路：这道题很明显就是大的数可以把小的数“吃”掉，然后得到的数字就是它们俩个个数的和。那么我们就可以对 $a$ 数组进行排序。然后用双指针来做就行了。这里要注意的就是不要每次让 $r=i$ ，这样会超时。</li>
</ul>
<blockquote>
<p>卡在：我想到排序了，但我怎么想的那么复杂，<strong>以后做题的时候尽量把能表达的写在纸张上，我怎么总是感觉我很喜欢在脑子里面进行模拟，但这种虽然能解决问题，但脑子想的比手快这种感觉很难受</strong>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i].fi,w[i].se=i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)s[i]=s[i<span class="number">-1</span>]+w[i].fi;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        r=<span class="built_in">max</span>(r,i);</span><br><span class="line">        <span class="keyword">while</span>(r<span class="number">+1</span>&lt;=n&amp;&amp;s[r]&gt;=w[r<span class="number">+1</span>].fi)r++;</span><br><span class="line">        ans[w[i].se]=r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;ans[i]<span class="number">-1</span>&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1832B-Maximum-Sum-1100"><a href="#1832B-Maximum-Sum-1100" class="headerlink" title="1832B-Maximum Sum *1100"></a>1832B-Maximum Sum <strong>*1100</strong></h2><ul>
<li>题意：给你一个数组 $a$，给你 $k$ 次以下操作：你可以选择后其中操作的一种操作进行，即：删除数组中最小的两个数或者删除最大的一个数。问进行操作之后最大的和是多少。</li>
<li>思路：这道题如果贪心就会错样例 <code>15 22 12 10 13 11</code>(要进行两次操作)。（贪心的思路就是如果最小值的两个大于最大值的一个，此时就删除最大值，此时这个答案就是 <code>40</code>），这样会有问题，其实我们可以删除两个最大值使得答案为 <code>46</code>。那么此时我们枚举进行了 $i$ 次操作 $1$，那么就进行了 $k-i$ 次操作 $2$，然后二者取最大值即可。</li>
</ul>
<blockquote>
<p>卡在：只想到贪心了，没有发现上述问题。<strong>以后贪心不保证是正确的情况下，建议举能让贪心失效的例子</strong>（这个感觉很困难，但我相信以后可以省略这个步骤）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,k)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,s[n-k+i]-s[i*<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1638B-Odd-Swap-Sort-1100"><a href="#1638B-Odd-Swap-Sort-1100" class="headerlink" title="1638B-Odd Swap Sort *1100"></a>1638B-Odd Swap Sort <strong>*1100</strong></h2><ul>
<li>题意：给定一个数组，如果相邻两个数之和是奇数的情况下，此时就可以交换。问进行无限次这种操作是否能让数组变得有序。</li>
<li>思路：我们发现奇数+偶数等于奇数，奇数+奇数等于偶数。所以有一个很明显的思路就是如果奇数不是有序的，那么你肯定不能让数组变得有序，比如(<code>6 3</code>)。偶数同理。</li>
</ul>
<blockquote>
<p>卡在：我刚开始看到相邻数交换，此时想到了冒泡排序，但我看到了数据规模很大，此时就不知道怎么办了。（<del>其实以为还可以优化，但我一直没有发现，又想歪了</del>）<strong>以后如果想不下去的话，抓住题目的提示，比如这道题说奇数，我们就得想到为什么题目说要是奇数，那这道题肯定跟数字的奇偶有关</strong>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    VI odd,even;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&amp;<span class="number">1</span>)odd.<span class="built_in">pb</span>(w[i]);</span><br><span class="line">        <span class="keyword">else</span> even.<span class="built_in">pb</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,odd.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(odd[i]&lt;odd[i<span class="number">-1</span>])&#123;</span><br><span class="line">            NO;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,even.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(even[i]&lt;even[i<span class="number">-1</span>])&#123;</span><br><span class="line">            NO;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1657C-Bracket-Sequence-Deletion-1200"><a href="#1657C-Bracket-Sequence-Deletion-1200" class="headerlink" title="1657C-Bracket Sequence Deletion *1200"></a>1657C-Bracket Sequence Deletion <strong>*1200</strong></h2><ul>
<li>题意：有 $T$ 组数据，每组给你一个 $n$，表示一个全部由 <code>(</code> 和 <code>)</code> 组成的长度为 $n$ 的字符串。当此时的前缀满足以下两种条件之一时即可操作：1. 这个前缀是一个合法括号序列。2. 此前缀是长度大于等于 $2$ 的回文串。问最多能操作多少次以及最后剩下多少个字符。</li>
<li>思路：因为题目又说要最小的情况，那就很好办了，我们发现我们只需要分成 <code>((</code> <code>))</code> <code>)(...()</code> 这样的，如果满足这样的就分成一组。  </li>
</ul>
<blockquote>
<p>不知道为什么，看到这种题心里面都会疙瘩一下。然后是看了测试点才发现我卡在 <code>)((</code>，我的答案全是 <code>0</code>，后来发现如果 <code>r=n</code> 的情况没有把 <code>t</code> 的值给赋了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">+1</span>&lt;n)&#123;</span><br><span class="line">                <span class="type">int</span> r=i<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">while</span>(r&lt;n&amp;&amp;s[r]==<span class="string">&#x27;(&#x27;</span>)r++;</span><br><span class="line">                <span class="keyword">if</span>(r==n)&#123;</span><br><span class="line">                    t=r-i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i=r;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">+1</span>&lt;n)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1530C-Pursuit-1200"><a href="#1530C-Pursuit-1200" class="headerlink" title="1530C-Pursuit *1200"></a>1530C-Pursuit <strong>*1200</strong></h2><ul>
<li><p>题意：给出你和对手的长度皆为 $n$ 个阶段的成绩序列，每个成绩都为 $0$ 到 $100$ 间的正整数。问至少再过多少个阶段，你的总分才能不小于对手的总分，如果你的总分已经不小于对手，输出 $0$。总分的计算方式为：设当前已进行 $k$ 个阶段，则总分为最高的 $k-\lfloor \frac{k}{4} \rfloor$ 个阶段的成绩之和，其中，$\lfloor a \rfloor$ 表示 $a$ 向下取整（不大于 $a$ 的最大整数）。</p>
</li>
<li><p>思路：就直接二分答案（也就是给定需要扩展的长度，后面就很容易想了）。思路很清楚，画个图就能理解了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=n+x-(n+x)/<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a1=<span class="number">0</span>,a2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,t-x);</span><br><span class="line">    a1=s1[n]-s1[n-p]+x*<span class="number">100</span>;</span><br><span class="line">    a2=s2[n]-s2[<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,n-t)];</span><br><span class="line">    <span class="keyword">return</span> a1&gt;=a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)s1[i]=s1[i<span class="number">-1</span>]+a[i],s2[i]=s2[i<span class="number">-1</span>]+b[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">-1</span>,r=<span class="number">1e12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1420B-Rock-and-Lever-1200"><a href="#1420B-Rock-and-Lever-1200" class="headerlink" title="1420B-Rock and Lever *1200"></a>1420B-Rock and Lever <strong>*1200</strong></h2><ul>
<li>题意：要找出满足 $i<j 且 a_i\&a_j>=a_i\oplus a_j$ 的个数。</li>
<li>思路：很容易发现，在二进制情况下，如果它们的位数一样的情况下（也就是假如我们的最高位都是 $1$ 的情况，此时与就很小了），是满足条件的。所以我们的答案就是 $C_{每一位}^{2}$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">b</span><span class="params">(<span class="number">70</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">0</span>,<span class="number">61</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((w[i]&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                b[j]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">61</span>)&#123;</span><br><span class="line">        ans+=(b[i]<span class="number">-1</span>)*b[i]/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1313B-WeirdSort-1200"><a href="#1313B-WeirdSort-1200" class="headerlink" title="1313B-WeirdSort *1200"></a>1313B-WeirdSort <strong>*1200</strong></h2><ul>
<li>题意：给定一个长度为 $n$ 的数组 $a$ 和一个数组 $p$ 。其中 <code>p[i]</code> 表示 <code>a[p[i]]</code> 和 <code>a[p[i]+1]</code> 可以交换。通过任意次交换，问你能否把 $a$ 数组变成一个非降数列。</li>
<li>思路：这种又是交换相邻的数，我们看数据规模不大，因此可以想到冒泡排序，暴力维护即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;S;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;p[i],S.<span class="built_in">insert</span>(p[i]);</span><br><span class="line"></span><br><span class="line">    VI ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">2</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[j]&lt;w[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(w[j],w[j<span class="number">-1</span>]);</span><br><span class="line">                ans.<span class="built_in">pb</span>(j<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(ans));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            NO;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发现后面的题目比前面好做多了，不知道是思维难度低还是什么原因。计划明天再来一次 $1h$ 的 $1100$ 练习和 $1h$ 的 $1200$ 练习，题目数量 $5\rightarrow 6$ 题吧。因为通过这一次发现：我 $1200$ 的题最快 $10$ 分钟，理想情况最慢 $30$ 分钟。</p>
<p>发现：自己做那种暴力的题目脑子会短路，就是感觉有那个思路但就是写不出来，而且很容易红温，建议：<strong>把分类讨论写在纸上，对自己说有什么珍贵的的东西不写下来。</strong> 同时要把那种容易写不出来就烦这种习惯改改，什么时候这种类型VP不会红温我就天天奖励我自己CP。</p>
</blockquote>
<h1 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h1><p><del>服了，为什么脑子还是这么不好用，会不会是昨天晚上睡不着啊，痛苦。</del></p>
<p><a href="https://vjudge.net/contest/700450">比赛链接1</a><br><a href="https://vjudge.net/contest/700538">比赛链接2</a></p>
<h2 id="1948B-Array-Fix"><a href="#1948B-Array-Fix" class="headerlink" title="1948B-Array Fix"></a>1948B-Array Fix</h2><ul>
<li>题意：给定一个长度为 $n\le 50$ 数组，数组的数 $a_i\le 99$，给出操作：把一个数拆成每一位的组成，比如 $45$ 可以拆成 $4$ 和 $5$。问有没有一种操作方式使得数组单调不减。</li>
<li>思路：分类讨论：</li>
</ul>
<ol>
<li>如果能拆（十位的数小于等于个位的数），且拆完之后能满足单调不减的条件，此时就拆，<strong>然后记录个位的数</strong>。</li>
<li>如果不能拆但本身就满足性质，此时就记录这个数字。</li>
<li>如果能拆但不管拆了还是不拆都不能使得数组单调不减，此时就输出 <code>NO</code>。</li>
</ol>
<blockquote>
<p>卡在：粗体的地方露考虑就开始看解题（<del>因为看到时间不够就红温看解题了</del> -&gt; 不允许这种情况出现），我其他都想明白了，也写在纸上了（以后这种操作多进行）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        string p=<span class="built_in">to_string</span>(w[i]);</span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;lst)&#123;</span><br><span class="line">            NO;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.sz==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">0</span>]&lt;=p[<span class="number">1</span>]&amp;&amp;p[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&gt;=lst)&#123;</span><br><span class="line">                lst=p[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if()</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;lst)&#123;</span><br><span class="line">                NO;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lst=w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YES;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1946B-Maximum-Sum"><a href="#1946B-Maximum-Sum" class="headerlink" title="1946B-Maximum Sum"></a>1946B-Maximum Sum</h2><ul>
<li>题意：给定一个数组，你能进行 $k$ 次操作，每次操作可以让选出的子序列之和放入数组的<strong>任意位置</strong>。问经过 $k$ 次操作得到的数组的最大的和是多少。</li>
<li>思路：很简单，就简单的dp。求出最长的子段和，然后把这个值放在最长子段和的末尾，然后依次放，我们会发现，在最长子段和的末尾的数字是 <code>mx 2mx 4mx 8mx ...</code>，然后这个可以用等比数列前 $n$ 项和公式求出或暴力求解。</li>
</ul>
<blockquote>
<p>卡在：题目看错了，没有注意到任意位置，我以为只能插在数组的末尾。（<del>插在末尾可以出一道题</del>）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>]+w[i],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mx=<span class="built_in">max</span>(mx,*<span class="built_in">max_element</span>(f.<span class="built_in">begin</span>()<span class="number">+1</span>,f.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=(s[n]+mod)%mod;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=mx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        ans=(ans+t+mod)%mod;</span><br><span class="line">        t=(t*<span class="number">2</span>%mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1923B-Monsters-Attack"><a href="#1923B-Monsters-Attack" class="headerlink" title="1923B-Monsters Attack!"></a>1923B-Monsters Attack!</h2><ul>
<li>题意：坐标轴上有 $n$ 个怪物，给出怪物的坐标以及生命值。你在坐标原点，然后你每次能射出 $\le k$ 个子弹去攻击怪物，问在这种情况下能不能把怪物给干掉。</li>
<li>思路：首先，我们发现怪物不管在正半轴还是负半轴都是一样的，不妨都放在正半轴。然后我们发现题目的数据范围给的很巧 $x_i,y_i\le n$，<strong>这意味着什么？意味着我们可以用桶来装</strong>。然后我们直接枚举时间即可。</li>
</ul>
<blockquote>
<p>卡在：我没有注意到粗体的想法，然后想了很复杂的东西，就是我当时想的是枚举怪物来做。真憨了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)b[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;x[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)b[<span class="built_in">abs</span>(x[i])]+=w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t+=k;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;b[i])&#123;</span><br><span class="line">            NO;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t-=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1914C-Quests"><a href="#1914C-Quests" class="headerlink" title="1914C-Quests"></a>1914C-Quests</h2><ul>
<li>题意：有 $n$ 个任务。第一个任务可以直接完成。后面的每个任务都需要前面的任务都至少完成一次才能完成。一个任务第一次完成的奖励是 $a_i$，之后每次完成的奖励是 $b_i$。你最多只能完成 $k$ 个任务。请最大化奖励。</li>
<li>思路：我们发现一个很神奇的规律：假设我们剩下 $k-i$ 次操作，且如果 $b<em>j&gt;b</em>{j+1}$，然后如果我们选 $b<em>{j+1}$ 的话，那么此时 $b_j+a</em>{j+1}+(k-i-2)b<em>{j+1}$，而原来的操作是 $(k-i)b_j$，二者做差得到：$(k-i)b_j-b_j-a</em>{j+1}-(k-i-2)b<em>{j+1}=2b</em>{j+1}-b<em>j-a</em>{j+1}$ 这个意思是什么？说的是要不要往后走就得看这个的大小。因此我们可以枚举最后停留在第 $i$ 个位置，然后和是 $a_1+a_2+…+a_i+(k-i)b_i$。最后就是这些取最大值。</li>
</ul>
<blockquote>
<p>卡在：想到了前半部分，但没有发现我们居然可以枚举最后停留的位置。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="built_in">min</span>(n,k))&#123;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,b[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum+(k-i)*mx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1905B-Begginer’s-Zelda"><a href="#1905B-Begginer’s-Zelda" class="headerlink" title="1905B-Begginer’s Zelda"></a>1905B-Begginer’s Zelda</h2><ul>
<li>题意：给你一棵树，这棵树可以进行操作：选择树上两点 $(u,v)$，将 $(u,v)$ 缩点。换句话说就是把从 $u\rightarrow v$ 的路径全部删除，然后创建一个新的节点 $w$，然后，每个与从 $u\rightarrow v$ 路径上某个顶点相连的顶点 $s$ 将与顶点 $w$ 相连。</li>
<li>思路：我们通过枚举发现，只需要将任意两个叶子节点连起来就可以缩点，也就是说我们缩点都是把两个叶子节点给去掉。所以总的操作次数很明显就是叶子节点除二上取整。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">d</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        d[a]++,d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans+=(d[i]==<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans<span class="number">+1</span>)/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1899B-250-Thousand-Tons-of-TNT"><a href="#1899B-250-Thousand-Tons-of-TNT" class="headerlink" title="1899B-250 Thousand Tons of TNT"></a>1899B-250 Thousand Tons of TNT</h2><ul>
<li>题意：有 $n$ 个数需要分成 $k$ 组，当且仅当 $n \bmod k=0$，共分成 $k$ 组，你需要构造一个 k 使得分成的所有组中的最大值和最小值的绝对值之差最大。</li>
<li>思路：你要分成 $k$ 组，那么 $k$ 肯定就是 $n$ 的因数。那么我们就可以枚举 $n$ 的因数，注意枚举因数可以优化成 $O(\sqrt n)$，然后每次暴力维护最大最小值，时间复杂度是 $O(n)$，那么总的时间复杂度就是 $O(n\sqrt n)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n/i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mi=<span class="number">1e18</span>,mx=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">                mi=<span class="built_in">min</span>(mi,s[j]-s[j-i]);</span><br><span class="line">                mx=<span class="built_in">max</span>(mx,s[j]-s[j-i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">abs</span>(mx-mi));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i!=n/i)&#123;</span><br><span class="line">                mi=<span class="number">1e18</span>,mx=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n/i;j&lt;=n;j+=n/i)&#123;</span><br><span class="line">                    mi=<span class="built_in">min</span>(mi,s[j]-s[j-n/i]);</span><br><span class="line">                    mx=<span class="built_in">max</span>(mx,s[j]-s[j-n/i]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,<span class="built_in">abs</span>(mx-mi));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1920B-Summation-Game"><a href="#1920B-Summation-Game" class="headerlink" title="1920B-Summation Game"></a>1920B-Summation Game</h2><ul>
<li>题意：Alice 和 Bob 在玩神奇的游戏，Alice 先手，他每次可以移除最多 $k$ 个元素，而 Bob 最多能把 $x$ 个元素乘 $-1$。且 Alice 希望和最大，Bob希望和最小，问最后的和是多少。</li>
<li>思路：思路很清楚，Alice 肯定是把有负数的数删掉，这样能保证最大，而 Bob 肯定是尽可能把数变小，所以他肯定是把数大的 $x$ 个元素都乘 $-1$。就这样模拟下去即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,x)&#123;</span><br><span class="line">        <span class="type">int</span> sum=s[<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,n-i-y)];</span><br><span class="line">        sum+=-(s[n-i]-s[<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,n-i-y)]);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1891B-Deja-Vu"><a href="#1891B-Deja-Vu" class="headerlink" title="1891B-Deja Vu"></a>1891B-Deja Vu</h2><ul>
<li>题意：给你一个数组以及 $q$ 次修改，每次修改是把数组中能被 $2^x_i$ 整除的数加上 $2^{x_i-1}$。问最后的数组是什么？</li>
<li>思路：就单纯模拟，得知道 <strong>如果一个数是 $2^x$ 的倍数，那么只需要二进制的末尾有 $x-1$ 个 $0$ 即可。</strong> 而且我们发现如果这个数已经被小的 $x_i$ 修改了，此时它不可能被大的数修改。所以<strong>具备单调性</strong>。因此可以考虑暴力，因为 $x\le 30$，此时得根据单调性优化，因为查询中肯定有很多没有修改数组的操作。</li>
</ul>
<blockquote>
<p>因为上一道题秒杀，这一道题就飘了，写的非常非常长，我的思路就是去把所有 <code>lowbit(x)=x</code> 的数维护下来，但我没有发现如果一个数是 $2^x$ 的倍数，那么只需要二进制的末尾有 $x-1$ 个 $0$ 即可。（想错了）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=k)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]%(<span class="number">1</span>&lt;&lt;x)==<span class="number">0</span>)&#123;</span><br><span class="line">                w[i]+=(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k=x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;w[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1966B-Rectangle-Filling"><a href="#1966B-Rectangle-Filling" class="headerlink" title="1966B-Rectangle Filling"></a>1966B-Rectangle Filling</h2><ul>
<li>题意：如果矩阵中一对对角线的最远端点的颜色相同，此时整个矩阵的颜色都可以变成对角线的颜色。问最后是否都能变成相同颜色。</li>
<li>思路：最后是否能变相同颜色还是得看最外层四周颜色。我们发现如果四周都有一样的颜色那最终不管如何都是可以变成相同颜色的。</li>
</ul>
<blockquote>
<p>卡在：没有反过来想。思路可能过于复杂。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">visw</span><span class="params">(<span class="number">4</span>,<span class="number">0</span>)</span>,<span class="title">visb</span><span class="params">(<span class="number">4</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i][<span class="number">1</span>]==<span class="string">&#x27;W&#x27;</span>)visw[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(s[i][m]==<span class="string">&#x27;W&#x27;</span>)visw[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(s[i][<span class="number">1</span>]==<span class="string">&#x27;B&#x27;</span>)visb[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(s[i][m]==<span class="string">&#x27;B&#x27;</span>)visb[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>][i]==<span class="string">&#x27;W&#x27;</span>)visw[<span class="number">2</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(s[n][i]==<span class="string">&#x27;W&#x27;</span>)visw[<span class="number">3</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>][i]==<span class="string">&#x27;B&#x27;</span>)visb[<span class="number">2</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(s[n][i]==<span class="string">&#x27;B&#x27;</span>)visb[<span class="number">3</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(visw[<span class="number">0</span>]&amp;&amp;visw[<span class="number">1</span>]&amp;&amp;visw[<span class="number">2</span>]&amp;&amp;visw[<span class="number">3</span>]||(visb[<span class="number">0</span>]&amp;&amp;visb[<span class="number">1</span>]&amp;&amp;visb[<span class="number">2</span>]&amp;&amp;visb[<span class="number">3</span>]))&#123;</span><br><span class="line">        YES;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1857B-Maximum-Rounding"><a href="#1857B-Maximum-Rounding" class="headerlink" title="1857B-Maximum Rounding"></a>1857B-Maximum Rounding</h2><ul>
<li>题意：一个字符串四舍五入，注意，你可以操作很多次然后改变后的字符串是会发生变化的，意思就是：如果你修改了字符串你后面是可以用你修改过的字符串。然后问最大的字符串是多少。</li>
<li>思路：一个贪心的想法就是从低位往高位依次四舍五入，这样肯定能保证是最大的。然后这边用一个技巧就是，因为它有进位嘛，所以最高位我们就给它放一个 <code>0</code>。</li>
</ul>
<blockquote>
<p>卡在：题目看错了，我以为那个 $k$ 只能选一次。然后想着用高精度….。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27;0&#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    n=s.sz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;5&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> t=i<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">FOR</span>(j,i,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">                s[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(s[t]==<span class="string">&#x27;4&#x27;</span>)&#123;</span><br><span class="line">                s[t]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">            s[t]=<span class="built_in">char</span>(s[t]<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span>)cout&lt;&lt;s[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1820B-JoJo’s-Incredible-Adventures"><a href="#1820B-JoJo’s-Incredible-Adventures" class="headerlink" title="1820B-JoJo’s Incredible Adventures"></a>1820B-JoJo’s Incredible Adventures</h2><ul>
<li>题意：给你一个二进制，然后它每一次循环移动会构成一个矩阵，问是 <code>1</code> 的矩阵的最大面积。</li>
<li>思路：有移动，此时我们就把数组复制两遍，然后求最大连续 <code>1</code> 的长度。然后我们通过手摸例子发现，发现 $4$ 的是 $2×3$，$5$ 的是 $3×3$，$6$ 的是 $3×4$，$7$ 的是 $4×4$。设最大连续 <code>1</code> 的长度为 $mx$ 的话，此时如果 $mx\not=字符串长度$，答案就是 $(mx+2)/\times(mx+1)/2$，如果相等的话就是 $(mx/2)\times (mx/2)$。</li>
</ul>
<blockquote>
<p>卡在：公式算错了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    s=s+s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;0&#x27;</span>)ans=<span class="built_in">max</span>(ans,sum),sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> sum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans==s.sz)&#123;</span><br><span class="line">        cout&lt;&lt;(ans/<span class="number">2</span>)*(ans/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;(((ans<span class="number">+2</span>)/<span class="number">2</span>)*((ans<span class="number">+1</span>)/<span class="number">2</span>))&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1788B-Sum-of-Two-Numbers"><a href="#1788B-Sum-of-Two-Numbers" class="headerlink" title="1788B-Sum of Two Numbers"></a>1788B-Sum of Two Numbers</h2><ul>
<li>题意：给你两个数 $n$，要求你把它拆成两个数使得这两个数的数位和差不超过 $1$。</li>
<li>思路：分类讨论，如果 $n$ 是偶数，那么答案就是 <code>n/2 n/2</code>，如果 $n$ 是奇数，答案就是 <code>n/2 n/2+1</code>（此时是不存在 <code>x/2</code> 中末尾是 <code>9</code> 的），<strong>如果存在末尾是 <code>9</code> 的话，此时我们可以拿 <code>4</code> 和 <code>5</code> 来凑 <code>9</code>。也就是它有几个 <code>9</code> 就要去在上面加上其他数去调节。我们发现，要想满足条件，加的数就为 <code>4</code> 和 <code>5</code> 交替组成的数，打一个表，最后加上对应的数就行了。</strong></li>
</ul>
<blockquote>
<p>卡在：没有想到粗体部分。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">454</span>,<span class="number">5454</span>,<span class="number">45454</span>,<span class="number">545454</span>,<span class="number">4545454</span>,<span class="number">54545454</span>,<span class="number">454545454</span>&#125;;</span><br><span class="line"><span class="type">int</span> t,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> k=n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k%<span class="number">10</span>&lt;<span class="number">9</span>||n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;k&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;k&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;k<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> c=k;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(c&gt;<span class="number">0</span>&amp;&amp;c%<span class="number">10</span>==<span class="number">9</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            c/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;k+a[cnt]<span class="number">+1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;k-a[cnt]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>总结：我发现这种低于1200的题都有个明显的特点，它的思维要么是：<strong>正难则反、转换主元（意思就是不同的枚举对象会导致不同的视角，比如前面有一道题如果枚举的是怪物就特别复杂，如果枚举的时间就特别简单）、暴力枚举、前缀和、双指针、二分、位运算、数学（数论特别多，可能伴随着计算题，公式题）、贪心（这部分很不好说，贪心如果你想到点子上去就很快了）</strong>。</p>
<hr>
]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>VP Educational Codeforces Round 1</title>
    <url>/2025/02/26/VP-Educational-Codeforces-Round-1/</url>
    <content><![CDATA[<p>成果：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3oooxrkj.png" alt=""></p>
<h1 id="A-Tricky-Sum"><a href="#A-Tricky-Sum" class="headerlink" title="A. Tricky Sum"></a>A. Tricky Sum</h1><ul>
<li><p>题意：给定正整数 $n(n\le 10^9)$， $i\in [1,n]$，如果 $i$ 是 $2$ 的幂次，则减去 $i$ ，否则加上 $i$。</p>
</li>
<li><p>思路：因为 $n$ 不大，所以在 $n$ 的范围内 $2$ 的幂次比较少，这里可以暴力做。然后我们可以先算 $1+2+…+n$，这里用等差数列前 $n$ 项和，然后再减去两倍的二次幂。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tot=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        p+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    tot-=<span class="number">2</span>*p;</span><br><span class="line">    cout&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Queries-on-a-String"><a href="#B-Queries-on-a-String" class="headerlink" title="B. Queries on a String"></a>B. Queries on a String</h1><ul>
<li><p>题意：给定长度为 $10000$ 的字符串，一共进行 $m(m\le 300)$ 次操作，每次操作给定 $l,r,k(k\le 10^6)$，字符串的区间 $[l,r]$ 想右移动 $k$ 次，求最终的字符串。</p>
</li>
<li><p>思路：我们可以知道，一个字符串向右移动 $r-l+1$ 就是原串，又因为 $r-l+1$ 不大，然后就暴力的拼接字符串即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    n=s.sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,k;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="type">int</span> len=r-l<span class="number">+1</span>;</span><br><span class="line">        k%=len;</span><br><span class="line">        string p1=s.<span class="built_in">substr</span>(l<span class="number">-1</span>,len-k);</span><br><span class="line">        string p2=s.<span class="built_in">substr</span>(l+len-k<span class="number">-1</span>,k);</span><br><span class="line">        string p3=p2+p1;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=l<span class="number">-1</span>&amp;&amp;i&lt;=r<span class="number">-1</span>)&#123;</span><br><span class="line">                s[i]=p3[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Nearest-vectors"><a href="#C-Nearest-vectors" class="headerlink" title="C. Nearest vectors"></a>C. Nearest vectors</h1><ul>
<li><p>题意：给定 $n$ 个向量，输出形成的夹角最小的两个向量的编号。</p>
</li>
<li><p>思路：我们可以用 <code>atan2(y,x)</code> 来计算极角，然后对极角从小到大进行排序，两个极角相减就是夹角，如果极角相减为负数，此时就得加上 $2\pi$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">double</span> angle,x,y;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(angle==t.angle)<span class="keyword">return</span> id&lt;t.id;</span><br><span class="line">        <span class="keyword">return</span> angle&lt;t.angle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">double</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">double</span> angle=<span class="built_in">atan2</span>(y,x);</span><br><span class="line">        w[i]=&#123;angle,x,y,i<span class="number">+1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w,w+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ans=<span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">double</span> angle=(w[(i<span class="number">+1</span>)%n].angle-w[i].angle);</span><br><span class="line">        <span class="keyword">if</span>(angle&lt;<span class="number">0</span>)angle+=<span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;angle)&#123;</span><br><span class="line">            ans=angle;</span><br><span class="line">            t1=w[(i<span class="number">+1</span>)%n].id,t2=w[i%n].id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;t1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;t2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Igor-In-the-Museum"><a href="#D-Igor-In-the-Museum" class="headerlink" title="D. Igor In the Museum"></a>D. Igor In the Museum</h1><ul>
<li><p>题意：给定 $1000\times 1000$ 的网格，每个格子为空地或墙壁。对于每一片连通的空地，求这片空地与多少个墙壁联通。</p>
</li>
<li><p>思路：这里算答案很容易想到用 <code>bfs</code> 来做。但由于查询次数很多，万一所有查询都是查同一个点的话，那么会超时的。因此我们把空地连成一个连通块，然后放在数组里面，当且仅当数组没有数的时候我们再去查询。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="keyword">while</span>(q.sz)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x,y]=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">pb</span>(&#123;x,y&#125;);</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a=dx[i]+x,b=dy[i]+y;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>||b&lt;<span class="number">1</span>||a&gt;n||b&gt;m||vis[a][b])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[a][b]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">            vis[a][b]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:res)&#123;</span><br><span class="line">        S[x][y]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(!S[x][y])&#123;</span><br><span class="line">            <span class="built_in">work</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;S[x][y]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Chocolate-Bar"><a href="#E-Chocolate-Bar" class="headerlink" title="E. Chocolate Bar"></a>E. Chocolate Bar</h1><ul>
<li>题意：对于一个由 $n$ 行 $m$ 列个小格子组成的矩形，我们称之为一块巧克力。对于一块巧克力，我们可以横向或纵向一刀切割为两块子巧克力（小格子是原子性的，无法切割成两部分），每次切割开需要切开长度的平方的代价。给定一块至多 $30 \times 30$ 的巧克力，我们可以多次切割得到很多子巧克力，从其中选择一些巧克力，使得选择的巧克力总共恰好含有  $k(k \leq 50)$ 个小格子。寻求合法方案的最小代价。</li>
<li>思路：因为这里的 $n,m,k$ 都是 $100$ 以内的数，又因为你切某一行或后一列会对后续产生影响，因此考虑dp。设 $f<em>{i,j,k}$ 表示大小为 $i\times j$ 的巧克力中取出 $k$ 块的代价。状态转移：$f</em>{i,j,k}=\min(f<em>{b,j,a}+f</em>{i-b,j,k-a}+j<em>j),b\in [1,b)，f<em>{i,j,k}=\min(f</em>{i,c,a}+f_{i,j-c,k-a}+i</em>i,c\in [1,j)$。</li>
</ul>
<p>当然可以用五重for循环，也可以用记忆化搜索。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k||x*y==k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x*y&lt;k)<span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[x][y][k]!=<span class="number">-1</span>)<span class="keyword">return</span> f[x][y][k];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,x<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,y*y+<span class="built_in">calc</span>(x-i,y,k-j)+<span class="built_in">calc</span>(i,y,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,y<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,x*x+<span class="built_in">calc</span>(x,y-i,k-j)+<span class="built_in">calc</span>(x,i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y][k]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m][k]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Task = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">30</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,<span class="number">30</span>)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(k,<span class="number">1</span>,<span class="number">50</span>)&#123;</span><br><span class="line">                f[i][j][k]=<span class="built_in">calc</span>(i,j,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (cin &gt;&gt; Task; Task; Task--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Cut-Length"><a href="#F-Cut-Length" class="headerlink" title="F. Cut Length"></a>F. Cut Length</h1><ul>
<li><p>题意：给定一个由 $n ( n ≤ 1000 )$ 个点构成的多边形（可凹可凸），给出 $m (m \leq 100)$ 次询问， 每次询问给定一条直线，求直线与多边形公共部分的长度。</p>
</li>
<li><p>思路：<a href="https://www.luogu.com.cn/article/g4yis80c">来源且参考</a></p>
</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9xqimomd.png" alt=""></p>
<ul>
<li><ul>
<li>如果我们最终计算得到的答案大于 $0$，这意味着给定的直线必然与多边形的某些边有交点。我们可以通过向量的叉积来判断点在直线的位置：</li>
</ul>
</li>
<li>叉积为正，点在直线左侧</li>
<li>叉积为负，点在直线右侧</li>
<li><p>叉积为零，点在直线上</p>
</li>
<li><ul>
<li>当一条线段的两个端点位于直线的不同侧时（即一个点的叉积为正，另一个点的叉积为负），这条线段必然与直线相交。</li>
</ul>
</li>
<li><ul>
<li>我们考虑向量 $\overrightarrow{AQ’}$ 与 $\overrightarrow{AP}$ 和 $\overrightarrow{AB}$ 的叉积关系：</li>
</ul>
</li>
</ul>
<ol>
<li>$\overrightarrow{AQ’}\times\overrightarrow{AP}=2S_{\triangle{APQ’}}$ </li>
<li>$\overrightarrow{AQ’}\times\overrightarrow{AB}=2S_{\triangle{ABQ’}}$</li>
</ol>
<ul>
<li><ul>
<li>由于三角形 $\triangle<em>{APQ’}$ 和 $\triangle</em>{ABQ’}$ 共用底边 $AQ’$，它们的面积比等于高的比值，即：</li>
</ul>
</li>
</ul>
<p>$\frac{S<em>{\triangle{APQ’}}}{S</em>{\triangle{ABQ’}}} = \frac{h_P}{h_B}$</p>
<p>其中 $h_P$ 和 $h_B$ 分别是点 $P$ 和点 $B$ 到直线 $AQ’$ 的距离。</p>
<ul>
<li><ul>
<li>因为 $AQ’$ 平行于 $PQ$（记作 $AQ’\parallel PQ$），所以点 $A$ 到直线 $AQ’$ 的距离等于点 $P$ 到直线 $PQ$ 的距离。根据相似三角形性质：</li>
</ul>
</li>
</ul>
<p>$\frac{|AM|}{|AB|} = \frac{\overrightarrow{AQ’}\times\overrightarrow{AP}}{\overrightarrow{AQ’}\times\overrightarrow{AB}}$</p>
<p>这个比值就是我们要记录的边 $PQ$ 的贡献值。</p>
<ul>
<li><ul>
<li>我们使用最小堆（小根堆）来存储所有有贡献的边，每条边用一个二元组（pair）表示：</li>
</ul>
</li>
<li><code>first</code>：表示该边的贡献值</li>
<li><code>second</code>：表示相对位置，计算方式为 $r_{i+1}-r_i$<ul>
<li>当点 $i$ 在直线左边时，$r_i=-1$</li>
<li>当点 $i$ 在直线右边时，$r_i=1$</li>
<li>当点 $i$ 在直线上时，$r_i=0$</li>
</ul>
</li>
</ul>
<p>维护一个变量 $sum$ 表示 <code>second</code> 的前缀和。当 $sum \neq 0$ 时，表示当前段落位于多边形内部。</p>
<ul>
<li><ul>
<li>设当前考虑的边的两个端点分别是 $M$ 和 $N$，则：</li>
</ul>
</li>
<li>$|AM| = first_i$</li>
<li>$|AN| = first_{i+1}$</li>
<li>边 $MN$ 的贡献值为 $first_{i+1}-first_i$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/uasuz2jm.png" alt=""></li>
<li><ul>
<li>将所有有效贡献值求和后，再乘以 $|AB|$ 即可得到最终答案。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    Point <span class="keyword">operator</span> +(Point t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x+t.x,y+t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-t.x,y-t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> *(<span class="type">int</span> t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x*t,y*t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="type">int</span> t)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x/t,y/t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x-y)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dist</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx=a.x-b.x;</span><br><span class="line">    <span class="type">double</span> dy=a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getLineIntersection</span><span class="params">(Point p1,Point v1,Point p2,Point v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cross</span>(v2,p2-p1)/<span class="built_in">cross</span>(v1,v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">work</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">    Point v=B-A;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt;&gt;pos;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> s1=<span class="built_in">sign</span>(<span class="built_in">cross</span>(v,(w[i]-A)));</span><br><span class="line">        <span class="type">int</span> s2=<span class="built_in">sign</span>(<span class="built_in">cross</span>(v,(w[(i<span class="number">+1</span>)%n]-A)));</span><br><span class="line">        <span class="keyword">if</span>(s1==s2)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">double</span> p=<span class="built_in">getLineIntersection</span>(A,v,w[i],w[(i<span class="number">+1</span>)%n]-w[i]);</span><br><span class="line">        pos.<span class="built_in">pb</span>(&#123;p,s1-s2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(pos));</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,pos.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        t+=pos[i].se;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            res+=pos[i<span class="number">+1</span>].fi-pos[i].fi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res*(<span class="built_in">get_dist</span>(A,B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].x&gt;&gt;w[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        Point A,B;</span><br><span class="line">        cin&gt;&gt;A.x&gt;&gt;A.y&gt;&gt;B.x&gt;&gt;B.y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.20Lf\n&quot;</span>,<span class="built_in">work</span>(A,B));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>VP 2024 ICPC National Invitational Collegiate Programming Contest, Wuhan Site</title>
    <url>/2025/03/09/VP-2024%20ICPC%20National%20Invitational%20Collegiate%20Programming%20Contest,%20Wuhan%20Site/</url>
    <content><![CDATA[<h1 id="B-Countless-Me"><a href="#B-Countless-Me" class="headerlink" title="B. Countless Me"></a>B. Countless Me</h1><ul>
<li>题意：给你一个数组，最多进行以下操作 $n$ 次：把 $a_i=a_i-x,a_j=a_j+x$。此时要最小化 $a_1|a_2|…|a_n$ 的值。</li>
<li>思路：我们发现这样操作我们的总值是不变的。此时这里就会有一个错误思路：就是取平均数，但你会发现过不了测试点：<code>7 7 8 8</code>，答案是 $10$。此时我们只能按位分析，从高位开始，如果总值减去这一位后面全为 $1$ 都能放，此时我们就让这一位放 $1$（这种贪心就能保证 $1$ 最少），但可能不能完全放下，因此放的数量就是 $\min(n,sum/bit)$，其中 $bit$ 就是 $1&lt;&lt;i$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],sum+=w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">0</span>,<span class="number">30</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;((<span class="number">1ll</span>&lt;&lt;i)<span class="number">-1</span>)*n)&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="built_in">min</span>(n,sum/(<span class="number">1ll</span>&lt;&lt;i));</span><br><span class="line">            ans|=(<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">            sum-=(<span class="number">1ll</span>&lt;&lt;i)*num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="D-ICPC"><a href="#D-ICPC" class="headerlink" title="D. ICPC"></a>D. ICPC</h1><ul>
<li>题意：求 $ \oplus <em>{i=1}^{n}(i+\oplus</em>{j=1}^{2n}jF<em>{i,j})$ 的值。令 $F</em>{i,j}$ 表示幽幽子从第 $i$ 个座位开始移动 $j$ 秒后可以消耗的菜肴的最大总量。</li>
<li>思路：我们可以发现很简单的二维 dp。对于所有移动，要么一直走到头不折返，要么只折返一次然后走到头。设 $f<em>{s,t}$ 为在位置 $s$ 移动不超过 $t$ 次且不折返的吃掉菜肴的最大值，先利用前缀和可以简单算出 $f</em>{s,t}$ 对于折返一次的走法，设在走 $i$ 步后折返，则最大值为 $f_{i+s,t-i}$。那么知道了这些这道题就很好写了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],s[N],f[N][N*<span class="number">2</span>],g[N][N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>,i-j),r=<span class="built_in">min</span>(n,i+j);</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(s[i]-s[l<span class="number">-1</span>],s[r]-s[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">            g[i][j]=<span class="built_in">max</span>(g[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">+1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">            res^=j*<span class="built_in">max</span>(f[i][j],g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans^=(res+i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="E-Boomerang"><a href="#E-Boomerang" class="headerlink" title="E. Boomerang"></a>E. Boomerang</h1><ul>
<li>题意：给你一张图，给你谣言的传播源头以及辟谣的开始时间，问你在辟谣传播的不同速度下在哪里可以阻止谣言的传播。</li>
<li>思路：我们发现，谣言要传播完全，肯定会在树的直径上传播，因此我们得动态维护树的直径。也就是说，从直径中间开始辟谣是最好的。此时动态维护树的直径我们可以用 $LCA$ 即可，每次把下一层的点加入，当加入一个新的点的时候，直径只有三种情况，假设新加入的点是 $x$，原直径两端是$u, v$，那么新的直径只会是 $(u, v), (u, x), (v. x)$,  不断扩大树的直径，然后记录每一秒的树的直径，然后开始枚举秒数，最大不会超过 $n + t0$，为什么？因为时间是随着 $k$ 的增大逐渐递减，所以枚举秒数，当就理论上扩散的深度比直径/2大，ans—，否则输出ans。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> r,t0;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">22</span>],dep[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[fa]<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">20</span>)&#123;</span><br><span class="line">        f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa)<span class="keyword">continue</span>;</span><br><span class="line">        f[j][<span class="number">0</span>]=u;</span><br><span class="line">        <span class="built_in">dfs1</span>(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">0</span>,<span class="number">20</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[f[x][i]]&gt;=dep[y])&#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">0</span>,<span class="number">20</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i])&#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">lca</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> dep[x]+dep[y]<span class="number">-2</span>*dep[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;r&gt;&gt;t0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(r,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt;<span class="built_in">d</span>(n<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>]=&#123;<span class="number">1</span>,r,r&#125;;</span><br><span class="line"></span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,r&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [deep,u]=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> now=<span class="built_in">max</span>(d[deep],d[deep<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ud=<span class="built_in">dist</span>(now[<span class="number">1</span>],u)<span class="number">+1</span>,vd=<span class="built_in">dist</span>(now[<span class="number">2</span>],u)<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ud&gt;now[<span class="number">0</span>])&#123;</span><br><span class="line">            now=&#123;ud,u,now[<span class="number">1</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vd&gt;now[<span class="number">0</span>])&#123;</span><br><span class="line">            now=&#123;vd,u,now[<span class="number">2</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        d[deep]=<span class="built_in">max</span>(d[deep],now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==f[u][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;deep<span class="number">+1</span>,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)d[i][<span class="number">0</span>]=<span class="built_in">max</span>(d[i][<span class="number">0</span>],d[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=n+t0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(d[<span class="built_in">min</span>(n,ans)][<span class="number">0</span>]/<span class="number">2</span>&lt;=(ans<span class="number">-1</span>-t0)*i)ans--;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="F-Custom-Made-Clothes"><a href="#F-Custom-Made-Clothes" class="headerlink" title="F. Custom-Made Clothes"></a>F. Custom-Made Clothes</h1><ul>
<li>题意：给定一个 $n * n$ 的矩阵，矩阵的每个点大于等于它左边的和上边的点（如果存在），每次可以查询一个点的数字是不是小于等于给定的询问值，在 $50000$ 次查询中得出第 $k$ 大的数字。</li>
<li>思路：因为题目说左边小于右边，上面小于下面二分答案，每次查询从左下角开始，如果小于等于mid，往上移动，否则把这一列上面的数字的个数全部加上，否则左移。然后这里为了研究方便，我们是把第 $k$ 大的数转化成了 $n^2-k-1$ 小的数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    cin&gt;&gt;res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=n,b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(a&gt;=<span class="number">1</span>&amp;&amp;b&lt;=n)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">query</span>(a,b,x);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            sum+=a;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    k=n*n-k<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n*n<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="I-Cyclic-Apple-Strings"><a href="#I-Cyclic-Apple-Strings" class="headerlink" title="I. Cyclic Apple Strings"></a>I. Cyclic Apple Strings</h1><ul>
<li>题意：给定一个 $01$ 字符串，每次操作可以将这个字符串向左循环移动任意次数，求让这个字符串变成有序的需要最少几次操作。</li>
<li>思路：只需要计算 $01$ 的个数即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;s[i<span class="number">+1</span>]==<span class="string">&#x27;0&#x27;</span>)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="K-Party-Games"><a href="#K-Party-Games" class="headerlink" title="K. Party Games"></a>K. Party Games</h1><ul>
<li>题意：给定 $n$ 个整数从左到右排成一列，每次可以从两端拿走其中一个数字，如果数字被拿完了或者剩余的数字的异或和为 $0$，则当前操作无法进行，先手就失败了。</li>
<li>思路：就是典型的打表题目。<code>n % 4 == 0 || n % 4 == 1</code> 的情况下 <code>Fluttershy</code> 必胜，否则必败。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=x%<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(!t)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)<span class="keyword">return</span> x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">get</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Pinkie Pie&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>||n%<span class="number">4</span>==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Fluttershy&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Pinkie Pie&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="M-Merge"><a href="#M-Merge" class="headerlink" title="M. Merge"></a>M. Merge</h1><ul>
<li>题意：给定 $n$ 个数字，每次可以把绝对值差为 $1$ 的两个数字合并，求最终数字任意排序后最大字典序情况。</li>
<li>思路：我们知道，由于是绝对值差为 $1$ 的两个数字的合并（也就是自然数中连续两个数合并），所以一个为奇数，一个为偶数，每次取出最大的偶数合并，要不和 $x + 1$ 合并，要不和 $x - 1$ 合并，递归的取合并数字，如果需要的数字已经存在了，那就优先合成进去，然后再用小数字合成，可以发现， 奇数可以用一个奇数一个偶数合成，偶数除非本身就存在，否则无法合成，用 <code>map</code> 记录数字的数量来递归的合成即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;odd,even;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp[x])&#123;</span><br><span class="line">        mp[x]--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x1=x/<span class="number">2</span>,x2=x1<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(x2&amp;<span class="number">1</span>))<span class="built_in">swap</span>(x1,x2);</span><br><span class="line">    <span class="keyword">if</span>(!mp[x1])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        mp[x1]--;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(x2))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mp[x1]++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(w[i]&amp;<span class="number">1</span>))even.<span class="built_in">insert</span>(w[i]);</span><br><span class="line">        mp[w[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VI ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(even.sz)&#123;</span><br><span class="line">        <span class="type">int</span> t=*even.<span class="built_in">rbegin</span>();</span><br><span class="line">        even.<span class="built_in">erase</span>(even.<span class="built_in">find</span>(t));</span><br><span class="line">        <span class="keyword">if</span>(!mp[t])<span class="keyword">continue</span>;</span><br><span class="line">        mp[t]--;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(t<span class="number">+1</span>))&#123;</span><br><span class="line">            mp[<span class="number">2</span>*t<span class="number">+1</span>]++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(t<span class="number">-1</span>))&#123;</span><br><span class="line">            mp[<span class="number">2</span>*t<span class="number">-1</span>]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:mp)&#123;</span><br><span class="line">        <span class="keyword">while</span>(y--)&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(ans),<span class="built_in">greater</span>());</span><br><span class="line">    cout&lt;&lt;ans.sz&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title>VP Codeforces Round 786 (Div. 3)</title>
    <url>/2025/02/20/VP-Codeforces-Round-786-Div-3/</url>
    <content><![CDATA[<h1 id="A-Number-Transformation"><a href="#A-Number-Transformation" class="headerlink" title="A. Number Transformation"></a>A. Number Transformation</h1><ul>
<li>题意：给定两个整数 $x,y$，选择 $a,b$ 整数使得 $a\rightarrow b$。</li>
<li>思路：1.如果 $x=y$，输出 $3 \ 1$，如果 $x\not|y$，输出 $0 \ 0$，其他就直接输出 $k \ 1$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(y%x)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;3 1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k=y/x;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Dictionary"><a href="#B-Dictionary" class="headerlink" title="B. Dictionary"></a>B. Dictionary</h1><ul>
<li>题意：观察，求索引值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Word 1 : ab</span><br><span class="line">Word 2 : ac</span><br><span class="line">...</span><br><span class="line">Word 25 : az</span><br><span class="line">Word 26 : ba</span><br><span class="line">Word 27 : bc</span><br><span class="line">...</span><br><span class="line">Word 649 : zx</span><br><span class="line">Word 650 : zy</span><br></pre></td></tr></table></figure></li>
<li>思路：相同的字母会被舍去，因此如果前一个字母大于后一个字母的情况下，此时正常算，反之+1。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">string a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k=<span class="number">26</span>*(a[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)+a[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>-(a[<span class="number">1</span>]&gt;a[<span class="number">0</span>]?(a[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>):(a[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Infinite-Replacement"><a href="#C-Infinite-Replacement" class="headerlink" title="C. Infinite Replacement"></a>C. Infinite Replacement</h1><ul>
<li>题意：给一个只含小写字母 a 的字符串 s 和一个用来替换的字符串 t 。你可以将 s 中任意一个字母 a 用 t 来替换，替换的次数不限。对于每一个 s 和 t ，你可以得到几个不同的字符串？如果有无限个，输出 -1 。</li>
<li>思路：分类讨论：如果 $t=a$，此时不管怎样替换，$s$ 不会发生变化。如果 t 包含 a 这个字母的话，此时就是无限大，反之就是 $2^{(s.size())}$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s,t;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="string">&quot;a&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                f=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="number">1ll</span>&lt;&lt;s.<span class="built_in">size</span>();</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-A-B-C-Sort"><a href="#D-A-B-C-Sort" class="headerlink" title="D. A-B-C Sort"></a>D. A-B-C Sort</h1><ul>
<li>题意：你有三个数组 a,b,c，a 初始有 n 个元素，b 和 c 初始是空的。你可以执行以下算法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步，当 a 不为空，重复从 a 取出末尾的元素并将其插入 b 的正中间。如果 b 当前有奇数个元素，可以选择将 a 中取出的元素插入 b 正中间元素紧挨着的左侧或右侧的空位上。</span><br><span class="line"></span><br><span class="line">在此之后 a 变成空的，b 有 n 个元素。</span><br><span class="line"></span><br><span class="line">第二步，当 b 不为空，重复取出 b 正中间的元素并将其插入 c 的末尾。如果 b 当前有偶数个元素，可以选择从正中间两个元素中取出一个。</span><br><span class="line"></span><br><span class="line">在此之后 b 变成空的，c 有 n 个元素。</span><br></pre></td></tr></table></figure></li>
<li>思路：容易看出，当 b 长度为奇数时，将 a 数组中的元素插入 b 数组，有 2 种情况，可以插在前面，也可以插在后面。然后从 b 数组中取出，放到 c 数组时，与上面的情况，要么这两个数非降序，要么反之。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c的任意两个相邻的数就是a中相邻的数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=(n&amp;<span class="number">1</span>)<span class="number">+1</span>;i-=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;w[i<span class="number">-1</span>])<span class="built_in">swap</span>(w[i],w[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;w[i<span class="number">+1</span>])f=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(f?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Breaking-the-Wall"><a href="#E-Breaking-the-Wall" class="headerlink" title="E. Breaking the Wall"></a>E. Breaking the Wall</h1><p>- </p>
]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>VP abc375</title>
    <url>/2025/03/07/VP-abc375/</url>
    <content><![CDATA[<h1 id="A-Seats"><a href="#A-Seats" class="headerlink" title="A. Seats"></a>A. Seats</h1><ul>
<li>题意：简单的模拟题，模拟题目空位置就是两边是 <code>#</code> 中间是 <code>.</code> 的情况。</li>
<li>思路：模拟<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.sz<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;s[i<span class="number">-1</span>]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;s[i<span class="number">+1</span>]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="B-Traveling-Takahashi-Problem"><a href="#B-Traveling-Takahashi-Problem" class="headerlink" title="B. Traveling Takahashi Problem"></a>B. Traveling Takahashi Problem</h1><ul>
<li>题意：求在笛卡尔坐标系中求欧几里得距离的和。</li>
<li>思路：模拟<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    n++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans+=<span class="built_in">dist</span>(x[i],y[i],x[i<span class="number">-1</span>],y[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.20lf&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="C-Spiral-Rotation"><a href="#C-Spiral-Rotation" class="headerlink" title="C. Spiral Rotation"></a>C. Spiral Rotation</h1><ul>
<li>题意：给你一个 $N$ 行 $N$ 列的矩阵，矩阵由两种字符 <code>#</code> 和 <code>.</code> 组成。当一个正整数 $i=1,2,3,…,N/2$ 时，对于任意一个在 $i$ 到 $N+1−i$ 之间的整数对 $(x,y)$，把矩阵中 $(y,N+1−x)$ 格子的颜色改成 $(x,y)$ 格子的颜色。</li>
<li>思路：根据样例观察，我们可以发现：我们可以按每层分析的方法，也就是从外层到内层分析。发现一个很神奇的性质：层 $i$ 就是顺时针旋转 $i\times 90$ °。</li>
</ul>
<blockquote>
<p>注意：我们这里判断某个点在哪个层上用 <code>min(&#123;i,n-i+1,j,n-j+1&#125;)</code>。为什么呢？层是按到四周的距离最小值来判定的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="built_in">min</span>(&#123;i,n-i<span class="number">+1</span>,j,n-j<span class="number">+1</span>&#125;)%<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!k)cout&lt;&lt;s[i][j];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)cout&lt;&lt;s[n-j<span class="number">+1</span>][i];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">2</span>)cout&lt;&lt;s[n-i<span class="number">+1</span>][n-j<span class="number">+1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">3</span>)cout&lt;&lt;s[j][n-i<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="D-ABA"><a href="#D-ABA" class="headerlink" title="D. ABA"></a>D. ABA</h1><ul>
<li>题意：给定一个字符串 $S$，让你在其中选择三个严格递增的下标，$(i,j,k)$ 使得 $S_i + S_j + S_k$ 连接在一起的字符串是一个回文串，有多少种选法。</li>
<li><p>思路：通过观察我们可以知道，我们只需要首尾相同即可。此时问题就转化成找每一对相同的数，并计算下标的差减一（就是中间有多少个数）然后求和。</p>
</li>
<li><p>思路2：我们可以通过列式得到：（其实我们可以先写暴力方法）：</p>
</li>
</ul>
<p>暴力肯定是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for(k in 1...N)</span><br><span class="line">    for(i in 1...k-1)</span><br><span class="line">        if(s[i]==s[k])</span><br><span class="line">            ans+=k-i-1</span><br><span class="line"></span><br><span class="line">那么可以简化成</span><br><span class="line">for(k in 1...N)</span><br><span class="line">    ans+=(k-i1-1)+(k-i2-1)+(k-i3-1)+...</span><br><span class="line"></span><br><span class="line">然后我们可以合并</span><br><span class="line"></span><br><span class="line">ans+=(k-1)*（有多少个满足条件的i）-(i1+i2+i3+...)</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.sz;</span><br><span class="line"></span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,0,26)l[i][j]=l[i-1][j];</span><br><span class="line">        l[i][s[i]-&#x27;A&#x27;]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FORD(i,1,n)&#123;</span><br><span class="line">        FOR(j,0,26)r[i][j]=r[i+1][j];</span><br><span class="line">        r[i][s[i]-&#x27;A&#x27;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        FOR(j,0,26)ans+=l[i-1][j]*r[i+1][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-3-Team-Division"><a href="#E-3-Team-Division" class="headerlink" title="E. 3 Team Division"></a>E. 3 Team Division</h1><ul>
<li>题意：有 $n(n\le 100)$ 个人，每个人最先都有一个小组，每个人有一个分数 $b_i$，现在要求把他们重新划分，是的小组内的总分数都相同，只有 $3$ 个小组，如果无解，输出 <code>-1</code>。</li>
<li>思路：此时我们就可以考虑dp了，我们最开始肯定想的是这样的dp，设 $f_{i,a_1,a_2,a_3}$ 为前 $i$ 个人中选出来一队的实力是 $a_1$ ，二队实力是 $a_2$，三队的实力是 $a_3$。但这样会爆空间。我们发现，如果两个队伍的实力确定下来，那么第三个实力也就确定下来了。状态转移方程比较好写。</li>
</ul>
<blockquote>
<p>注意：最终的实力是一样的，所以要均分。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i]&gt;&gt;b[i],s[i]=s[i<span class="number">-1</span>]+b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[n]%<span class="number">3</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=s[n]/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,t)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(k,<span class="number">0</span>,t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=b[i])&#123;</span><br><span class="line">                    f[i][j][k]=<span class="built_in">min</span>(f[i][j][k],f[i<span class="number">-1</span>][j-b[i]][k]+(a[i]!=<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=b[i])&#123;</span><br><span class="line">                    f[i][j][k]=<span class="built_in">min</span>(f[i][j][k],f[i<span class="number">-1</span>][j][k-b[i]]+(a[i]!=<span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i]-j-k&gt;=b[i])&#123;</span><br><span class="line">                    f[i][j][k]=<span class="built_in">min</span>(f[i][j][k],f[i<span class="number">-1</span>][j][k]+(a[i]!=<span class="number">3</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[n][t][t]&lt;=n)&#123;</span><br><span class="line">        cout&lt;&lt;f[n][t][t]&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Road-Blocked"><a href="#F-Road-Blocked" class="headerlink" title="F. Road Blocked"></a>F. Road Blocked</h1><ul>
<li>题意：给定一个无向带权图，每次有两种操作，一种是删除一条边，一种是查询两点之间的最短路。</li>
<li>思路：这里又是删边操作，此时我们又是把它转化成建边操作。（也就是离线操作）。这里要求每个最短路，而且数据规模很小，因此我们可以考虑用 <code>flord</code>。也就是先用 <code>flord</code> 预处理出每两点间的距离最小值（这里要注意，我们维护的是总的图减去所有查询被删除的边剩下的边的最短路）。然后我们要新增这条边，此时最短路无非就两种情况：变和不变。因为最短路可能经过这条边也可能不经过这条边。此时<strong>每次加入一条新边 u—v ，那么对于 $x\rightarrow y$，如果最短路距离发生变化，那么其新的最短路一定经过 u—v 。因此，其新的最短路要么是 x—u—v—y，要么是 x—v—u—y，分类讨论即可</strong>。（在代码中体现就是dist[x][y]=dist[x][u]+c+dist[v][y] 或者是 dist[x][y]=dist[x][v]+c+dist[u][y]）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,val;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span>&#123;</span><br><span class="line">    <span class="type">int</span> op,x,y;</span><br><span class="line">&#125;Q[M];</span><br><span class="line"><span class="type">int</span> ans[M];</span><br><span class="line"><span class="type">bool</span> vis[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)d[i][i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        e[i]=&#123;x,y,z&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Q[i].op=a,Q[i].x=b;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>)vis[b]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> cin&gt;&gt;Q[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            d[e[i].x][e[i].y]=<span class="built_in">min</span>(d[e[i].x][e[i].y],e[i].val);</span><br><span class="line">            d[e[i].y][e[i].x]=<span class="built_in">min</span>(d[e[i].y][e[i].x],e[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(k,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Q[i].op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> j=Q[i].x;</span><br><span class="line">            d[e[j].x][e[j].y]=<span class="built_in">min</span>(d[e[j].x][e[j].y],e[j].val);</span><br><span class="line">            d[e[j].y][e[j].x]=<span class="built_in">min</span>(d[e[j].y][e[j].x],e[j].val);</span><br><span class="line">            <span class="built_in">FOR</span>(u,<span class="number">1</span>,n)&#123;</span><br><span class="line">                <span class="built_in">FOR</span>(v,<span class="number">1</span>,n)&#123;</span><br><span class="line">                    d[u][v]=<span class="built_in">min</span>(&#123;d[u][v],d[u][e[j].x]+e[j].val+d[e[j].y][v],d[u][e[j].y]+e[j].val+d[e[j].x][v]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[++cnt]=d[Q[i].x][Q[i].y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,cnt)cout&lt;&lt;(ans[i]&gt;=<span class="number">0x3f3f3f3f3f3f3f3fll</span>?<span class="number">-1</span>:ans[i])&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="G-Road-Blocked-2-多模哈希用法"><a href="#G-Road-Blocked-2-多模哈希用法" class="headerlink" title="G. Road Blocked 2 多模哈希用法"></a>G. Road Blocked 2 多模哈希用法</h1><ul>
<li>题意：给定你一个图，让你求出 $1$ 到 $n$ 的最短路的必经过边，如果这条边是必经边，输出 <code>Yes</code>，否则输出 <code>No</code>。</li>
<li>思路：这道题给的图就是最短路图，我们知道：在最短路图随便走，得到的一定最短路。然后题目要问如果在最短路图中删掉一条边，最短路是不是发生变化了。那我们可以这样做：<strong>我们只需要比较“经过这条边的最短路的数量”和“总的最短路数量”是否一致，那我们如何求前者呢？跑两次最短路，第一次以 $1$ 为起点，统计从 $1$ 到各点的最短路和数量；第二次从 $n$ 开始统计。那么，经过 u—v 的最短路数量（假设 dis(1-&gt;u)<dis(1->v)）就是 1-&gt;u 的最短路数量乘以 v-&gt;n 的最短路数量。还有一个问题就是，最短路数量肯定很大，不好比较，这样可能会导致错误。因此我们可以取多次模数。也就是“多模哈希”</strong></li>
</ul>
<blockquote>
<p>多模哈希顾名思义就是多个模数，注意我们一般取 $3$ 个模数，然后用于很大的数比较是否相等的情况下用，它的模板如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD0=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD1=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD2=<span class="number">1000000009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MOD</span>&#123;</span><br><span class="line">    <span class="type">int</span> x0,x1,x2;</span><br><span class="line">    <span class="built_in">MOD</span>():<span class="built_in">x0</span>(<span class="number">0</span>),<span class="built_in">x1</span>(<span class="number">0</span>),<span class="built_in">x2</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">MOD</span>(<span class="type">int</span> x0,<span class="type">int</span> x1,<span class="type">int</span> x2):<span class="built_in">x0</span>(x0),<span class="built_in">x1</span>(x1),<span class="built_in">x2</span>(x2)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MOD <span class="keyword">operator</span>+(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x0+b.x0)%MOD0,(a.x1+b.x1)%MOD1,(a.x2+b.x2)%MOD2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MOD <span class="keyword">operator</span>-(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x0-b.x0+MOD0)%MOD0,(a.x1-b.x1+MOD1)%MOD1,(a.x2-b.x2+MOD2)%MOD2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MOD <span class="keyword">operator</span>*(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x0*b.x0)%MOD0,(a.x1*b.x1)%MOD1,(a.x2*b.x2)%MOD2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x0==b.x0&amp;&amp;a.x1==b.x1&amp;&amp;a.x2==b.x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是总代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD0=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD1=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD2=<span class="number">1000000009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MOD</span>&#123;</span><br><span class="line">    <span class="type">int</span> x0,x1,x2;</span><br><span class="line">    <span class="built_in">MOD</span>():<span class="built_in">x0</span>(<span class="number">0</span>),<span class="built_in">x1</span>(<span class="number">0</span>),<span class="built_in">x2</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">MOD</span>(<span class="type">int</span> x0,<span class="type">int</span> x1,<span class="type">int</span> x2):<span class="built_in">x0</span>(x0),<span class="built_in">x1</span>(x1),<span class="built_in">x2</span>(x2)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MOD <span class="keyword">operator</span>+(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x0+b.x0)%MOD0,(a.x1+b.x1)%MOD1,(a.x2+b.x2)%MOD2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MOD <span class="keyword">operator</span>-(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x0-b.x0+MOD0)%MOD0,(a.x1-b.x1+MOD1)%MOD1,(a.x2-b.x2+MOD2)%MOD2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MOD <span class="keyword">operator</span>*(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x0*b.x0)%MOD0,(a.x1*b.x1)%MOD1,(a.x2*b.x2)%MOD2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MOD&amp; a,<span class="type">const</span> MOD&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x0==b.x0&amp;&amp;a.x1==b.x1&amp;&amp;a.x2==b.x2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;PII&gt;g[N];</span><br><span class="line"><span class="type">int</span> d1[N],d2[N];</span><br><span class="line">MOD c1[N],c2[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijistra</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> d[],MOD c[])</span></span>&#123;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">    <span class="function">VI <span class="title">vis</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)d[i]=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    c[s]=<span class="built_in">MOD</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [dd,ver]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dd!=d[ver])<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,w]:g[ver])&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j]&gt;d[ver]+w)&#123;</span><br><span class="line">                d[j]=d[ver]+w;</span><br><span class="line">                c[j]=c[ver];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;d[j],j&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[j]==d[ver]+w)&#123;</span><br><span class="line">                c[j]=c[j]+c[ver];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">        w[i]=&#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijistra</span>(<span class="number">1</span>,d1,c1);</span><br><span class="line">    <span class="built_in">dijistra</span>(n,d2,c2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [a,b,c]=w[i];</span><br><span class="line">        <span class="keyword">if</span>(d1[a]+c+d2[b]==d1[n])&#123;</span><br><span class="line">            <span class="keyword">if</span>(c1[a]*c2[b]==c1[n])&#123;</span><br><span class="line">                Yes;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                No;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d1[b]+c+d2[a]==d1[n])&#123;</span><br><span class="line">            <span class="keyword">if</span>(c1[b]*c2[a]==c1[n])&#123;</span><br><span class="line">                Yes;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                No;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            No;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>收获：收获满满啊，收获了多模哈希写法以及贡献法独特的暴力写法再统计规律的写法。最短路的规律性总结。</p>
</blockquote>
]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>abc137</title>
    <url>/2025/01/13/abc137/</url>
    <content><![CDATA[<h1 id="A-x"><a href="#A-x" class="headerlink" title="A. +-x"></a>A. +-x</h1><ul>
<li>模拟题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(&#123;a+b,a*b,a-b&#125;)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-One-Clue"><a href="#B-One-Clue" class="headerlink" title="B. One Clue"></a>B. One Clue</h1><ul>
<li>模拟题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x-k<span class="number">+1</span>;i&lt;=x+k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Green-Bin"><a href="#C-Green-Bin" class="headerlink" title="C. Green Bin"></a>C. Green Bin</h1><ul>
<li><p>题意：给出变位词概念，叫我们求出变位词对的个数。</p>
</li>
<li><p>解题：变位词本质上就是排完序是同一个单词，然后通过交换其中几个词。题目要求变位词对的个数，我们可以先统计排完序单词的个数，然后按照组合数 $C_{cnt}^{2}$ 来计算最后的答案即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        S[s]++;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [x,y]:S)ans+=(y<span class="number">-1</span>)*y/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Summer-Vacation"><a href="#D-Summer-Vacation" class="headerlink" title="D. Summer Vacation"></a>D. Summer Vacation</h1><ul>
<li><p>题意：有 $n$ 个工会，如果你接受第 $i$ 个工作并完成它，你将在完成当天之后的 $A_i$ 天内获得奖励 $B_i$ 并且每天最多只能接受并完成一个工作，同时不能重新接受已经完成过的工作，求不迟于 $M$ 天内能获得的最大奖励数。</p>
</li>
<li><p>解题：要求最大奖励数，其实可以想到：尽可能选时间短的奖励多的，因此可以先对 $A_i$ 从小到大排序。那么之后我们肯定是尽可能选奖励多的，因此我们可以开一个大顶堆，把所有截至到第 $i$ 天之前的奖励数全部放入堆中，然后取出最大的即可。这样就能保证我们的贪心是正确的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].x&gt;&gt;w[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;=n&amp;&amp;w[t].x&lt;=i)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(w[t++].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res+=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是具有二维变量的贪心，有的时候可能是用 <code>dp</code> 去做，但本题数据规模较大，因此得想到贪心，这种常见的思路一般是先定一个顺序然后另一个顺序可以用类似 <strong>双指针</strong>、<strong>单调队列</strong>、<strong>堆</strong> 等优化和计算。</p>
</blockquote>
<h1 id="E-Coins-Respawn"><a href="#E-Coins-Respawn" class="headerlink" title="E. Coins Respawn"></a>E. Coins Respawn</h1><ul>
<li><p>题意：给你一张图，你从 $1$ 号点出发，要到 $n$ 号点，图上的每一条边都有硬币，你要收集它们，当然当你收集了一次之后在这条边又会出现这个硬币。最后到 $n$ 号节点时要上交 $T\times P$ 个硬币，其中 $T$ 是走的时间，$P$ 是给定值。求最后获得到的硬币数最多是多少。</p>
</li>
<li><p>思路：因为最后都要上交 $T\times P$ 个硬币，那不如简化运算，然所有权值都减去 $P$，这样最后就可以不用上交了。然后我们再考虑什么情况下会无解，也就是答案无限大的情况，那就是有一个边权和为正数的环与<strong>点 $n$ 联通</strong>，这里就先建立个反图，从 $n$ 出发，标记能走到的点，然后 spfa 的时候不去松弛它们，这样就能保证用spfa判断正环的时候包括 $n$ 这个点了（<strong>很重要，要不然过不了第三个测试点</strong>）。然后要求最大的答案，此时就是求从 $1\rightarrow n$ 的最长路，注意这里有可能有负权边，因此必须用 <code>spfa</code>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,p;</span><br><span class="line">vector&lt;PII&gt;G[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">bool</span> vis[N],st[N];</span><br><span class="line"><span class="type">int</span> cnt[N],dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[u])<span class="built_in">dfs</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>,st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,w]:G[t])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w)&#123;</span><br><span class="line">                dist[j]=dist[t]+w;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    cnt[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[j]&gt;n)&#123;</span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b,c-p);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(n);</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(dist[n],<span class="number">0ll</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看似简单，实则细节满满。</p>
</blockquote>
<h1 id="F-Polynomial-Construction-构造-多项式"><a href="#F-Polynomial-Construction-构造-多项式" class="headerlink" title="F. Polynomial Construction 构造+多项式"></a>F. Polynomial Construction 构造+多项式</h1><ul>
<li><p>题意：给出长度为 $p$ 的 $01$ 序列 $a$, 构造 $f(x)=\sum\limits_{i=0}^{p-1} b_i x^i$，满足 $f(i) \equiv a_i \pmod{p}$。</p>
</li>
<li><p>思路：可以看出 $f(x)$ 是一个多项式，此时可以考虑二项展开式。又因为此时的 $a$ 只有 $01$ 两种取值，因此可以：在 $a<em>x = 1$ 时构造一个函数 $g(i)$ 使 $i = x$ 时 $g(i) = 1$，$i \not = x$ 时 $g(i)=0$。这样使求和后只对 $f(x)$ 产生影响。由于题目要求是在模意义下（又因为 $p$ 为质数），且值为 $1$，可以考虑用费马小定理构造出 $g(i) = 1 - (i-x)^{p-1}$，后面的 $(i-x)^{p-1}$ 用二项式定理展开得 $\displaystyle\sum</em>{j=0}^{p-1} \binom{p-1}{j}i^{p-j-1}(-x)^i$。</p>
</li>
</ul>
<p><a href="https://www.luogu.com.cn/article/ht3daoip">思路参考</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)C[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(!a[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> f[N]=&#123;<span class="number">1</span>&#125;,now[N]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;p;j++)f[j]=(f[j<span class="number">-1</span>]*i)%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((p-j)&amp;<span class="number">1</span>)now[j]=(C[p<span class="number">-1</span>][j]*f[p<span class="number">-1</span>-j])%p;</span><br><span class="line">            <span class="keyword">else</span> now[j]=-(C[p<span class="number">-1</span>][j]*f[p<span class="number">-1</span>-j])%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p;j++)b[j]=(b[j]-now[j]+p)%p;</span><br><span class="line">        b[<span class="number">0</span>]=(b[<span class="number">0</span>]<span class="number">+1</span>)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多项式练少了，想不到这方面。</p>
</blockquote>
]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>abc377</title>
    <url>/2025/01/30/abc377/</url>
    <content><![CDATA[<h1 id="A-Rearranging-ABC"><a href="#A-Rearranging-ABC" class="headerlink" title="A. Rearranging ABC"></a>A. Rearranging ABC</h1><ul>
<li><p>题意：求给定的字符串是不是 <code>ABC</code>。</p>
</li>
<li><p>思路：直接判断。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        S[x]++;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[<span class="string">&#x27;A&#x27;</span>]==<span class="number">1</span>&amp;&amp;S[<span class="string">&#x27;B&#x27;</span>]==<span class="number">1</span>&amp;&amp;S[<span class="string">&#x27;C&#x27;</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Avoid-Rook-Attack"><a href="#B-Avoid-Rook-Attack" class="headerlink" title="B. Avoid Rook Attack"></a>B. Avoid Rook Attack</h1><ul>
<li>题意：一个棋子在图中记为 <code>*</code>，跟它同一行或同一列不能放 <code>*</code>，问还有几个方格能放棋子。</li>
<li>思路：因为 $n$ 很小，直接暴力枚举整张图，把能被覆盖到的标记，此时剩下的就是答案。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n=<span class="number">8</span>;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                t.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:t)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            vis[x][i]=<span class="number">1</span>;</span><br><span class="line">            vis[i][y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ans+=(vis[i][j]==<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Avoid-Knight-Attack"><a href="#C-Avoid-Knight-Attack" class="headerlink" title="C. Avoid Knight Attack"></a>C. Avoid Knight Attack</h1><ul>
<li><p>题意：一个棋子可以像中国象棋的 “马” 那样走 “日” 覆盖，问图中没有被棋子覆盖的地方的方格数。</p>
</li>
<li><p>思路：直接用 <code>set</code> 去维护每个棋子能覆盖到的点，因为 <code>set</code> 自带去重功能，最后直接把棋盘大小减去 <code>set</code> 的元素的个数就是答案。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    set&lt;PII&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> x=a+dx[j],y=b+dy[j];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>||x&gt;n||y&gt;n)<span class="keyword">continue</span>;</span><br><span class="line">            S.<span class="built_in">insert</span>(&#123;x,y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        S.<span class="built_in">insert</span>(&#123;a,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;((<span class="type">long</span> <span class="type">long</span>)n*n-(<span class="type">long</span> <span class="type">long</span>)S.<span class="built_in">size</span>())&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Many-Segments-2"><a href="#D-Many-Segments-2" class="headerlink" title="D.  Many Segments 2"></a>D.  Many Segments 2</h1><ul>
<li><p>题意：给定 $n$ 个区间，求出区间 $[l,r]$ 不完全包含区间 $[L_i,R_i]$ 的区间个数。</p>
</li>
<li><p>思路：因为数据规模比较大，对于这种求个数的问题可以考虑贡献法。然后我们又发现了：如果固定 $l$ 的话，它的答案是取决于所有 $L_i&gt;=l$ 的区间中 $R_i$ 最小的。此时我们用双指针来做，此时从大到小枚举 $l$ 的时候（为什么从大到小，因为你更新最小值的时候肯定是从大到小来维护的），$L_i&gt;=l$ 的区间会逐渐变多，此时统计右端点即可，然后每次更新一下最小值即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lst=m<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">1</span>&amp;&amp;w[j].fi&gt;=i)&#123;</span><br><span class="line">            lst=<span class="built_in">min</span>(lst,w[j].se);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=(lst-i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Permute-K-times-2"><a href="#E-Permute-K-times-2" class="headerlink" title="E. Permute K times 2"></a>E. Permute K times 2</h1><ul>
<li><p>题意：给定排列，然后每次操作将 $P<em>i$ 更新为 $P</em>{P_i}$，问第 $k$ 次操作 $P$ 的结果。</p>
</li>
<li><p>思路：对于这种题，可以考虑结合图来做，也就是画图。通过画图，可以很容易知道最后肯定会形成一个环，具体字怎么画呢？就是将 $P<em>i$ 与 $P</em>{P_i}$ 连边。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/lnswgoyg.png" alt=""></p>
</li>
<li><p>通过手算可以知道：它的第一个数在 $5$ 次操作的值是 $5,2,4,6,5$，解释一下就是：操作一次从 $5\rightarrow 2$，也就是走一步；然后第二次操作从 $2\rightarrow 4$，在图上走两步。以此类推，若要一个数按题目要求变换 $k$ 次，那么它的值将变为它向箭头方向走 $k-1$ 步的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    a[cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        g[i].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])cnt++,<span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="built_in">qmi</span>(<span class="number">2</span>,k,(<span class="type">int</span>)a[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            w[a[i][j]]=a[i][(j+s)%(<span class="type">int</span>)a[i].<span class="built_in">size</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;w[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Avoid-Queen-Attack"><a href="#F-Avoid-Queen-Attack" class="headerlink" title="F. Avoid Queen Attack"></a>F. Avoid Queen Attack</h1><ul>
<li><p>题意：对于一个棋子，它可以覆盖的范围类似 “米” 字形。给定一张图，问最后可以放棋子的格子数。</p>
</li>
<li><p>思路：如果是十字的话还好做，但这道题有对角线，因此对于对角线，我们可以取个巧，就是让 $x+y$ 作为 <code>/</code> 形对角线，让 $x-y$ 最为 <code>\</code> 形对角线，那么对于 <code>/</code> 对角线的取值范围就是 $[n+1,2n]$，对于 <code>\</code> 对角线的取值范围就是 $[0,n-1]$ 。此时我们可以先去让 <code>\</code> 形对角线满足条件，因为 <code>/</code> <code>\</code> 会有交点。这样的话我们可以先把十字形的先去掉，也就是先把十字形覆盖的格数算出来，从剩下的个数进行对角线的选择。然后根据 <code>*</code> 的横坐标、纵坐标和 <code>\</code> 形对角线，此时要看 <code>\</code> 形对角线能覆盖到哪里，可以算：（比如现在是已知横坐标和对角线去求 $y$ 就是 $d=x-y$ =&gt; $y=x-d$，然后最后的答案假如对于某个 <code>\</code> 对角线，是把对角线长度 $n-d$ 减去被对角线覆盖到的格子数（已经被覆盖到的格子数））。当开始枚举另一边的时候得注意：中间重复部分，此时可以列出方程 $a=x-y,b=x+y$ 解得：$x=(a+b)/2,y=(b-a)/2$，注意 $x,y$ 均为整数,如果能整除的话说明有交点，反之没有。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        ht.<span class="built_in">insert</span>(a);</span><br><span class="line">        vt.<span class="built_in">insert</span>(b);</span><br><span class="line">        zhu.<span class="built_in">insert</span>(a-b);</span><br><span class="line">        fu.<span class="built_in">insert</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=(n-ht.<span class="built_in">size</span>())*(n-vt.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> d:zhu)&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;cs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:ht)&#123;</span><br><span class="line">            <span class="type">int</span> y=x-d;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:vt)&#123;</span><br><span class="line">            <span class="type">int</span> x=d+y;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num=cs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len_d=n-<span class="built_in">abs</span>(d);</span><br><span class="line">        ans-=(len_d-num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:fu)&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;cs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:ht)&#123;</span><br><span class="line">            <span class="type">int</span> y=e-x;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:vt)&#123;</span><br><span class="line">            <span class="type">int</span> x=e-y;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:zhu)&#123;</span><br><span class="line">            <span class="type">int</span> x=(d+e)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> y=(e-d)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((e+d)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n)&#123;</span><br><span class="line">                cs.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=cs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len_d=n-<span class="built_in">abs</span>(e-(n<span class="number">+1</span>));</span><br><span class="line">        ans-=(len_d-num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G-Edit-to-Match"><a href="#G-Edit-to-Match" class="headerlink" title="G.  Edit to Match"></a>G.  Edit to Match</h1><ul>
<li><p>题意：给你 $n$ 个字符串，记 $s_0$ 为空，对于每个字符串 $i\in[1,n]$，求通过删除/添加后缀字母的操作，最少需要操作多少次使得 $s_i=s_k,k\in[0,i-1]$。</p>
</li>
<li><p>思路：这就是很典型的字符串匹配，对于字符串的前缀匹配，可以考虑字典树。将每个数插入到类似于 <code>trie</code> 树的东西上，再用 $en_i$ 数组记录离这个节点最近的结尾字符，代价即为：$en_p+n-i+1$，取最小值即可。其中 $en_i$ 就是 <code>cnt</code> 数组。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,n=s.<span class="built_in">size</span>();</span><br><span class="line">    ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[p][u]==<span class="number">0</span>)tr[p][u]=++idx;</span><br><span class="line">        p=tr[p][u];</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,cnt[p]+n-i<span class="number">-1</span>);</span><br><span class="line">        cnt[p]=<span class="built_in">min</span>(cnt[p],n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    cnt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>奇技淫巧</title>
    <url>/2025/03/01/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="曼哈顿距离转化为切比雪夫距离"><a href="#曼哈顿距离转化为切比雪夫距离" class="headerlink" title="曼哈顿距离转化为切比雪夫距离"></a>曼哈顿距离转化为切比雪夫距离</h1><ul>
<li>曼哈顿距离概念：如果平面内有 $(x_1,y_1)$ 以及 $(x_2,y_2)$，那么它们的距离就是 $d=|x_1-x_2|+|y_1-y_2|$。</li>
<li><p>切比雪夫距离概念：如果平面内有 $(x_1,y_1)$ 以及 $(x_2,y_2)$，那么它们的距离就是 $d=\max(|x_1-x_2|,|y_1-y_2|)$。</p>
</li>
<li><p>二者相互转化：曼哈顿转切比雪夫距离就是旋转 $45$°，然后扩大 $\sqrt 2$ 倍。</p>
</li>
<li><p>总的来说：</p>
</li>
<li><ul>
<li>曼哈顿距离转切比雪夫距离：$(x,y)\rightarrow (x+y,x-y)$。</li>
</ul>
</li>
<li><ul>
<li>切比雪夫距离转曼哈顿距离：$(x,y)\rightarrow ((x+y)/2,(x-y)/2)$。</li>
</ul>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1689D-Lena-and-Matrix"><a href="#1689D-Lena-and-Matrix" class="headerlink" title="1689D-Lena and Matrix"></a>1689D-Lena and Matrix</h3><ul>
<li>题意：给定一张表（有黑色的也有白色的单元格），找出一个单元格，使其到所选单元格最远的黑色单元格的曼哈顿距离最小。</li>
<li>思路：曼哈顿距离求这种最大最小的问题比较困难，更何况那么多单元格。因此，我们转化成切比雪夫距离，这样求最大最小值就可以非常方便了，也就是此时我们只需要排序即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    VI v1,v2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ansx=<span class="number">1e18</span>,ansy=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;B&#x27;</span>)&#123;<span class="comment">//转换切比雪夫距离</span></span><br><span class="line">                v<span class="number">1.</span><span class="built_in">pb</span>(j-i);</span><br><span class="line">                v<span class="number">2.</span><span class="built_in">pb</span>(i+j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(v1)),<span class="built_in">sort</span>(<span class="built_in">ALL</span>(v2));</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;calc=[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(&#123;x-v1[<span class="number">0</span>],y-v2[<span class="number">0</span>],v1[v<span class="number">1.</span>sz<span class="number">-1</span>]-x,v2[v<span class="number">2.</span>sz<span class="number">-1</span>]-y&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="type">int</span> xx=j-i,yy=i+j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">calc</span>(xx,yy)&lt;<span class="built_in">calc</span>(ansy-ansx,ansx+ansy))&#123;</span><br><span class="line">                ansx=i,ansy=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ansx&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ansy&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>整理（正在施工）</title>
    <url>/2025/02/14/%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>待施工</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日练习(1)</title>
    <url>/2025/03/05/%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从这里开始，我开始计划刷 abc/agc 的题目来巩固算法套路。那边的知识点整理我之后只抽取我觉得很有价值的题目放上去。然后同时计划每一天VP cf edu、abc 以及得写博客（但我可能不能做到每天VP，如果一天没有时间的话，我打算做 abc/agc 和刷知识点的题目，但不得不说，感觉时间很紧啊）。就希望能变得越来越好吧。</p>
<hr>
<h1 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h1><h2 id="abc067b-Snake-Toy-前缀和"><a href="#abc067b-Snake-Toy-前缀和" class="headerlink" title="abc067b-Snake Toy 前缀和"></a>abc067b-Snake Toy 前缀和</h2><ul>
<li>题意：给定 $n$ 个棍子，要求你用 $k$ 个棍子组成新棍子，使得这个新棍子最大。</li>
<li>思路：直接用前缀和<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,m,n)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,s[i]-s[i-m]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc068b-Break-Number-思维"><a href="#abc068b-Break-Number-思维" class="headerlink" title="abc068b-Break Number 思维"></a>abc068b-Break Number 思维</h2><ul>
<li>题意：问从 $1$ 到 $n$ 求能被 $2$ 整除最多次的数。</li>
<li>思路：我们按位分析，肯定是二进制中零越多越好。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1</span>,t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        bitset&lt;31&gt;<span class="built_in">S</span>(i);</span><br><span class="line">        string pp=S.<span class="built_in">to_string</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(pp));</span><br><span class="line">        <span class="keyword">while</span>(pp.<span class="built_in">back</span>()==<span class="string">&#x27;0&#x27;</span>&amp;&amp;pp.sz&gt;<span class="number">1</span>)pp.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="type">int</span> p=pp.sz-__builtin_popcount(i);</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;p)&#123;</span><br><span class="line">            ans=p;</span><br><span class="line">            t=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc113d-Number-of-Amidakuji-dp"><a href="#abc113d-Number-of-Amidakuji-dp" class="headerlink" title="abc113d-Number of Amidakuji dp"></a>abc113d-Number of Amidakuji dp</h2><ul>
<li>题意：有 $m$ 条竖线，每条线上有 $n$ 个高度。从 $(1,1)$ 出发，每次遇到横线时都选择经过它，并且不存在两条端点重合的横线，一条横线的两端点必须在同一高度，一条横线连接的需要是相邻的两条竖线。求从 $(1,1)$ 到 $(h,k)$ 的图的方案数。</li>
<li>思路：因为这边的数据规模比较小，因此我们肯定是考虑dp，我们设 $f<em>{i,j}$ 表示从 $(1,1)$ 到 $(i,j)$ 的方案数。通过观察题目可以发现：对于 $(i,j)$ 点，我们可以从 $(i-1,j-1)$、$(i-1,j)$ 以及 $(i-1,j+1)$ 转移过来的。此时题目说横线不能连续放（也就是不能共用一个端点），所以就得再开一个数组来记录，我们设 $g</em>{i,0/1}$ 表示，如果是 $g_{i,0}$ 表示第 $i$ 个位置不放边的方案，如果是 $1$ 则表示放。那么状态转移方程就比较容易了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,w)&#123;</span><br><span class="line">        g[i][<span class="number">0</span>]=(g[i<span class="number">-1</span>][<span class="number">0</span>]+g[i<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">        g[i][<span class="number">1</span>]=g[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,h)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,w)&#123;</span><br><span class="line">            f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]*g[j<span class="number">-1</span>][<span class="number">0</span>]%mod*g[w-j][<span class="number">0</span>]%mod)%mod;</span><br><span class="line">            f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>]*g[j<span class="number">-1</span>][<span class="number">1</span>]%mod*g[w-j][<span class="number">0</span>]%mod)%mod;</span><br><span class="line">            f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j<span class="number">+1</span>]*g[j<span class="number">-1</span>][<span class="number">0</span>]%mod*g[w-j][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[h][k]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc114d-756-数学"><a href="#abc114d-756-数学" class="headerlink" title="abc114d-756 数学"></a>abc114d-756 数学</h2><ul>
<li>题意：问再 $N!$ 中有多少个因数恰好包含 $75$ 个因数。</li>
<li>思路：因为阶乘很大，可以把它转化成 $N=p1^{c_1}…$ 这种形式。这边有个结论就是因数个数是等于 $(c_1+1)(c_2+1)(c_3+1)…$，然后令这个值等于 $75$，而且我们又发现 $75=75=15\times 5 = 3\times 25 = 3\times 5 \times 5$。那么只需要统计大于等于 <code>74 24 14 4 2</code> 的个数即可，为什么是大于等于呢？因为如果那个指数越大那肯定能分配到这些数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])primes[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i*primes[j]&lt;=x;j++)&#123;</span><br><span class="line">            vis[i*primes[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x=i;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> p=primes[j];</span><br><span class="line">            <span class="keyword">while</span>(x%p==<span class="number">0</span>)x/=p,a[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">            b[j]+=a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+n,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="number">74</span>)&#123;</span><br><span class="line">            c[<span class="number">74</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="number">24</span>)&#123;</span><br><span class="line">            c[<span class="number">24</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="number">14</span>)&#123;</span><br><span class="line">            c[<span class="number">14</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">            c[<span class="number">4</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            c[<span class="number">2</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">74</span>])&#123;</span><br><span class="line">        ans+=c[<span class="number">74</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">24</span>])&#123;</span><br><span class="line">        ans+=c[<span class="number">24</span>]*(c[<span class="number">2</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">14</span>])&#123;</span><br><span class="line">        ans+=c[<span class="number">14</span>]*(c[<span class="number">4</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">4</span>])&#123;</span><br><span class="line">        ans+=(c[<span class="number">4</span>]*(c[<span class="number">4</span>]<span class="number">-1</span>)/<span class="number">2</span>*(c[<span class="number">2</span>]<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc119c-Synthetic-Kadomatsu-思维"><a href="#abc119c-Synthetic-Kadomatsu-思维" class="headerlink" title="abc119c-Synthetic Kadomatsu 思维"></a>abc119c-Synthetic Kadomatsu 思维</h2><ul>
<li>题意：给定 $n(n\le 8)$ 个竹子，你可以通过合并（消耗 $10 MP$ ），削减（$1 MP$），增加（$1MP$）三个操作使得最后的长度是 $A,B,C$。问最小的花费。</li>
<li>思路：因为 $n$ 很小。是个位数。因此我们可以考虑暴力搜索。然后我们暴力搜索是用来合并两个竹子的，然后最后什么增加延长我们可以通过现在的值跟给定值的绝对值的差值就是了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> A,<span class="type">int</span> B,<span class="type">int</span> C,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A!=<span class="number">0</span>&amp;&amp;B!=<span class="number">0</span>&amp;&amp;C!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="built_in">abs</span>(A-a)+<span class="built_in">abs</span>(B-b)+<span class="built_in">abs</span>(C-c)+val<span class="number">-30</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;n)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(u<span class="number">+1</span>,A+w[u],B,C,val<span class="number">+10</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(u<span class="number">+1</span>,A,B+w[u],C,val<span class="number">+10</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(u<span class="number">+1</span>,A,B,C+w[u],val<span class="number">+10</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(u<span class="number">+1</span>,A,B,C,val);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>刚开始也想到暴力搜索，但被那个延长和缩短的操作给限制到了。</p>
</blockquote>
<h2 id="abc120c-Unification-思维"><a href="#abc120c-Unification-思维" class="headerlink" title="abc120c-Unification 思维"></a>abc120c-Unification 思维</h2><ul>
<li>题意：给你一个 $01$ 序列，每次可以删掉 $01$，问最后序列中能删掉 $01$ 的长度是多少。</li>
<li>思路：通过模拟发现：最终肯定是看 $0$ 和 $1$ 的数量的最小值乘 $2$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c0=<span class="number">0</span>,c1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;0&#x27;</span>)c0++;</span><br><span class="line">        <span class="keyword">else</span> c1++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(c0,c1)*<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc121c-Energy-Drink-Collector-贪心"><a href="#abc121c-Energy-Drink-Collector-贪心" class="headerlink" title="abc121c-Energy Drink Collector 贪心"></a>abc121c-Energy Drink Collector 贪心</h2><ul>
<li>题意：高桥君决定去买 $M$ 瓶饮料。有 $N$ 家超市，对于第 $i$ 家超市，高桥君可以以 $A_i$ 的单价购买一瓶饮料。但是超市供货有限，高桥君在第 $i$ 家超市最多只能买 $B_i$ 瓶饮料。高桥君想知道他最少需要花多少钱，买到 $M$ 瓶饮料。</li>
<li>思路：就贪心。将所有超市按照单价升序排序。然后就按照这个顺序买就行了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].a&gt;&gt;w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n,[&amp;](E x,E y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m-w[i].b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=w[i].a*m;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=w[i].a*w[i].b;</span><br><span class="line">        m-=w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc122c-GeT-AC-STL-前缀和"><a href="#abc122c-GeT-AC-STL-前缀和" class="headerlink" title="abc122c-GeT AC STL/前缀和"></a>abc122c-GeT AC STL/前缀和</h2><ul>
<li>题意：给定长度为 $n$ 的字符串只包含 <code>A</code> <code>T</code> <code>C</code> <code>G</code> ，问字串中存在 <code>AC</code> 的个数。</li>
<li>思路：我的思路是把每个 <code>AC</code> 串的位置存下来，然后最后查找就直接二分即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    vector&lt;PII&gt;p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>&amp;&amp;s[i<span class="number">+1</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            p.<span class="built_in">pb</span>(&#123;i<span class="number">+1</span>,i<span class="number">+2</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">upper_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(r<span class="number">-1</span>,r))-<span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(l,l<span class="number">+1</span>))&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc123c-Five-Transportations-思维"><a href="#abc123c-Five-Transportations-思维" class="headerlink" title="abc123c-Five Transportations 思维"></a>abc123c-Five Transportations 思维</h2><ul>
<li>题意：有 $6$ 个城市，中间有 $5$ 段路。每段路只有一种交通工具联通两个城市，所有交通工具均只需要 $1$ 分钟就能到达另一个城市。第 $i$ 种交通工具有一个最大载客量 $a_i$ 。如果超过最大载客量，剩下的人就要等待。现在有 $n$ 个人，他们要从一号城市到六号城市。问他们所有人去到六号城市要多久。</li>
<li>思路：通过模拟发现，最大时间就是卡在运载量最小的地方。因此答案就很明显了，就是把总数除这个最小运载量的运载量上取整然后再加四。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">5</span>)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span><span class="number">+5</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;((n+w[<span class="number">1</span>]<span class="number">-1</span>)/w[<span class="number">1</span>]<span class="number">+4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc124c-Coloring-Colorfully-思维"><a href="#abc124c-Coloring-Colorfully-思维" class="headerlink" title="abc124c-Coloring Colorfully 思维"></a>abc124c-Coloring Colorfully 思维</h2><ul>
<li>题意：给你一个 $01$ 序列，你可以把区间的数修改成任意的数，最后要满足 $01$ 序列是 $01$ 相间的。</li>
<li>思路：正难则反，我们直接从最终状态出发，因为最终状态肯定是 $01$ 相间的。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.sz;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    string p1,p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        p1+=(<span class="string">&#x27;0&#x27;</span>+(i&amp;<span class="number">1</span>));</span><br><span class="line">        p2+=(<span class="string">&#x27;0&#x27;</span>+!(i&amp;<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1[i]!=s[i])s1++;</span><br><span class="line">        <span class="keyword">if</span>(p2[i]!=s[i])s2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=<span class="built_in">min</span>(&#123;ans,s1,s2&#125;);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc125c-GCD-on-Blackboard-数学"><a href="#abc125c-GCD-on-Blackboard-数学" class="headerlink" title="abc125c-GCD on Blackboard 数学"></a>abc125c-GCD on Blackboard 数学</h2><ul>
<li>题意：给你 $n$ 个数的数组，你只能修改其中一个值，你的目的就是求修改这个值后数组的 $\gcd$。</li>
<li>思路：因为 $\gcd$ 跟 $\max \min$ 一样，都可以用前缀和/后缀和维护。因为你只能修改一个值，那么我这个值肯定是前缀和后缀的 $\gcd$ 值。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)l[i]=__gcd(l[i<span class="number">-1</span>],w[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)r[i]=__gcd(r[i<span class="number">+1</span>],w[i<span class="number">+1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,__gcd(l[i],r[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc127c-Prison-差分"><a href="#abc127c-Prison-差分" class="headerlink" title="abc127c-Prison 差分"></a>abc127c-Prison 差分</h2><ul>
<li>题意：我们现在有 $N$ 张ID卡，有 $M$ 道门。我们有第 $L_i$张、第 $L_i+1$张、…第 $R_i$张ID卡中的一张的时候，我们可以通过第 $i$ 道门。总共有几张卡符合“只用一张卡就能通过全部门”？</li>
<li>思路：这很明显就是差分。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        b[l]++,b[r<span class="number">+1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==m)ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1859C-Another-Permutation-Problem-1200-思维"><a href="#1859C-Another-Permutation-Problem-1200-思维" class="headerlink" title="1859C-Another Permutation Problem *1200 思维"></a>1859C-Another Permutation Problem <strong>*1200</strong> 思维</h2><ul>
<li>题意：给定序列长度 $n$ ，求排列中去掉 $p_i⋅i$ 的最大值后的最大 $p_i⋅i$ 和。</li>
<li>思路：我们首先可以考虑构造 $1,2,3,…,n$，后来我们发现 $n^2-(n-1)^2$ 太大了。然后根据样例的思路，我们可以考虑构造 $1,2,3,…,n,n-1$，但当 $n&gt;=10$ 的时候，这个 $n⋅(n−1)−(n−2)^2$ 太大了。所以我们可以考虑一边正序一边逆序，然后求个最小值即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        w[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(k,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(w+k,w<span class="number">+1</span>+n);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            sum+=i*w[i];</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,i*w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(w+k,w<span class="number">+1</span>+n);</span><br><span class="line">        res=<span class="built_in">max</span>(res,sum-mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这，有的时候样例会有一点启发吧。这构造题。</p>
</blockquote>
<h1 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h1><h2 id="abc115d-Christmas-递归"><a href="#abc115d-Christmas-递归" class="headerlink" title="abc115d-Christmas 递归"></a>abc115d-Christmas 递归</h2><ul>
<li>题意：第 $i$ 级汉堡是由一个 $B$ 一个 $i−1$ 级汉堡一个 $P$ 一个 $i−1$ 级汉堡一个 $B$ 组成的。（其中 $B$ 为面包，$P$ 为肉饼）求第 $n$ 级汉堡的前 $k$ 层有多少肉饼（$P$）。</li>
<li>思路：我们可以很快的写出通式：$s<em>i=B+s</em>{i-1}+P+s<em>{i-1}+B$。那么在递归的时候可以分类讨论：当 $B+s</em>{i-1}+P+s<em>{i-1}$ ，也就是跟后面的 $s</em>{i-1}$ 有交集，当 $B+s<em>{i-1}+P$，当 $B+s</em>{i-1}$，也就是跟后面的 $s_{i-1}$ 有交集。因为要求前 $k$ 层，我们这里最好预处理每一层的长度和 $P$ 的个数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&gt;len[u<span class="number">-1</span>]<span class="number">+2</span>)<span class="keyword">return</span> p[u<span class="number">-1</span>]<span class="number">+1</span>+<span class="built_in">dfs</span>(u<span class="number">-1</span>,k-len[u<span class="number">-1</span>]<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">if</span>(k==len[u<span class="number">-1</span>]<span class="number">+2</span>)<span class="keyword">return</span> p[u<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">dfs</span>(u<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    len[<span class="number">0</span>]=p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        len[i]=len[i<span class="number">-1</span>]*<span class="number">2</span><span class="number">+3</span>;</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>(n,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc116d-Various-Sushi-反悔贪心"><a href="#abc116d-Various-Sushi-反悔贪心" class="headerlink" title="abc116d-Various Sushi 反悔贪心"></a>abc116d-Various Sushi 反悔贪心</h2><ul>
<li>题意：有 $n$ 个物品，每个物品有种类和价值。要选择 $k$ 个物品，使得价值和加上不同物品个数和的平方最大。即如果的物品价值和为 $x$ ，有 $y$ 个不同种类的物品，贡献为 $x+y^2$ 。</li>
<li>思路：我们可以先选价值最大的，然后选好了之后开始反悔，如果不同种类的加进去会使得答案更大我们就选。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].t&gt;&gt;w[i].d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    VI b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        sum+=w[i].d;</span><br><span class="line">        <span class="keyword">if</span>(vis[w[i].t])&#123;</span><br><span class="line">            b.<span class="built_in">pb</span>(w[i].d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vis[w[i].t]=<span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=sum+cnt*cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,k<span class="number">+1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b.sz)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[w[i].t])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum+=w[i].d-b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line">        cnt++,vis[w[i].t]=<span class="number">1</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum+cnt*cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc117d-XXOR-位运算"><a href="#abc117d-XXOR-位运算" class="headerlink" title="abc117d-XXOR 位运算"></a>abc117d-XXOR 位运算</h2><ul>
<li><p>题意：有 $n$ 个数 $a<em>1,a_2……a_n$ 和一个数 $k$，$\oplus$ 表示按位异或。对于 $0\leq x\leq k，f(x)=(x \oplus a_1)+(x \oplus a_2)……(x \oplus a_n)$。求 $f</em>{max}$ 为多少。</p>
</li>
<li><p>思路：这又是一道按位分析的题目，如果某一位 $1$ 的个数少于一半的情况下，此时我们就得从外界引入 $1$（也就是异或上 $1$）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">40</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                b[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">0</span>,<span class="number">40</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*b[i]&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>((ans|(<span class="number">1ll</span>&lt;&lt;i))&lt;=k)&#123;</span><br><span class="line">                ans|=(<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        p+=(w[i]^ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc118d-Match-Matching-背包dp"><a href="#abc118d-Match-Matching-背包dp" class="headerlink" title="abc118d-Match Matching 背包dp"></a>abc118d-Match Matching 背包dp</h2><ul>
<li>题意：已知每种数字拼得所需的火柴数，给出所拥有的火柴棒数 $n$ 以及可以拼 $m$ 种数字 $a_1,a_2,…,a_m$，求出所能拼成的最大数字。</li>
<li>思路：总数确定，而且火柴棒的数目确定（相当于体积），且数据规模不大，这不就是背包问题。只不过要求方案数。方案数的确定就是像下面这样倒过来，从 $n$ 开始向下枚举。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> num[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n<span class="number">+1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(<span class="built_in">ALL</span>(f),<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,num[w[i]],n)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-num[w[i]]]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+m,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;=num[w[i]]&amp;&amp;f[n]==f[n-num[w[i]]]<span class="number">+1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;w[i];</span><br><span class="line">                n-=num[w[i]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>背包问题求方案数就是从末状态开始推的。</p>
</blockquote>
<h2 id="abc119d-Lazy-Faith-二分"><a href="#abc119d-Lazy-Faith-二分" class="headerlink" title="abc119d-Lazy Faith 二分"></a>abc119d-Lazy Faith 二分</h2><ul>
<li>题意：有 $a$ 个点 $s$，有 $b$ 个点 $t$，问从点 $x$ 出发到达至少一个 $a$ 和一个 $b$ 的最短距离是多少。</li>
<li>思路：这就是典型的二分，我们发现无非就四种情况（<del>服了，我之前写的那个写了 12 种情况</del>），即 $a,b$ 都在当前点的左边；都在右边；一左一右。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n),<span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">9e18</span>;</span><br><span class="line">        <span class="type">int</span> t1=<span class="built_in">lower_bound</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n,x)-a;</span><br><span class="line">        <span class="type">int</span> t2=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+m,x)-b;</span><br><span class="line">        <span class="keyword">if</span>(t1&gt;<span class="number">1</span>&amp;&amp;t2&gt;<span class="number">1</span>)&#123;<span class="comment">//ll</span></span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(<span class="built_in">abs</span>(x-a[t1<span class="number">-1</span>]),<span class="built_in">abs</span>(x-b[t2<span class="number">-1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t1&lt;=n&amp;&amp;t2&lt;=m)&#123;<span class="comment">//rr</span></span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(<span class="built_in">abs</span>(x-a[t1]),<span class="built_in">abs</span>(x-b[t2])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t1&gt;<span class="number">1</span>&amp;&amp;t2&lt;=m)&#123;<span class="comment">//lr</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(x-a[t1<span class="number">-1</span>])&gt;<span class="built_in">abs</span>(b[t2]-x))&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(b[t2]-x)+<span class="built_in">abs</span>(b[t2]-a[t1<span class="number">-1</span>]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(x-a[t1<span class="number">-1</span>])+<span class="built_in">abs</span>(b[t2]-a[t1<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t1&lt;=n&amp;&amp;t2&gt;<span class="number">1</span>)&#123;<span class="comment">//rl</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[t1]-x)&gt;<span class="built_in">abs</span>(x-b[t2<span class="number">-1</span>]))&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(x-b[t2<span class="number">-1</span>])+<span class="built_in">abs</span>(b[t2<span class="number">-1</span>]-a[t1]));   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(a[t1]-x)+<span class="built_in">abs</span>(b[t2<span class="number">-1</span>]-a[t1]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc120d-Decayed-Bridges-思维"><a href="#abc120d-Decayed-Bridges-思维" class="headerlink" title="abc120d-Decayed Bridges 思维"></a>abc120d-Decayed Bridges 思维</h2><ul>
<li>题意：给定一张 $n$ 个点， $m$ 条边的无向图，现按输入顺序依次删除每一条边，求出每删除一条边是，有多少对 $(x,y)$ 不能联通，注意 $(x,y)$ 与 $(y,x)$ 为一种。</li>
<li>思路：正难则反，删边困难转化成连边，我们不是要求有多少对吗，我们可以用 size 数组维护联通块的点的个数，连边的时候就减去这两个联通块如果分开所产生的对数（正好，它的对数恰好是 $size_a\times size_b$）。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    a=<span class="built_in">find</span>(a),b=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">        p[a]=b;</span><br><span class="line">        siz[b]+=siz[a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)p[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ans[m]=(n<span class="number">-1</span>)*n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">2</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(a[i]),pb=<span class="built_in">find</span>(b[i]);</span><br><span class="line">        <span class="keyword">if</span>(pa==pb)ans[i<span class="number">-1</span>]=ans[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans[i<span class="number">-1</span>]=ans[i]-siz[pa]*siz[pb];</span><br><span class="line">            p[pb]=pa;</span><br><span class="line">            siz[pa]+=siz[pb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="abc121d-XOR-World-位运算-结论（模4结论）"><a href="#abc121d-XOR-World-位运算-结论（模4结论）" class="headerlink" title="abc121d-XOR World 位运算+结论（模4结论）"></a>abc121d-XOR World 位运算+结论（模4结论）</h2><ul>
<li>题意：求 $A,A+1,A+2,…,B$ 异或的结果。</li>
<li>思路：这道题就是算连续的异或和，我们发现，长度是 $4$ 的有如下性质：</li>
</ul>
<p><code>int work(int x)&#123;
    if(x%4==0)return x;
    if(x%4==1)return 1;
    if(x%4==2)return x+1;
    if(x%4==3)return 0;
&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">2</span>)<span class="keyword">return</span> x<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(<span class="built_in">work</span>(r)^<span class="built_in">work</span>(l<span class="number">-1</span>))&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="abc122d-We-Like-AGC"><a href="#abc122d-We-Like-AGC" class="headerlink" title="abc122d-We Like AGC"></a>abc122d-We Like AGC</h2><ul>
<li>题意：求长度为 $n$ 的，满足只有字符 <code>A，G，C，T</code>没有子串 <code>AGC</code>，在单次操作（交换相邻两个字符）后仍然满足上述条件的串的个数。</li>
<li>思路：我们发现之有这些子串会有问题：<code>AGC</code> ，<code>ACG</code>，<code>GAC</code> ，<code>AGGC</code> ，<code>AGTC</code> ，<code>ATGC</code> 。因为数组内有四个数字，还有可能是空字符（相比长度为 $4$ 的子串），因此我们可以用五进制来表示这些串。比如 <code>AGC</code> 就是 $38$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">124</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                <span class="built_in">FOR</span>(k,j*<span class="number">5</span><span class="number">+1</span>,j*<span class="number">5</span><span class="number">+4</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(k%<span class="number">125</span>==<span class="number">38</span>||k%<span class="number">125</span>==<span class="number">42</span>||k%<span class="number">125</span>==<span class="number">58</span>||k==<span class="number">188</span>||k==<span class="number">198</span>||k==<span class="number">238</span>))&#123;</span><br><span class="line">                        f[i][k%<span class="number">125</span>]=(f[i][k%<span class="number">125</span>]+f[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">125</span>)ans=(ans+f[n][i])%mod;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h1><h2 id="abc123d-Cake-123"><a href="#abc123d-Cake-123" class="headerlink" title="abc123d-Cake 123"></a>abc123d-Cake 123</h2><ul>
<li>题意：有三行序列，每次都要从每一行中选一个数，将所选的三个数相加，得到一个新数。如此操作，输出所得的前 $K$ 大的数。</li>
<li>思路：既然要选前 $K$ 大的数，我们先将三个序列从大到小排序，最大的显然是 $a_1+b_1+c_1$，然后剩下的就是从 $a_2+b_1+c_1$、$a_1+b_2+c_1$、$a_1+b_1+c_2$ 中选，那这就是很典型的大顶堆来维护。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z,k;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i]+b[j]+c[k]&lt;a[t.i]+b[t.j]+c[t.k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,x)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,y)cin&gt;&gt;b[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,z)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+x,<span class="built_in">greater</span>());</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+y,<span class="built_in">greater</span>());</span><br><span class="line">    <span class="built_in">sort</span>(c<span class="number">+1</span>,c<span class="number">+1</span>+z,<span class="built_in">greater</span>());</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;E&gt;q;</span><br><span class="line"></span><br><span class="line">    map&lt;TII,<span class="type">bool</span>&gt;st;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    st[&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [a1,a2,a3]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;a[a1]+b[a2]+c[a3]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">count</span>(&#123;a1<span class="number">+1</span>,a2,a3&#125;)&amp;&amp;a1&lt;x)&#123;</span><br><span class="line">            st[&#123;a1<span class="number">+1</span>,a2,a3&#125;]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a1<span class="number">+1</span>,a2,a3&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">count</span>(&#123;a1,a2<span class="number">+1</span>,a3&#125;)&amp;&amp;a2&lt;y)&#123;</span><br><span class="line">            st[&#123;a1,a2<span class="number">+1</span>,a3&#125;]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a1,a2<span class="number">+1</span>,a3&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">count</span>(&#123;a1,a2,a3<span class="number">+1</span>&#125;)&amp;&amp;a3&lt;z)&#123;</span><br><span class="line">            st[&#123;a1,a2,a3<span class="number">+1</span>&#125;]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a1,a2,a3<span class="number">+1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面就是 <code>VP</code> 的了。</p>
<h1 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h1><h2 id="1872D-Plus-Minus-Permutation-1200-思维-数学"><a href="#1872D-Plus-Minus-Permutation-1200-思维-数学" class="headerlink" title="1872D-Plus Minus Permutation *1200 思维+数学"></a>1872D-Plus Minus Permutation <strong>*1200</strong> 思维+数学</h2><ul>
<li>题意：给定三个整数 $n,x,y$，有排列 $p<em>1,p_2,\dots,p_n$，规定这种排列的分数为：<br>$(p</em>{1 \cdot x} + p<em>{2 \cdot x} + \ldots + p</em>{\lfloor \frac{n}{x} \rfloor \cdot x}) - (p<em>{1 \cdot y} + p</em>{2 \cdot y} + \ldots + p_{\lfloor \frac{n}{y} \rfloor \cdot y})$，求所有长度为 $n$ 的排列的最大分数。</li>
<li>思路：对于被减数我们肯定是越大越好，因此我们的被减数分配从 $n$ 开始，减数就是从 $1$ 开始往上算。重叠的部分就是 $x,y$ 的 $lcm$。对于 $n/x$ 就是算从 $1$ 到 $n$ 有多少个数是 $x$ 的倍数。最后通过等差数列通项公式把答案算出来即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y/__gcd(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">lcm</span>(x,y);</span><br><span class="line"></span><br><span class="line">    VI px,py;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p=n/t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p1=n/x,p2=n/y;</span><br><span class="line"></span><br><span class="line">    p1-=p,p2-=p;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;((n+(n-p1<span class="number">+1</span>))*p1/<span class="number">2</span>-((<span class="number">1</span>+(<span class="number">1</span>+p2<span class="number">-1</span>))*p2)/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h1><p>VP 2024 ICPC National Invitational Collegiate Programming Contest, Wuhan Site 去了。</p>
<h1 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h1><p>见我的 CF各ratingVP专题。</p>
<h1 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h1><h2 id="abc124d-Handstand"><a href="#abc124d-Handstand" class="headerlink" title="abc124d-Handstand"></a>abc124d-Handstand</h2><ul>
<li>题意：给定一个长度为 $n$ 的二进制序列 $a$ ，每次可以选择连续的一段并取反，求在最多 $K$ 次操作后连续的 $1$ 的个数的最大值。</li>
<li>思路：我的可以把连续的数量记录下来，即把连续的 $1$ 的个数存储下来，此时用负数表示，反之用正数表示。比如样例的 <code>11101010110011</code> 就处理成 <code>-3 1 -1 1 -1 1 -2 2 -2</code>。然后用滑动窗口处理即可。假设现在加入的 $i$ 号串为 $0$ 串，且现在（加入前）已有 $k$ 个 $0$ 串，则要删除 $0$ 串 $i−2k$ 和 $1$ 串 $i−2k−1$ 的贡献。（也就是这边我们的滑动窗口可以用数组模拟）</li>
</ul>
<blockquote>
<p>为什么是 $i−2k$ 呢？</p>
<p>答：因为处理后的序列必然是 $01$ 相间的，那么 $i$ 前的第 $1$ 个 $0$ 串即是 $i−2$，第 $k$ 个即是 $i−2k$。而 $i−2k−1$ 是在删除 $i−2k$ 后已经无法联通的，所以也要去除。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> r=i;</span><br><span class="line">            <span class="keyword">while</span>(r&lt;n&amp;&amp;s[r]==<span class="string">&#x27;1&#x27;</span>)r++;</span><br><span class="line">            p[++cnt]=-(r-i);</span><br><span class="line">            i=r<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> r=i;</span><br><span class="line">            <span class="keyword">while</span>(r&lt;n&amp;&amp;s[r]==<span class="string">&#x27;0&#x27;</span>)r++;</span><br><span class="line">            p[++cnt]=(r-i);</span><br><span class="line">            i=r<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FOR(i,1,cnt)cout&lt;&lt;p[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,l=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l==k)sum-=(p[i<span class="number">-2</span>*k]-p[i<span class="number">-2</span>*k<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=<span class="built_in">abs</span>(p[i]);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="abc125d-Flipping-Signs"><a href="#abc125d-Flipping-Signs" class="headerlink" title="abc125d-Flipping Signs"></a>abc125d-Flipping Signs</h2><ul>
<li>题意：有一个长度为 $n$ 的数组，可以进行无限次操作，每次可以使第 $i$ 和第 $i+1$ 个数变成其相反数，求可能达到的最大值。</li>
<li>思路：这很明显的线性 dp，设 $f<em>{i,0/1}$ 表示进行/不进行第 $i$ 个操作的 $1\rightarrow i$ 的前缀和。$f</em>{i,0}=\max(f<em>{i-1,1},f</em>{i-1,0})+w<em>i,f</em>{i,1}=\max(f<em>{i-1,0}-2w</em>{i-1},f<em>{i-1,1}+2w</em>{i-1})-w_i$ 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=w[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>])+w[i];</span><br><span class="line">        f[i][<span class="number">1</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">-2</span>*w[i<span class="number">-1</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]<span class="number">+2</span>*w[i<span class="number">-1</span>])-w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="abc126d-Even-Relation"><a href="#abc126d-Even-Relation" class="headerlink" title="abc126d-Even Relation"></a>abc126d-Even Relation</h2><ul>
<li>题意：给定一颗无根树，让你给每个点染黑和白色，前提是两点之间的边权如果是奇数，两点的颜色就不能一样。颜色用 $0$ 和 $1$ 表示，输出任意一种方案即可。</li>
<li>思路：因为不存在环，我们其实都不需要判断矛盾，直接暴力搜索即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt;g[N];</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=color[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,w]:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[j]!=<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(w&amp;<span class="number">1</span>))&#123;</span><br><span class="line">            color[j]=t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            color[j]=t^<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)color[i]=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    color[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;color[i]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="abc127d-Integer-Cards"><a href="#abc127d-Integer-Cards" class="headerlink" title="abc127d-Integer Cards"></a>abc127d-Integer Cards</h2><ul>
<li>题意：给定一个长度为 $n$ 的序列 $a$，和长度为 $m$ 的序列 $b$ 和 $c$，表示你最多可以选择 $a$ 中 $b_i$ 个数变为 $c_i$。让你求出在经过数次操作后，$a$ 序列的总和最大是多少。</li>
<li>思路：大型贪心现场，我们肯定是把数换的越大越好，也就是我们是把 $a$ 数组小的数换成 $b$ 中大的数。然后就按照这个顺序模拟即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y&gt;t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;q[i].x&gt;&gt;q[i].y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;q[t].y)&#123;</span><br><span class="line">            q[t].x--;</span><br><span class="line">            w[i]=q[t].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!q[t].x)t++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t&gt;m)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)ans+=w[i];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点系列——基本算法</title>
    <url>/2025/02/20/%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="2-2-尺取法"><a href="#2-2-尺取法" class="headerlink" title="2.2 尺取法"></a>2.2 尺取法</h1><h2 id="HDU-2029-Palindromes-easy-version"><a href="#HDU-2029-Palindromes-easy-version" class="headerlink" title="HDU-2029 Palindromes _easy version"></a>HDU-2029 Palindromes _easy version</h2><ul>
<li>回文数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string t=s;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(t));</span><br><span class="line">    <span class="keyword">if</span>(s==t) cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-5358-First-One"><a href="#HDU-5358-First-One" class="headerlink" title="HDU - 5358 First One"></a>HDU - 5358 First One</h2><ul>
<li>因为题目有 $\log$，然后又是双重循环，肯定得优化，因为存在 $\log$，那么又得考虑每一位了。这道题有个特殊的地方就是，我们可以令 $k=(\log_2{S(i,j)}+1)，我们可以枚举 $k$ 的值，尺取法选择区间 $[l,r]$ 满足的 $k$，然后固定 $i$ 找 $j$ 满足的区间 $[l,r]$，则在区间中的 $(i+j)=i<em>(r-l+1)+(r-l+1)</em>(l+r)/2$，最后再乘 $k$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(k,<span class="number">1</span>,<span class="number">34</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L=(<span class="number">1ll</span>&lt;&lt;(k<span class="number">-1</span>)),R=(<span class="number">1ll</span>&lt;&lt;k)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)L=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="number">1</span>,l=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            l=<span class="built_in">max</span>(l,i);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=n&amp;&amp;s[l]-s[i<span class="number">-1</span>]&lt;L)l++;</span><br><span class="line">            r=<span class="built_in">max</span>(r,l);</span><br><span class="line">            <span class="keyword">while</span>(r&lt;=n&amp;&amp;s[r]-s[i<span class="number">-1</span>]&gt;=L&amp;&amp;s[r]-s[i<span class="number">-1</span>]&lt;=R)r++;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">                ans+=((r-l)*i+(r-l)*(l+r<span class="number">-1</span>)/<span class="number">2</span>)*k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="580B-Kefa-and-Company"><a href="#580B-Kefa-and-Company" class="headerlink" title="580B-Kefa and Company"></a>580B-Kefa and Company</h2><ul>
<li>题意：给定一些人的钱和贡献，选取一些人让他们的钱之差不超过d，使贡献最大。</li>
<li>思路：先按工资升序排序，然后套上尺取就行了，时间复杂度 $O(n\log n)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].a&gt;&gt;w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w+n<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(l,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=n&amp;&amp;w[r].a-w[l].a&lt;m)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>……</p>
<hr>
<p>总结一下尺取法：尺取法的本质就是给定 $l$ ，然后去找满足条件的 $r$。应用：见到有单调性、有限制的区间问题，很自然地就会想到用尺取去做。</p>
<hr>
<h1 id="2-3-二分法"><a href="#2-3-二分法" class="headerlink" title="2.3 二分法"></a>2.3 二分法</h1><h2 id="洛谷-P1462-通往奥格瑞玛的道路"><a href="#洛谷-P1462-通往奥格瑞玛的道路" class="headerlink" title="洛谷 - P1462 通往奥格瑞玛的道路"></a>洛谷 - P1462 通往奥格瑞玛的道路</h2><h2 id="洛谷-P1824-进击的奶牛"><a href="#洛谷-P1824-进击的奶牛" class="headerlink" title="洛谷 - P1824 进击的奶牛"></a>洛谷 - P1824 进击的奶牛</h2><h2 id="洛谷-P1419-寻找段落"><a href="#洛谷-P1419-寻找段落" class="headerlink" title="洛谷 - P1419 寻找段落"></a>洛谷 - P1419 寻找段落</h2><h2 id="洛谷-P1083-借教室"><a href="#洛谷-P1083-借教室" class="headerlink" title="洛谷 - P1083 借教室"></a>洛谷 - P1083 借教室</h2><h2 id="洛谷-P2678-跳石头"><a href="#洛谷-P2678-跳石头" class="headerlink" title="洛谷 - P2678 跳石头"></a>洛谷 - P2678 跳石头</h2><h2 id="洛谷-P1314-聪明的质监员"><a href="#洛谷-P1314-聪明的质监员" class="headerlink" title="洛谷 - P1314 聪明的质监员"></a>洛谷 - P1314 聪明的质监员</h2><h2 id="洛谷-P1868-饥饿的奶牛"><a href="#洛谷-P1868-饥饿的奶牛" class="headerlink" title="洛谷 - P1868 饥饿的奶牛"></a>洛谷 - P1868 饥饿的奶牛</h2><h2 id="洛谷-P1493-分梨子"><a href="#洛谷-P1493-分梨子" class="headerlink" title="洛谷 - P1493 分梨子"></a>洛谷 - P1493 分梨子</h2><h2 id="HDU-6231-K-th-Number"><a href="#HDU-6231-K-th-Number" class="headerlink" title="HDU - 6231 K-th Number"></a>HDU - 6231 K-th Number</h2><h1 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h1><h2 id="洛谷-P3382-三分"><a href="#洛谷-P3382-三分" class="headerlink" title="洛谷-P3382 三分"></a>洛谷-P3382 三分</h2><h2 id="HDU-3400-Line-belt"><a href="#HDU-3400-Line-belt" class="headerlink" title="HDU-3400 Line belt"></a>HDU-3400 Line belt</h2><h2 id="洛谷-P3745-期末考试"><a href="#洛谷-P3745-期末考试" class="headerlink" title="洛谷-P3745 期末考试"></a>洛谷-P3745 期末考试</h2><h2 id="洛谷-P1883-三分-函数"><a href="#洛谷-P1883-三分-函数" class="headerlink" title="洛谷-P1883 三分 | 函数"></a>洛谷-P1883 三分 | 函数</h2><h1 id="2-5-倍增法与ST算法"><a href="#2-5-倍增法与ST算法" class="headerlink" title="2.5 倍增法与ST算法"></a>2.5 倍增法与ST算法</h1><h2 id="洛谷-P4155-国旗计划"><a href="#洛谷-P4155-国旗计划" class="headerlink" title="洛谷-P4155 国旗计划"></a>洛谷-P4155 国旗计划</h2><h2 id="洛谷-P2880-Balanced-Lineup-G"><a href="#洛谷-P2880-Balanced-Lineup-G" class="headerlink" title="洛谷-P2880 Balanced Lineup G"></a>洛谷-P2880 Balanced Lineup G</h2><h2 id="HDU-5443-The-Water-Problem"><a href="#HDU-5443-The-Water-Problem" class="headerlink" title="HDU-5443 The Water Problem"></a>HDU-5443 The Water Problem</h2><h2 id="HDU-6107-Typesetting"><a href="#HDU-6107-Typesetting" class="headerlink" title="HDU-6107 Typesetting"></a>HDU-6107 Typesetting</h2><h2 id="洛谷-P3865-ST-表-amp-amp-RMQ-问题"><a href="#洛谷-P3865-ST-表-amp-amp-RMQ-问题" class="headerlink" title="洛谷-P3865 ST 表 &amp;&amp; RMQ 问题"></a>洛谷-P3865 ST 表 &amp;&amp; RMQ 问题</h2><h2 id="洛谷-P2251-质量检测"><a href="#洛谷-P2251-质量检测" class="headerlink" title="洛谷-P2251 质量检测"></a>洛谷-P2251 质量检测</h2><h2 id="洛谷-P1816-忠诚"><a href="#洛谷-P1816-忠诚" class="headerlink" title="洛谷-P1816 忠诚"></a>洛谷-P1816 忠诚</h2><h2 id="洛谷-P1198-最大数"><a href="#洛谷-P1198-最大数" class="headerlink" title="洛谷-P1198 最大数"></a>洛谷-P1198 最大数</h2><h1 id="2-6-前缀和与差分"><a href="#2-6-前缀和与差分" class="headerlink" title="2.6 前缀和与差分"></a>2.6 前缀和与差分</h1><h2 id="HDU-1556-Color-the-ball"><a href="#HDU-1556-Color-the-ball" class="headerlink" title="HDU-1556 Color the ball"></a>HDU-1556 Color the ball</h2><h2 id="HDU-6273-Master-of-GCD"><a href="#HDU-6273-Master-of-GCD" class="headerlink" title="HDU-6273 Master of GCD"></a>HDU-6273 Master of GCD</h2><h1 id="2-7-离散化"><a href="#2-7-离散化" class="headerlink" title="2.7 离散化"></a>2.7 离散化</h1>]]></content>
      <tags>
        <tag>知识点系列</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点系列——基础数据结构</title>
    <url>/2025/02/17/%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1-1-链表"><a href="#1-1-链表" class="headerlink" title="1.1 链表"></a>1.1 链表</h1><h2 id="洛谷-P1996-约瑟夫问题"><a href="#洛谷-P1996-约瑟夫问题" class="headerlink" title="洛谷-P1996 约瑟夫问题"></a>洛谷-P1996 约瑟夫问题</h2><ul>
<li>我就直接模拟</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;k)&#123;</span><br><span class="line">            <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(vis[id])&#123;</span><br><span class="line">                id++;</span><br><span class="line">                f=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(id&gt;n)id=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">                id++;</span><br><span class="line">                <span class="keyword">if</span>(id&gt;n)id=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(vis[id])&#123;</span><br><span class="line">                    id++;</span><br><span class="line">                    <span class="keyword">if</span>(id&gt;n)id=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;id&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        vis[id]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1160-队列安排-list-做法"><a href="#洛谷-P1160-队列安排-list-做法" class="headerlink" title="洛谷-P1160 队列安排 list 做法"></a>洛谷-P1160 队列安排 list 做法</h2><ul>
<li><p><code>list</code> 有 <code>insert</code> 函数，可以将某个数插入在某个位置的后面，这里的位置是 <code>list&lt;int&gt;::iterator</code> 。</p>
</li>
<li><p>只不过为了优化，此时存储 <code>list&lt;int&gt;::iterator</code> 的所有位置，这样速度就会快很多。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;lt;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator elt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    elt[<span class="number">1</span>]=lt.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(y)&#123;</span><br><span class="line">            it=elt[x];<span class="comment">//然后这里的elt存储的是某个数前面的位置</span></span><br><span class="line">            lt.<span class="built_in">insert</span>(++it,i);<span class="comment">//因为list插入都是在某个位置的后面插</span></span><br><span class="line">            elt[i]=--it;<span class="comment">//左闭右开</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            it=elt[x];</span><br><span class="line">            lt.<span class="built_in">insert</span>(it,i);</span><br><span class="line">            elt[i]=--it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(elt[x]!=lt.<span class="built_in">end</span>())&#123;</span><br><span class="line">            lt.<span class="built_in">erase</span>(elt[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        elt[x]=lt.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:lt)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-2-队列"><a href="#1-2-队列" class="headerlink" title="1.2 队列"></a>1.2 队列</h1><h2 id="洛谷-P1540-机器翻译"><a href="#洛谷-P1540-机器翻译" class="headerlink" title="洛谷-P1540 机器翻译"></a>洛谷-P1540 机器翻译</h2><ul>
<li>直接模拟。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            S.<span class="built_in">insert</span>(x);</span><br><span class="line">            ans++;</span><br><span class="line">            q.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(q.sz&gt;m)S.<span class="built_in">erase</span>(q.<span class="built_in">front</span>()),q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-1003-Max-Sum-连续和的dp"><a href="#HDU-1003-Max-Sum-连续和的dp" class="headerlink" title="HDU-1003 Max Sum 连续和的dp"></a>HDU-1003 Max Sum 连续和的dp</h2><ul>
<li>这个就是 dp 问题，只不过我觉得用队列麻烦。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>,al=<span class="number">1</span>,ar=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>]+w[i],w[i]);</span><br><span class="line">        <span class="keyword">if</span>(f[i]==f[i<span class="number">-1</span>]+w[i])&#123;</span><br><span class="line">            r=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f[i]==w[i])&#123;</span><br><span class="line">            l=r=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;ans)&#123;</span><br><span class="line">            ans=f[i];</span><br><span class="line">            al=l,ar=r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;T++&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;al&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ar&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1440-求m区间内的最小值-双端队列"><a href="#洛谷-P1440-求m区间内的最小值-双端队列" class="headerlink" title="洛谷-P1440 求m区间内的最小值 双端队列"></a>洛谷-P1440 求m区间内的最小值 双端队列</h2><ul>
<li><strong>注意一下：这里是不包括 $i$ 的前面 $m$ 个的最小值，因此我把那个输出放在弹出队首之后和弹出队尾之前的操作。反之如果包括，则写在下面</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;m)q.<span class="built_in">pop_front</span>();</span><br><span class="line">    </span><br><span class="line">        cout&lt;&lt;w[q.<span class="built_in">front</span>()]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;w[q.<span class="built_in">back</span>()]&gt;=w[i])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2032-扫描"><a href="#洛谷-P2032-扫描" class="headerlink" title="洛谷-P2032 扫描"></a>洛谷-P2032 扫描</h2><ul>
<li>跟上一道题类似。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;=m)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;w[q.<span class="built_in">back</span>()]&lt;=w[i])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m)&#123;<span class="comment">//因为有包括该数的前k个数，所以必须写在下面，上一题是没有包括这个数，所以写在上面</span></span><br><span class="line">            cout&lt;&lt;w[q.<span class="built_in">front</span>()]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1714-切蛋糕-前缀和"><a href="#洛谷-P1714-切蛋糕-前缀和" class="headerlink" title="洛谷-P1714 切蛋糕 前缀和"></a>洛谷-P1714 切蛋糕 前缀和</h2><ul>
<li>就是把求最小值改成了前缀和，一样的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;k)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;s[i]&lt;=s[q.<span class="built_in">back</span>()])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,s[i]-s[q.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="总结一下（易错点）："><a href="#总结一下（易错点）：" class="headerlink" title="总结一下（易错点）："></a><strong>总结一下（易错点）：</strong></h3><ol>
<li>如果是求前面的最小值的话，此时 <code>deque</code> 的初始加入的数不能是 <code>0</code>，必须是 <code>1</code>，如果是前缀和这样的，就可以是 <code>0</code>。</li>
<li>如果是不包括 $i$ 的前面 $m$ 个的最小值，因此我把那个输出放在弹出队首之后和弹出队尾之前的操作。反之如果包括，则写在下面。</li>
</ol>
<hr>
<h2 id="洛谷-P2629-好消息，坏消息"><a href="#洛谷-P2629-好消息，坏消息" class="headerlink" title="洛谷 - P2629 好消息，坏消息"></a>洛谷 - P2629 好消息，坏消息</h2><ul>
<li>因为这道题有跨区间（就是从 $[k,n]$ $[1,k-1]$），那么可以扩展数组，那么此时这些区间的长度就是固定的了，那么我们就可以用单调队列来维护了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],w[i+n]=w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m=n;</span><br><span class="line">    n*=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;m)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;s[i]&lt;=s[q.<span class="built_in">back</span>()])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[q.<span class="built_in">front</span>()]-s[i-m]&gt;=<span class="number">0</span>)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复制数组有的时候很重要，特别对于移动或跨区间问题上。</p>
</blockquote>
<h2 id="洛谷-P2422-良好的感觉"><a href="#洛谷-P2422-良好的感觉" class="headerlink" title="洛谷 - P2422 良好的感觉"></a>洛谷 - P2422 良好的感觉</h2><ul>
<li>题目要求最大的值（区间内的最小值乘区间和的值），此时如果我们固定了最小的值，那岂不是很好算。根据这个思路，我们可以对于每一个数，看它往左最远能扩展到哪里，往右同理。这里就可以用栈来维护了。（悄悄地说一下，这道题好像也可用悬线法）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],s[N];<span class="comment">//考虑一个值它能作为什么区间的最小值，即它能向两边扩展多少</span></span><br><span class="line"><span class="type">int</span> L[N],R[N];</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;w[stk[top]]&gt;=w[i])&#123;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        L[i]=stk[top];</span><br><span class="line">        stk[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    stk[<span class="number">0</span>]=n<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;w[stk[top]]&gt;=w[i])top--;</span><br><span class="line">        R[i]=stk[top]<span class="number">-1</span>;</span><br><span class="line">        stk[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)ans=<span class="built_in">max</span>(ans,(s[R[i]]-s[L[i]])*w[i]);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1540-机器翻译-1"><a href="#洛谷-P1540-机器翻译-1" class="headerlink" title="洛谷 - P1540 机器翻译"></a>洛谷 - P1540 机器翻译</h2><ul>
<li>题目叫我们查找查词典次数，查词典次数被定义为如果内存中有（此时我们可以用队列来维护内存，因为内存的大小是固定的），那么就可以增加答案了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            S.<span class="built_in">insert</span>(x);</span><br><span class="line">            ans++;</span><br><span class="line">            q.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(q.sz&gt;m)S.<span class="built_in">erase</span>(q.<span class="built_in">front</span>()),q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P3957-跳房子-区间不固定的单调队列"><a href="#洛谷-P3957-跳房子-区间不固定的单调队列" class="headerlink" title="洛谷 - P3957  跳房子 区间不固定的单调队列"></a>洛谷 - P3957  跳房子 区间不固定的单调队列</h2><ul>
<li>可以发现：这道题的弹跳距离是个范围。而且这道题具有二段性，也就是如果低于了这个值，那么可能跳不过去。这里得特别注意区间是个范围的单调队列的写法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=d)&#123;</span><br><span class="line">        l=<span class="number">1</span>,r=x+d;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l=d-x,r=x+d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n+n,<span class="number">-1e18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;j&amp;&amp;w[i].fi-w[j].fi&gt;=l)&#123;<span class="comment">//区间不固定，也就是区间是个大范围都是这么写</span></span><br><span class="line">            <span class="keyword">while</span>(q.sz&amp;&amp;f[q.<span class="built_in">back</span>()]&lt;=f[j])q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(j++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;w[i].fi-w[q.<span class="built_in">front</span>()].fi&gt;r)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(q.sz)f[i]=f[q.<span class="built_in">front</span>()]+w[i].se;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;=k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i].fi&gt;&gt;w[i].se,s+=(w[i].se&gt;<span class="number">0</span>?w[i].se:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s&lt;k)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1725-琪露诺"><a href="#洛谷-P1725-琪露诺" class="headerlink" title="洛谷 - P1725 琪露诺"></a>洛谷 - P1725 琪露诺</h2><ul>
<li>这道题和上一道题类似，只不过得注意：只要她下一步的位置编号大于 $N$ 就算到达对岸。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n*<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;j&amp;&amp;i-j&gt;=L)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.sz&amp;&amp;f[q.<span class="built_in">back</span>()]&lt;=f[j])q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(j++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;R)q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(q.sz)f[i]=f[q.<span class="built_in">front</span>()]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,n,n*<span class="number">3</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>总结：区间是个范围的单调队列来维护最大/最小值的写法：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FOR</span>(i,<span class="number">0</span>,n*<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;j&amp;&amp;i-j&gt;=L)&#123;<span class="comment">//L,R是区间范围</span></span><br><span class="line">        <span class="keyword">while</span>(q.sz&amp;&amp;f[q.<span class="built_in">back</span>()]&lt;=f[j])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.sz&amp;&amp;i-q.<span class="built_in">front</span>()&gt;R)q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span>(q.sz)f[i]=f[q.<span class="built_in">front</span>()]+w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="洛谷-P2776-小组队列"><a href="#洛谷-P2776-小组队列" class="headerlink" title="洛谷 - P2776 小组队列"></a>洛谷 - P2776 小组队列</h2><ul>
<li>这道题存在在特定的位置上插入值，此时得考虑链表。</li>
</ul>
<blockquote>
<p>deque双端队列是一个很好的办法 deque的操作:</p>
<p>void push_front(const T&amp; x):双端队列头部增加一个元素X</p>
<p>void push_back(const T&amp; x):双端队列尾部增加一个元素x</p>
<p>void pop_front():删除双端队列中最前一个元素</p>
<p>void pop_back():删除双端队列中最后一个元素</p>
<p>iterator begin():返回向量头指针，指向第一个元素</p>
<p>iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line">list&lt;<span class="type">int</span>&gt;lst;</span><br><span class="line">deque&lt;list&lt;<span class="type">int</span>&gt;::iterator&gt;pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(pos[w[x]].sz)&#123;</span><br><span class="line">                it=*(--pos[w[x]].<span class="built_in">end</span>());</span><br><span class="line">                it++;</span><br><span class="line">                pos[w[x]].<span class="built_in">push_back</span>(lst.<span class="built_in">insert</span>(it,x));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lst.<span class="built_in">push_back</span>(x);</span><br><span class="line">                it=--lst.<span class="built_in">end</span>();</span><br><span class="line">                pos[w[x]].<span class="built_in">push_back</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            it=lst.<span class="built_in">begin</span>();</span><br><span class="line">            cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">            pos[w[*it]].<span class="built_in">pop_front</span>();</span><br><span class="line">            lst.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Task = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; Task; Task--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h1><h2 id="HDU-1062-Text-Reverse"><a href="#HDU-1062-Text-Reverse" class="headerlink" title="HDU - 1062 Text Reverse"></a>HDU - 1062 Text Reverse</h2><ul>
<li>模拟。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    s+=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>&amp;&amp;s[i]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            S.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(S.sz)&#123;</span><br><span class="line">                cout&lt;&lt;S.<span class="built_in">top</span>();</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2947-Look-Up-S"><a href="#洛谷-P2947-Look-Up-S" class="headerlink" title="洛谷 - P2947 Look Up S"></a>洛谷 - P2947 Look Up S</h2><ul>
<li>这里得从大到小去维护栈，因为奶牛是往右看的，右边的高，栈能维护从 $n$ 到 $i$ 最高的奶牛的下标。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(S.sz&amp;&amp;w[S.<span class="built_in">top</span>()]&lt;=w[i])S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(S.sz)ans[i]=S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P5788-单调栈"><a href="#洛谷-P5788-单调栈" class="headerlink" title="洛谷 - P5788 单调栈"></a>洛谷 - P5788 单调栈</h2><ul>
<li>和上一道类似。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(S.sz&amp;&amp;w[S.<span class="built_in">top</span>()]&lt;=w[i])S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(S.sz)ans[i]=S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="洛谷-P1449-后缀表达式"><a href="#洛谷-P1449-后缀表达式" class="headerlink" title="洛谷 - P1449 后缀表达式"></a>洛谷 - P1449 后缀表达式</h2><ul>
<li>就是维护两个栈，一个是符号栈，另一个是数字栈。符号栈还有优先级，优先级高的先运算。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    s.<span class="built_in">pop_back</span>();</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;S;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            S.<span class="built_in">push</span>(res);</span><br><span class="line">            res=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            res=(res&lt;&lt;<span class="number">3</span>)+(res&lt;&lt;<span class="number">1</span>)+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> a=S.<span class="built_in">top</span>();S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> b=S.<span class="built_in">top</span>();S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>)S.<span class="built_in">push</span>(a+b);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>)S.<span class="built_in">push</span>(b-a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)S.<span class="built_in">push</span>(b/a);</span><br><span class="line">            <span class="keyword">else</span> S.<span class="built_in">push</span>(b*a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;S.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="洛谷-P1739-表达式括号匹配"><a href="#洛谷-P1739-表达式括号匹配" class="headerlink" title="洛谷 - P1739 表达式括号匹配"></a>洛谷 - P1739 表达式括号匹配</h2><ul>
<li>这道题直接用栈维护，如果右括号多就不对，左括号到最后还有剩也不对。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;(&#x27;</span>)S.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!S.sz)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(!S.sz?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1981-表达式求值"><a href="#洛谷-P1981-表达式求值" class="headerlink" title="洛谷 - P1981  表达式求值"></a>洛谷 - P1981  表达式求值</h2><ul>
<li>这道题就是多了个中缀表达式转化成后缀表达式的操作以及判断括号是否匹配的操作。</li>
</ul>
<p>具体细节可看代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;S&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ovel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">char</span> c=op.<span class="built_in">top</span>();op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)num.<span class="built_in">push</span>((a+b)%<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)num.<span class="built_in">push</span>((a-b)%<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)num.<span class="built_in">push</span>((a*b)%<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">else</span> num.<span class="built_in">push</span>((a/b)%<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,s.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.sz&amp;&amp;s[j]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[j]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                res=((res&lt;&lt;<span class="number">3</span>)+(res&lt;&lt;<span class="number">1</span>)+s[j]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">10000</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(res);</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(op.sz&amp;&amp;S[op.<span class="built_in">top</span>()]&gt;=S[s[i]])<span class="built_in">ovel</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(op.sz)<span class="built_in">ovel</span>();</span><br><span class="line">    cout&lt;&lt;num.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1175-表达式的转换"><a href="#洛谷-P1175-表达式的转换" class="headerlink" title="洛谷 - P1175 表达式的转换"></a>洛谷 - P1175 表达式的转换</h2><ul>
<li>这道题比较复杂，得考虑表达式树，这种做法是通法，因为它能输出，每一步的运算过程以及可以输出后缀前缀中缀表达式。很方便。</li>
</ul>
<h3 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a><a href="https://blog.csdn.net/fireflylane/article/details/83017889">表达式树</a></h3><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><ol>
<li>先找根：有加减找最后一个加减，有乘除找最后一个乘除，否则找第一个幂。</li>
</ol>
<p>注意：括号内要看成一个整体（不然递归到后面会出错） 如果整个式子是形如 (xxxxx) 型要先把外括号去掉，且一定要对应。</p>
<ol>
<li><p>递归。</p>
</li>
<li><p>我们得知道：</p>
</li>
</ol>
<ul>
<li>树的结构。</li>
<li>叶子结点的数值。</li>
<li>每个节点的符号。（叶子结点就是” “）</li>
</ul>
<p><a href="https://www.luogu.com.cn/article/1phl9fzr">参考</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> ch[N];</span><br><span class="line"><span class="type">int</span> num[N],lf[N],rf[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        num[++cnt]=s[l]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch[cnt]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[l]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,l<span class="number">+1</span>,r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)t++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)t--;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==r)l++,r--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p,t=<span class="number">5</span>;<span class="comment">//t:+1-1*2/2^3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,l,r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tt=<span class="number">1</span>,j;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=l;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">&#x27;)&#x27;</span>)tt++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;(&#x27;</span>)tt--;</span><br><span class="line">                <span class="keyword">if</span>(!tt)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i=j;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;s[i]&gt;=<span class="string">&#x27;0&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>)&amp;&amp;t&gt;<span class="number">1</span>)p=i,t=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i]==<span class="string">&#x27;*&#x27;</span>||s[i]==<span class="string">&#x27;/&#x27;</span>)&amp;&amp;t&gt;<span class="number">2</span>)p=i,t=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i]==<span class="string">&#x27;^&#x27;</span>)&amp;&amp;t&gt;<span class="number">3</span>)p=i,t=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x=++cnt;</span><br><span class="line">    ch[x]=s[p];</span><br><span class="line">    lf[x]=cnt<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,p<span class="number">-1</span>);</span><br><span class="line">    rf[x]=cnt<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)<span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> a-b;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)<span class="keyword">return</span> a*b;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;/&#x27;</span>)<span class="keyword">return</span> a/b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmi</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[u]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        cout&lt;&lt;num[u]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(lf[u]),<span class="built_in">print</span>(rf[u]);</span><br><span class="line">    cout&lt;&lt;ch[u]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[x]==<span class="string">&#x27; &#x27;</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(lf[x]);</span><br><span class="line">    <span class="built_in">dfs</span>(rf[x]);</span><br><span class="line">    num[x]=<span class="built_in">calc</span>(num[lf[x]],num[rf[x]],ch[x]);</span><br><span class="line">    ch[x]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>,s.sz<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1-4-二叉树与哈夫曼树"><a href="#1-4-二叉树与哈夫曼树" class="headerlink" title="1.4 二叉树与哈夫曼树"></a>1.4 二叉树与哈夫曼树</h1><h2 id="HDU-2527-Safe-Or-Unsafe"><a href="#HDU-2527-Safe-Or-Unsafe" class="headerlink" title="HDU - 2527 Safe Or Unsafe"></a>HDU - 2527 Safe Or Unsafe</h2><ul>
<li>就是算huffman编码，因为一个字母的权值等于该字母在字符串中出现的频率。$WPL$ 的算法就是两个两个堆合并的过程。具体细节可看代码。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;t&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">p</span><span class="params">(<span class="number">30</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        p[x-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,VI,greater&lt;<span class="type">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">25</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(a+b);</span><br><span class="line">        res+=a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!res)res=q.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res&lt;=t)cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1087-FBI-树"><a href="#洛谷-P1087-FBI-树" class="headerlink" title="洛谷 - P1087 FBI 树"></a>洛谷 - P1087 FBI 树</h2><ul>
<li>就是递归（因为递归本身也就是栈）。要找后序遍历，就把输出放在后面即可（回溯位置）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">FBI</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">FBI</span>(p.<span class="built_in">substr</span>(<span class="number">0</span>,p.sz/<span class="number">2</span>));</span><br><span class="line">        cout&lt;&lt;<span class="built_in">FBI</span>(p.<span class="built_in">substr</span>(p.sz/<span class="number">2</span>,p.sz/<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t0=p.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>),t1=p.<span class="built_in">find</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(t0!=<span class="number">-1</span>&amp;&amp;t1!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(t0!=<span class="number">-1</span>&amp;&amp;t1==<span class="number">-1</span>)<span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(t0==<span class="number">-1</span>&amp;&amp;t1!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">FBI</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1030-求先序排列"><a href="#洛谷-P1030-求先序排列" class="headerlink" title="洛谷 - P1030 求先序排列"></a>洛谷 - P1030 求先序排列</h2><ul>
<li>已知中序与后序排列，求先序遍历。根据每种遍历的结构，比如先序遍历的结构是 <code>根 左子树 右子树</code>。那么可以很容易写出代码。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string sa,string sb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sa.sz&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;sb[sb.sz<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> t=sa.<span class="built_in">find</span>(sb[sb.sz<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">dfs</span>(sa.<span class="built_in">substr</span>(<span class="number">0</span>,t),sb.<span class="built_in">substr</span>(<span class="number">0</span>,t));</span><br><span class="line">        <span class="built_in">dfs</span>(sa.<span class="built_in">substr</span>(t<span class="number">+1</span>),sb.<span class="built_in">substr</span>(t,sa.sz<span class="number">-1</span>-t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1305-新二叉树"><a href="#洛谷-P1305-新二叉树" class="headerlink" title="洛谷 - P1305 新二叉树"></a>洛谷 - P1305 新二叉树</h2><ul>
<li>这就是建一颗树即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">char</span> l,r;</span><br><span class="line">&#125;w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">char</span> rt,<span class="type">char</span> l,<span class="type">char</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;rt;</span><br><span class="line">    <span class="keyword">if</span>(l)<span class="built_in">dfs</span>(l,w[l].l,w[l].r);</span><br><span class="line">    <span class="keyword">if</span>(r)<span class="built_in">dfs</span>(r,w[r].l,w[r].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            c=s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>]!=<span class="string">&#x27;*&#x27;</span>)w[s[<span class="number">0</span>]].l=s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">2</span>]!=<span class="string">&#x27;*&#x27;</span>)w[s[<span class="number">0</span>]].r=s[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(c,w[c].l,w[c].r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1229-遍历问题"><a href="#洛谷-P1229-遍历问题" class="headerlink" title="洛谷 - P1229 遍历问题"></a>洛谷 - P1229 遍历问题</h2><ul>
<li>从当前遍历节点来看，如果不是链的话，受到左右节点影响，显然先序和后序遍历的子树开头和结尾两个字符不会相等。因此可以发现满足上述条件的唯一情况就是从当前节点开始的子树的是链的情况，接下来可以选择把子树放到左边，也可以选择放到右边，答案 $×2$ 即可。总的来说就是如果只有一个儿子的话，那么它可以是左儿子也可以是右儿子。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,a.sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,b.sz<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]&amp;&amp;a[i<span class="number">+1</span>]==b[j<span class="number">-1</span>])&#123;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P5018-对称二叉树"><a href="#洛谷-P5018-对称二叉树" class="headerlink" title="洛谷 - P5018  对称二叉树"></a>洛谷 - P5018  对称二叉树</h2><ul>
<li>只需要判断每个节点的子树是否为对称二叉树，然后计算该子树的节点个数就行了。<img src="https://cdn.luogu.com.cn/upload/image_hosting/i7uonvng.png" alt=""><br>当到节点 $x$ 时，需要满足 $v<em>{l_x}=v</em>{r<em>x}$。到节点 $y$ 和 $z$ 时，需要满足 $v</em>{l<em>y}=v</em>{r<em>z}$ 和 $v</em>{r<em>y}=v</em>{l_z}$。若其中 $l,r$ 其中一个的值为 $-1$ 或 $v$ 不相等，那么它就不是对称二叉树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N];</span><br><span class="line"><span class="type">int</span> l[N],r[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(l[u]);</span><br><span class="line">    siz[u]+=siz[l[u]];</span><br><span class="line">    <span class="built_in">dfs1</span>(r[u]);</span><br><span class="line">    siz[u]+=siz[r[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">-1</span>&amp;&amp;y==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">-1</span>||y==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(w[x]!=w[y])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs2</span>(l[x],r[y])&amp;&amp;<span class="built_in">dfs2</span>(r[x],l[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs2</span>(i,i))&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,siz[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P5597-复读"><a href="#洛谷-P5597-复读" class="headerlink" title="洛谷 - P5597  复读"></a>洛谷 - P5597  复读</h2><ul>
<li>很神奇<a href="https://www.luogu.com.cn/article/n0mlpy4y">看解题的</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;tr[N],tr2[N];<span class="comment">//每次指令后都不可能返回祖先节点了</span></span><br><span class="line"><span class="comment">//到下一个灰色点之前必须先把上面部分全部访问完,否则就不可能回去了</span></span><br><span class="line"><span class="type">int</span> tot,p1,p2,tot2,ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> p=++tot;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>||t==<span class="number">3</span>)tr[p].l=<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>||t==<span class="number">3</span>)tr[p].r=<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;<span class="comment">//合并树</span></span><br><span class="line">    <span class="keyword">if</span>(p==p1||q==p2)p2=q,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr2[q].l)tr2[q].l=++tot2;</span><br><span class="line">        <span class="built_in">dfs</span>(tr[p].l,tr2[q].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr2[q].r)tr2[q].r=++tot2;</span><br><span class="line">        <span class="built_in">dfs</span>(tr[p].r,tr2[q].r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">    p1=u,p2=<span class="number">0</span>,tot2=<span class="number">1</span>;<span class="comment">//p1是原树，p2是合并树</span></span><br><span class="line">    <span class="built_in">memset</span>(tr2,<span class="number">0</span>,<span class="keyword">sizeof</span> tr2);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,tot2);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="number">2</span>*(tot2<span class="number">-1</span>)-dep);</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l)<span class="built_in">calc</span>(tr[u].l,dep<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tr[u].r)<span class="built_in">calc</span>(tr[u].r,dep<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2168-荷马史诗"><a href="#洛谷-P2168-荷马史诗" class="headerlink" title="洛谷 - P2168 荷马史诗"></a>洛谷 - P2168 荷马史诗</h2><ul>
<li>典型的 $k$ 叉树。</li>
</ul>
<blockquote>
<p>对于 $k$ 叉哈夫曼树的求解,直观的想法是在贪心的基础上,改为每次从堆中去除最小的 $k$ 个权值合并。然而，仔细思考可以发现，如果在执行最后一次循环时，堆的大小在（2~k-1）之间（不足以取出 k 个），那么整个哈夫曼树的根的子节点个数就小于k。这显然不是最优解————我们任意取哈夫曼树中一个深度最大的节点，改为树根的子节点，就会使 $∑w_i\times l_i$  变小。因此，我们应该在执行上述贪心算法之前，补加一些额外的权值为0的叶子节点，使叶子节点的个树满足(n-1)%(k-1)=0。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII,VPII,GII&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((n<span class="number">-1</span>)%(k<span class="number">-1</span>))&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);<span class="comment">//补节点</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dep=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">            sum+=q.<span class="built_in">top</span>().fi;</span><br><span class="line">            dep=<span class="built_in">max</span>(dep,q.<span class="built_in">top</span>().se);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        res+=sum;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;sum,dep<span class="number">+1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl&lt;&lt;q.<span class="built_in">top</span>().se&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-5-堆"><a href="#1-5-堆" class="headerlink" title="1.5 堆"></a>1.5 堆</h1><h2 id="洛谷-P3378-堆"><a href="#洛谷-P3378-堆" class="headerlink" title="洛谷 - P3378 堆"></a>洛谷 - P3378 堆</h2><ul>
<li>模拟</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> op,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1090-合并果子"><a href="#洛谷-P1090-合并果子" class="headerlink" title="洛谷 - P1090 合并果子"></a>洛谷 - P1090 合并果子</h2><ul>
<li>每次拿去两个较小的果子，这里就可以用堆来维护了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        q.<span class="built_in">push</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=a+b;</span><br><span class="line">        q.<span class="built_in">push</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1168-中位数"><a href="#洛谷-P1168-中位数" class="headerlink" title="洛谷 - P1168 中位数"></a>洛谷 - P1168 中位数</h2><ul>
<li>如果直接用排序加取中位数的方法，时间复杂度很高，因此可以想到对顶堆来做。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(q<span class="number">1.</span>sz&gt;q<span class="number">2.</span>sz)&#123;</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">push</span>(q<span class="number">1.</span><span class="built_in">top</span>());</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q<span class="number">2.</span>sz&gt;q<span class="number">1.</span>sz)&#123;</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">push</span>(q<span class="number">2.</span><span class="built_in">top</span>());</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;q<span class="number">1.</span><span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2085-最小函数值"><a href="#洛谷-P2085-最小函数值" class="headerlink" title="洛谷 - P2085 最小函数值"></a>洛谷 - P2085 最小函数值</h2><ul>
<li>就是搞一个堆，然后把函数的值都放进去。这边存在一个优化，就是这边先把 $x=1$ 带入每个函数里面去，然后把这些得到的值都放入堆中，然后从堆中取出较小的值，然后把 $x+1$ 的值又放入堆中，这样是最优的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,x,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y&gt;t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;E&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;a[i]+b[i]+c[i],<span class="number">1</span>,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        E t=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;t.y&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;a[t.id]*(t.x<span class="number">+1</span>)*(t.x<span class="number">+1</span>)+b[t.id]*(t.x<span class="number">+1</span>)+c[t.id],t.x<span class="number">+1</span>,t.id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P2827-蚯蚓"><a href="#洛谷-P2827-蚯蚓" class="headerlink" title="洛谷 - P2827 蚯蚓"></a>洛谷 - P2827 蚯蚓</h2><ul>
<li>这道题如果每次切断都去维护一下堆的话，时间复杂度特别高，因此对于堆，如果要优化，一般想到的都是队列。首先我们明白一个不等式 $x_1-\lfloor px_1 \rfloor \ge x_2 \lfloor px_2 \rfloor$，具体证明过程请 <a href="https://www.luogu.com.cn/article/hgnmtohe">看，包含所有细节</a>。根据这个不等式，我们可以考虑维护三个队列，而不必维护一个优先队列，因为三个队列始终保持满足单调性，无需使用优先队列。然后根据此思路即可拿到所有 $q = 0$ 的分，接下来为了解决 $q \gt 0$，通常方法都是计个 $tag$，加入队列时把两段都减掉一个 $q$，$tag$ 加上一个 $q$。考虑到一条在第 $i$ 时刻加入的长度为 $len$ 蚯蚓，如果在第 $j$ 时刻被拿出来砍，因为它一共经历了 $j - i - 1$ 次切割，一次切割长度加 $q$，所以总长度是 $q \times (j - i - 1) + len$。<strong>可以在常数时间内算出</strong>，不必打 $tag$ 标记，只需多存个加入时间。  </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,q,u,v,t,w[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;qw[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// int INF=1e18;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n,<span class="built_in">GI</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        qw[<span class="number">1</span>].<span class="built_in">push</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        PII tt=<span class="built_in">max</span>(&#123;</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">1</span>].sz?qw[<span class="number">1</span>].<span class="built_in">front</span>():INF,<span class="number">1</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">2</span>].sz?qw[<span class="number">2</span>].<span class="built_in">front</span>():INF,<span class="number">2</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">3</span>].sz?qw[<span class="number">3</span>].<span class="built_in">front</span>():INF,<span class="number">3</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> x=tt.fi+q*i,y=tt.se;</span><br><span class="line">        qw[y].<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%t==t<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> b=x*u/v,c=x-b;</span><br><span class="line">        qw[<span class="number">2</span>].<span class="built_in">push</span>(b-q-q*i);</span><br><span class="line">        qw[<span class="number">3</span>].<span class="built_in">push</span>(c-q-q*i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n+m)&#123;</span><br><span class="line">        PII tt=<span class="built_in">max</span>(&#123;</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">1</span>].sz?qw[<span class="number">1</span>].<span class="built_in">front</span>():INF,<span class="number">1</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">2</span>].sz?qw[<span class="number">2</span>].<span class="built_in">front</span>():INF,<span class="number">2</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(qw[<span class="number">3</span>].sz?qw[<span class="number">3</span>].<span class="built_in">front</span>():INF,<span class="number">3</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> x=tt.fi,y=tt.se;</span><br><span class="line">        qw[y].<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;x+q*m&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P3045-Cow-Coupons-G"><a href="#洛谷-P3045-Cow-Coupons-G" class="headerlink" title="洛谷 - P3045  Cow Coupons G"></a>洛谷 - P3045  Cow Coupons G</h2><ul>
<li>反悔贪心的题目。<blockquote>
<p>反悔贪心是什么？</p>
<p>答：其实贪心本身不带有反悔，是因为此时的贪心可以从局部最优解推出全局最优解。但当有些时候局部最优解推不出全局最优解时，就要用反悔贪心，在适当的时候撤销之前做出的决策。</p>
</blockquote>
</li>
<li>我们先选取 $c$ 最小的 $k$ 个物品使用优惠劵，当前已经使用的价格是 $tot$。下文为方便表述，记使用优惠劵的物品集合为 $A$，他在求解过程中不是固定不变的。<br>当前考虑第 $i$ 个物品，由于 $k$ 张优惠券已经用完了，所以只能以原价 $p_i$ 购买物品 $i$。现在考虑反不反悔的条件是什么。<br>如果要反悔，那么用优惠券买 $i$ 的价格一定要小于用原价买 $i$。当 $i$ 用了优惠券，那么 $A$ 势必要有一个物品（记为 $j,j \in A$）做出退让，用原价来买 $j$。（其实相当于用 $i$ 来代替 $j$），那么一定满足以下不等式：</li>
</ul>
<script type="math/tex; mode=display">tot-c_j+p_j+c_i\lt tot+p_i</script><p>意思是：$i$ 代替 $j$ 用优惠券的价格比用原价买 $i$ 便宜，这个时候就需要反悔。<br>发现 $tot$ 可以消去：</p>
<script type="math/tex; mode=display">-c_j+p_j+c_i\lt p_i</script><p>然后把下标相同的归在小于号的同一侧：</p>
<script type="math/tex; mode=display">p_j-c_j\lt p_i-c_i</script><p>他们的形式是相同的，所以我们可以设 $\Delta_i=p_i-c_i$：</p>
<script type="math/tex; mode=display">\Delta_j\lt\Delta_i</script><p>所以只要在已经使用优惠券的物品里面，存在一个 $j$，使得 $\Delta<em>j\lt\Delta_i$，我们就需要用 $i$ 代替 $j$ 使用优惠券。也就是 $k$ 个物品中，$(\Delta_j)</em>{\min}\lt\Delta_i$ 。注意这个不是恒等式，因为 $i \notin A$，但是 $j\in A$。<br>最小值可以用优先队列来求。</p>
<p><a href="https://www.luogu.com.cn/article/zg562iym">引用</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="type">int</span> p[N],c[N];</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,GII&gt;P,C;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,VI,GI&gt;delta;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">        P.<span class="built_in">push</span>(&#123;p[i],i&#125;);</span><br><span class="line">        C.<span class="built_in">push</span>(&#123;c[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,k)delta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(P.sz)&#123;</span><br><span class="line">        PII x=P.<span class="built_in">top</span>();</span><br><span class="line">        PII y=C.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[x.se])&#123;</span><br><span class="line">            P.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[y.se])&#123;</span><br><span class="line">            C.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原价买比按优惠价买并且补上差价便宜的话，我们就就用原价买</span></span><br><span class="line">        <span class="keyword">if</span>(delta.<span class="built_in">top</span>()+y.fi&gt;x.fi)&#123;<span class="comment">//用原价买 i 更划算</span></span><br><span class="line">            m-=x.fi;</span><br><span class="line">            vis[x.se]=<span class="number">1</span>;</span><br><span class="line">            P.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//用优惠券买 i 更划算</span></span><br><span class="line">            m-=y.fi+delta.<span class="built_in">top</span>();</span><br><span class="line">            vis[y.se]=<span class="number">1</span>;</span><br><span class="line">            C.<span class="built_in">pop</span>();</span><br><span class="line">            delta.<span class="built_in">pop</span>();</span><br><span class="line">            delta.<span class="built_in">push</span>(p[y.se]-c[y.se]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="待深入总结"><a href="#待深入总结" class="headerlink" title="待深入总结"></a>待深入总结</h2>]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点系列——数据结构</title>
    <url>/2025/02/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h1><ul>
<li>概念： 给定一棵无向树，包含 $n$ 个点 $n-1$ 条边，在树中任意两个点之间加一条边，此时树中<strong>有且仅有</strong>一个环，此时整棵树的形状应该是以环为中心，环上每个点都可能向环外延伸出一棵子树，这就是一棵基环树。</li>
<li>性质：</li>
</ul>
<ol>
<li>对于每棵基环树，恰好有 $n$ 个点 $n$ 条边。</li>
<li>可以发现，仙人掌是有多个简单环，而基环树只有一个简单环，因此基环树其实是一个特殊的仙人掌。</li>
<li>如果给基环树中每条边一个方向，环上边的方向都要一致，如果以环上每个点为根的子树上的边都是指向环外，则称为外向树。如果以环上每个点为根的子树上的边都是指向环内，则称为内向树。</li>
<li>若干棵基环树构成的图，被称为基环（树）森林。若干棵外向树构成的图，被称为外向树森林。若干棵内向树构成的图，被称为内向树森林。</li>
<li>对于一张图，如果图中每个点恰好有 $1$ 条入边或恰好有 $1$ 条出边，那么这张图一定是一个基环森林。</li>
</ol>
<p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/7958357/">参考</a></p>
<ul>
<li>应用：基环树问题的常见题型就是求树上的某些信息。</li>
</ul>
<h2 id="P1399-NOI2013-快餐店"><a href="#P1399-NOI2013-快餐店" class="headerlink" title="P1399 [NOI2013] 快餐店"></a>P1399 [NOI2013] 快餐店</h2><ul>
<li><p>题意：给定一张图，包含 $n$ 个点，每个点都有一个父节点。让你在某一处（可以在点上，也可以在边上）安置一个快餐店使得整张图上离它最远的点最近。</p>
</li>
<li><p>思路：根据<strong>每个点都有一个父节点</strong>可以知道：这张图是基环树。要求与最远的顾客之间的距离，那么我们肯定很容易想到在树的直径的终点放快餐店。由于这张图是基环树，有一个朴素的想法：我们可以考虑每次破掉环上的一条边使它变成一颗树，然后求出直径，最后统计所有的直径中最短的那个作为答案即可。但这个的时间复杂度是 $O(n^2)$，此时考虑优化：我们先考虑整个图上的直径可能存在的情况：1.这个直径完全在环上某一点所在的子树中。2.这个直径从环上某一点所在子树出发，到达该点后在环上走过一些边到达另一个点，进入该点所在子树并且结束。此时第一种情况就比较好算，直接维护每一颗子树的直径即可。对于第二种情况，我们容易发现直径在某个子树内的部分一定是从该子树的根出发的最长路径，也就是该树的<strong>最大深度</strong>。所以我们预先处理环上所有点所在子树的深度。然后通过预处理出 $A,B,C,D$ 数组，然后再通过切断环上第 $i$ 号点求直径（$B<em>i,D_i,A_i+C</em>{i+1}+tmp$）<a href="https://www.luogu.com.cn/article/qm5qkbsm">具体的ABCD什么意思这篇文章讲的很清楚</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt;G[N];</span><br><span class="line"><span class="type">int</span> din[N],fa[N],w[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> inc[N],cv[N],cw[N],cnt;</span><br><span class="line"><span class="type">double</span> ans1,ans2=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">double</span> A[N],B[N],C[N],D[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,v]:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">        fa[j]=u,w[j]=v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(j))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> p=u;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                inc[p]=<span class="number">1</span>,cv[++cnt]=p;</span><br><span class="line">                cw[cnt]=w[p];</span><br><span class="line">                p=fa[p];</span><br><span class="line">                <span class="keyword">if</span>(p==u)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,v]:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=fa&amp;&amp;!inc[j])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j,u);</span><br><span class="line">            ans1=<span class="built_in">max</span>(ans1,d[u]+d[j]+v);</span><br><span class="line">            d[u]=<span class="built_in">max</span>(d[u],d[j]+v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        G[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(cv[i],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//断开(1,cnt)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        sum+=cw[i<span class="number">-1</span>];</span><br><span class="line">        A[i]=<span class="built_in">max</span>(A[i<span class="number">-1</span>],sum+d[cv[i]]);<span class="comment">//前缀中链长度+节点深度</span></span><br><span class="line">        B[i]=<span class="built_in">max</span>(B[i<span class="number">-1</span>],mx+sum+d[cv[i]]);<span class="comment">//前缀中两棵树的深度+两节点的距离</span></span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum=mx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> cn=cw[cnt];</span><br><span class="line">    cw[cnt]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        sum+=cw[i];</span><br><span class="line">        C[i]=<span class="built_in">max</span>(C[i<span class="number">+1</span>],sum+d[cv[i]]);</span><br><span class="line">        D[i]=<span class="built_in">max</span>(D[i<span class="number">+1</span>],mx+sum+d[cv[i]]);</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,d[cv[i]]-sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)&#123;<span class="comment">//枚举断开环边拼凑答案</span></span><br><span class="line">        res=<span class="built_in">max</span>(&#123;B[i],D[i<span class="number">+1</span>],A[i]+C[i<span class="number">+1</span>]+cn&#125;);</span><br><span class="line">        ans2=<span class="built_in">min</span>(ans2,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans2=<span class="built_in">min</span>(ans2,B[cnt]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1Lf&quot;</span>,<span class="built_in">max</span>(ans1,ans2)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P5022-NOIP-2018-提高组-旅行"><a href="#P5022-NOIP-2018-提高组-旅行" class="headerlink" title="P5022 [NOIP 2018 提高组] 旅行"></a>P5022 [NOIP 2018 提高组] 旅行</h2><ul>
<li><p>题意：给定一个基环树，求第一次去到每个点的字典序最小的编号顺序。</p>
</li>
<li><p>思路：如果是普通的树（$n=m+1$），我们直接走字典序小的点就可以了，这部分可以对每个点的出边进行排序即可。如果是基环树（$n\not=m+1$），可以考虑暴力删边，此时就是将基环树转化成普通树，然后对于每一次暴力删边的结果进行深搜遍历。（时间复杂度 $O(n^2)$）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力删边即可对于基环树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> path[N],better,cnt;</span><br><span class="line">PII e[N];</span><br><span class="line"><span class="type">int</span> du,dv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!better)&#123;</span><br><span class="line">        <span class="comment">//若序号变大则退回，变小则走完</span></span><br><span class="line">        <span class="keyword">if</span>(u&gt;path[cnt])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&lt;path[cnt])better=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    path[cnt++]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(v==du&amp;&amp;u==dv)<span class="keyword">continue</span>;<span class="comment">//遇到断边</span></span><br><span class="line">        <span class="keyword">if</span>(v==dv&amp;&amp;u==du)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(v))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//枚举断点</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">        e[i]=&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(),G[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==m<span class="number">+1</span>)<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            du=e[i].x,dv=e[i].y;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">            cnt=better=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树上启发式合并-dsu-on-tree"><a href="#树上启发式合并-dsu-on-tree" class="headerlink" title="树上启发式合并 dsu on tree"></a>树上启发式合并 dsu on tree</h1><ul>
<li><p>概念：首先得知道轻子树和重子树概念（树链剖分）。</p>
</li>
<li><p>使用场景: 1.统计/查询一颗树所有子树内节点的信息。2.每次要合并两个集合的时候，我们可以每次把较小集合的元素合并到较大集合中去，这样就能保证时间复杂度为：$O(nlogn)$。</p>
</li>
</ul>
<blockquote>
<p>也就是：只支持子树查询，不支持修改操作。</p>
</blockquote>
<ul>
<li><p>原理：贪心。</p>
</li>
<li><p>性质：</p>
</li>
</ul>
<ol>
<li>一个点总是有1个重儿子, 除了叶子节点。</li>
<li>一个点可能是父节点的重儿子, 但不一定再重链上。</li>
<li>一个点至多往上走logn步就被合并到重链。</li>
</ol>
<ul>
<li><p>实现方法：对于每个节点, 总是先统计 ”轻” 子树, 并将桶清空, 最后统计 ”重” 子树, 并将桶保留。（这样能保证时间复杂度是 $O(nlogn)$，都是把轻子树合并到重子树中去）</p>
</li>
<li><p>步骤：</p>
</li>
</ul>
<ol>
<li>先跑重链剖分，预处理出每个节点的重儿子;</li>
<li>dfs，对于节点 <code>u</code>，总是先统计轻子树的信息，再统计重子树信息，最后统计 <code>u</code> 的信息。看情况清空桶。</li>
<li>通常需要预处理将询问离线。</li>
</ol>
<p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/12548702/">参考</a></p>
<h2 id="CF600E-Lomsat-gelral"><a href="#CF600E-Lomsat-gelral" class="headerlink" title="CF600E Lomsat gelral"></a>CF600E Lomsat gelral</h2><ul>
<li><p>题意：求出以 $i$ 为根的子树中，占主导颜色（出现次数最多）的编号和。</p>
</li>
<li><p>思路：暴力搜索 $O(n^2)$，采取启发式合并。</p>
</li>
<li><p>具体做法：用 <code>cnt[i]</code> 记录颜色 <code>i</code> 的出现次数，对于节点 <code>u</code>，此时：</p>
</li>
</ul>
<ol>
<li><p>先遍历 <code>u</code> 的轻儿子，计算答案，但不保留它对答案的贡献（目的是更快的算重儿子的贡献）</p>
</li>
<li><p>遍历 <code>u</code> 的重儿子，保留贡献。</p>
</li>
<li><p>再遍历轻儿子。</p>
</li>
</ol>
<blockquote>
<p>注意：为什么不合并1、3步呢？</p>
<p>答：因为我们要重复使用 <code>cnt</code> 数组，且对于 <code>A</code> 子树不能影响 <code>B</code> 子树。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line"><span class="type">int</span> son[N],siz[N],cnt[N];</span><br><span class="line"><span class="type">int</span> sum,ans[N],mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j,u);</span><br><span class="line">        siz[u]+=siz[j];</span><br><span class="line">        <span class="keyword">if</span>(siz[son[u]]&lt;siz[j])&#123;</span><br><span class="line">            son[u]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> son)</span></span>&#123;</span><br><span class="line">    cnt[c[u]]++;</span><br><span class="line">    <span class="keyword">if</span>(cnt[c[u]]&gt;mx)mx=cnt[c[u]],sum=c[u];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt[c[u]]==mx)sum+=c[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=fa&amp;&amp;j!=son)<span class="built_in">add</span>(j,u,son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    cnt[c[u]]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=fa)<span class="built_in">sub</span>(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这边保留重儿子是因为轻儿子的贡献已经算在了重儿子内部（也就是合并了），因此要把轻儿子的贡献删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> opt)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先搜索轻儿子再到重儿子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa||j==son[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j,u,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[u])<span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add</span>(u,fa,son[u]);<span class="comment">//累加贡献（轻儿子和u的）</span></span><br><span class="line">    ans[u]=sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!opt)<span class="built_in">sub</span>(u,fa),sum=mx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CF1709E-XOR-Tree"><a href="#CF1709E-XOR-Tree" class="headerlink" title="CF1709E XOR Tree"></a>CF1709E XOR Tree</h2><ul>
<li><p>题意：定义一条路径 $P(u,v)$ 的权值为经过的所有点的点权的异或和，定义一棵树是合法的，当且仅当树上所有简单路径（只经过每个点一次的路径）的的权值都不为 $0$。你可以对权值进行修改，可以改成任意正整数，问最少修改多少次才能让这棵树合法。</p>
</li>
<li><p>思路：首先我们可以用前缀和来维护树上的异或关系。根据贪心我们可以知道：修改路径上 <code>lca</code> 的就能满足最小的条件。最后推导得到式子：<code>d[u]=d[v]^a[x]</code>（这个是非法路径），其中 <code>x</code> 为 <code>lca(u,v)</code>，<code>d[u]</code> 表示从根 $1$ 到 $u$ 的路径上所有点权的疑惑和，<code>a[u]</code> 表示 $u$ 的点权。那么此时我们只要把 $x=lca(u,v)$ 的点权改为很大的整数，就可以消除所有经过 $x$ 点的非法路径。即 $x$ 点相对于一个端点，对于代码上来说，就是把以 $x$ 为根的子树从桶中清空。具体实现就是：如果发现经过当前子树根的非法路径，直接答案+1，并清空当前子树的集合，如果没有发现，则把小集合合并到大集合中。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N],d[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt;S[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    S[u].<span class="built_in">insert</span>(d[u]);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[j]=d[u]^w[j];</span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(S[u].<span class="built_in">size</span>()&lt;S[j].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">swap</span>(S[u],S[j]);<span class="comment">//保证u是大集合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> z:S[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[u].<span class="built_in">find</span>(z^w[u])!=S[u].<span class="built_in">end</span>())f=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> z:S[j])&#123;</span><br><span class="line">            S[u].<span class="built_in">insert</span>(z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f)ans++,S[u].<span class="built_in">clear</span>();<span class="comment">//算完之后得清空数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b);</span><br><span class="line">        G[b].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是说：启发式合并不是一成不变的，它只是个优化算法，没有固定的模板。</p>
</blockquote>
<h1 id="线段树-树状数组"><a href="#线段树-树状数组" class="headerlink" title="线段树/树状数组"></a>线段树/树状数组</h1><ul>
<li>用法：可以用在区间查询区间修改的操作中。</li>
</ul>
<h2 id="P2572-SCOI2010-序列操作"><a href="#P2572-SCOI2010-序列操作" class="headerlink" title="P2572 [SCOI2010] 序列操作"></a>P2572 [SCOI2010] 序列操作</h2><ul>
<li>题意：给定如下操作：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 l r 把 [l,r] 区间内的所有数全变成 0；</span><br><span class="line">1 l r 把 [l,r] 区间内的所有数全变成 1；</span><br><span class="line">2 l r 把 [l,r] 区间内的所有数全部取反，也就是说把所有的 0 变成 1，把所有的 1 变成 0；</span><br><span class="line">3 l r 询问 [l,r] 区间内总共有多少个 1；</span><br><span class="line">4 l r 询问 [l,r] 区间内最多有多少个连续的 1。</span><br></pre></td></tr></table></figure></li>
<li>思路：线段树，但本道题有取反和赋值两个操作，此时就得开两个懒标记。对于有两个懒标记的情况，就得考虑优先级：<strong>一般来说：赋值标记优先级高于取反标记</strong>。然后要求区间内连续的 <code>1</code> ，就得添加 <code>lsum,rsum,tsum</code> 变量来求。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> b,lb,rb,mb;</span><br><span class="line">    <span class="type">int</span> c,lc,rc,mc;</span><br><span class="line">    <span class="type">int</span> len,tag,rev;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(E&amp; u,E l,E r)</span></span>&#123;</span><br><span class="line">    u.b=l.b+r.b;</span><br><span class="line">    u.lb=l.c?l.lb:l.b+r.lb;</span><br><span class="line">    u.rb=r.c?r.rb:r.b+l.rb;</span><br><span class="line">    u.mb=<span class="built_in">max</span>(&#123;l.mb,r.mb,l.rb+r.lb&#125;);</span><br><span class="line">    u.c=l.c+r.c;</span><br><span class="line">    u.lc=l.b?l.lc:l.c+r.lc;</span><br><span class="line">    u.rc=r.b?r.rc:r.c+l.rc;</span><br><span class="line">    u.mc=<span class="built_in">max</span>(&#123;l.mc,r.mc,l.rc+r.lc&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> opt)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">0</span>)&#123;</span><br><span class="line">        t.b=t.lb=t.rb=t.mb=<span class="number">0</span>;</span><br><span class="line">        t.c=t.lc=t.rc=t.mc=t.len;</span><br><span class="line">        t.tag=t.rev=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">        t.b=t.lb=t.rb=t.mb=t.len;</span><br><span class="line">        t.c=t.lc=t.rc=t.mc=<span class="number">0</span>;</span><br><span class="line">        t.tag=<span class="number">1</span>,t.rev=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(t.b,t.c),<span class="built_in">swap</span>(t.lb,t.lc);</span><br><span class="line">        <span class="built_in">swap</span>(t.rb,t.rc),<span class="built_in">swap</span>(t.mb,t.mc);</span><br><span class="line">        t.rev^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u],tr[u&lt;&lt;<span class="number">1</span>],tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">0</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">1</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(t.rev)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    t.tag=<span class="number">-1</span>;</span><br><span class="line">    t.rev=<span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=c[l];</span><br><span class="line">    tr[u]=&#123;l,r,t,t,t,t,t^<span class="number">1</span>,t^<span class="number">1</span>,t^<span class="number">1</span>,t^<span class="number">1</span>,r-l<span class="number">+1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    E res;</span><br><span class="line">    <span class="built_in">pushup</span>(res,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l++,r++;</span><br><span class="line">        <span class="keyword">if</span>(op&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,r,op);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            E t=<span class="built_in">query</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">                cout&lt;&lt;t.b&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;t.mb&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1972-SDOI2009-HH的项链"><a href="#P1972-SDOI2009-HH的项链" class="headerlink" title="P1972 [SDOI2009] HH的项链"></a>P1972 [SDOI2009] HH的项链</h2><ul>
<li><p>题意：询问某一段贝壳中，包含了多少种不同的贝壳。</p>
</li>
<li><p>思路：对于给定区间询问，往往有两种方式查询：<strong>在线查询、离线查询</strong>。很明显，本题离线查询更优，因为离线查询可以给查询排序，这样可以用类似双指针的思想来查询，大大降低时间复杂度。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于区间查询问题，要么在线处理，要么离线处理</span></span><br><span class="line"><span class="comment">//显然，本道题离线处理能减小时间复杂度</span></span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r&lt;t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        e[i]=&#123;l,r,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=last;j&lt;=e[i].r;j++)&#123;<span class="comment">//重叠部分被算过，因此不需要再跳到重叠部分</span></span><br><span class="line">            <span class="keyword">if</span>(vis[w[j]])<span class="built_in">add</span>(vis[w[j]],<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">add</span>(j,<span class="number">1</span>);</span><br><span class="line">            vis[w[j]]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        last=e[i].r<span class="number">+1</span>;</span><br><span class="line">        ans[e[i].id]=<span class="built_in">query</span>(e[i].r)-<span class="built_in">query</span>(e[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P4344-SHOI2015-脑洞治疗仪-线段树-二分"><a href="#P4344-SHOI2015-脑洞治疗仪-线段树-二分" class="headerlink" title="P4344 [SHOI2015] 脑洞治疗仪 线段树+二分"></a>P4344 [SHOI2015] 脑洞治疗仪 线段树+二分</h2><ul>
<li><p>题意：我们将大脑视作一个 01 序列，求出在大脑某个区间中最大的连续脑洞区域有多大。同时给出脑洞的治疗仪的使用方式：仅会尽量填补位置比较靠前的脑洞。（也就是把一段区间的 $1$ 的个数全部添加到另一段区间内）</p>
</li>
<li><p>思路：可以把题目转化成对于操作1 $[l_0,r_0]=0，[l_1,r_1]=1$，设 $[l_0,r_0]$ 有 $x$ 个 $1$ ，$[l_1,r_1]$ 有 $y$ 个 $0$，也就是需要在 $[l_1,r_1]$ 中找出 $\min(x,y)$ 个 $0$ 替换。但区间越长 $0$ 的个数越多，因此具有单调性，那么采用二分答案即可找出替换的区间。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> s,ls,rs,ms,len,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//s是1的个数</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> l1,r1,l0,r0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(E&amp; u,E l,E r)</span></span>&#123;</span><br><span class="line">    u.s=l.s+r.s;</span><br><span class="line">    u.ls=l.s?l.ls:l.len+r.ls;</span><br><span class="line">    u.rs=r.s?r.rs:r.len+l.rs;</span><br><span class="line">    u.ms=<span class="built_in">max</span>(&#123;l.ms,r.ms,l.rs+r.ls&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;<span class="comment">//赋值为0</span></span><br><span class="line">        t.ms=t.ls=t.rs=t.len;</span><br><span class="line">        t.s=t.tag=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t.ms=t.ls=t.rs=<span class="number">0</span>;</span><br><span class="line">        t.s=t.len,t.tag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    E&amp; t=tr[u];</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">0</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(t.tag==<span class="number">1</span>)<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">pushdown</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    t.tag=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u],tr[u&lt;&lt;<span class="number">1</span>],tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,r-l<span class="number">+1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>].r&gt;=l)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l&lt;=r)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].s;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="keyword">return</span> <span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;tr[u&lt;&lt;<span class="number">1</span>].r)<span class="keyword">return</span> <span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">q1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q0</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].len-tr[u].s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="keyword">return</span> <span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;tr[u&lt;&lt;<span class="number">1</span>].r)<span class="keyword">return</span> <span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">q0</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;tr[u&lt;&lt;<span class="number">1</span>].r)<span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    E res;</span><br><span class="line">    <span class="built_in">pushup</span>(res,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;l1&gt;&gt;r1;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">q1</span>(<span class="number">1</span>,l0,r0);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,l0,r0,<span class="number">0</span>);<span class="comment">//全变0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=l1,r=r1<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">q0</span>(<span class="number">1</span>,l1,mid)&lt;=x)l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,l1,l,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l0&gt;&gt;r0;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)<span class="built_in">change</span>(<span class="number">1</span>,l0,r0,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">work</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>)cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l0,r0).ms&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P2824-HEOI2016-TJOI2016-排序-线段树-二分"><a href="#P2824-HEOI2016-TJOI2016-排序-线段树-二分" class="headerlink" title="P2824 [HEOI2016/TJOI2016] 排序 线段树+二分"></a>P2824 [HEOI2016/TJOI2016] 排序 线段树+二分</h2><ul>
<li><p>题意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 l r 表示将区间 [l,r] 的数字升序排序</span><br><span class="line">1 l r 表示将区间 [l,r] 的数字降序排序</span><br></pre></td></tr></table></figure>
<p>最后查询 <code>q</code> 位置上的数字。</p>
</li>
<li><p>思路：如果这道题暴力去做 $O(mnlogn)$。因此我们转化一下思路就是：把上序列和下降序列分别转化成01序列。因为线段树操作01序列比较容易。这样就把区间排序转化成了区间修改和区间查询。因为这个线段树维护的是排列，因此可以用二分来求解某个位置上的值。因为具有二段性，为什么具有二段性呢？因此我们可以把 $&gt;=mid$ 的设为 $1$ ，反之为 $0$。之后查询的时候如果是 $1$ 则在 $&gt;=mid$ 找。对于这种 $01$ 序列的懒标记都是 $0$ 和 $1$，没有标记就是 $-1$。总的来说本道题就是二分答案的思路，因为本道题查询只有 $1$ 个。只查找 <code>sum</code> 不需要区间合并，而且 <code>sum</code> 不涉及累加的过程，因为本题只是排序。只是移动位置，没有其他任何合并操作，因此不需要区间合并以及 <code>sum</code> 累加。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],m,op[N];</span><br><span class="line"><span class="type">int</span> L[N],R[N];</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].tag!=<span class="number">-1</span>)&#123;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].sum=tr[u].tag*(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l<span class="number">+1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum=tr[u].tag*(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l<span class="number">+1</span>);</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].tag=tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag=tr[u].tag;</span><br><span class="line">        tr[u].tag=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,w[l]&gt;=x,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid,x),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r,x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].sum=k*(tr[u].r-tr[u].l<span class="number">+1</span>);</span><br><span class="line">        tr[u].tag=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n,x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l=L[i],r=R[i];</span><br><span class="line">        <span class="type">int</span> cnt=<span class="built_in">query</span>(<span class="number">1</span>,l,r);<span class="comment">//1的个数</span></span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,r-cnt<span class="number">+1</span>,r,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,r-cnt,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,l+cnt<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l+cnt,r,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,q,q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;op[i]&gt;&gt;L[i]&gt;&gt;R[i];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P5142-区间方差-线段树"><a href="#P5142-区间方差-线段树" class="headerlink" title="P5142 区间方差 线段树"></a>P5142 区间方差 线段树</h2><ul>
<li><p>题意：给定操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若 c=1，为修改操作，代表将 bx 赋值为 y。</span><br><span class="line">若 c=2，为查询操作，代表查询 bx 到 by​ 的方差。</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：方差的计算只需要计算平方和和区间和即可。因为：</p>
<script type="math/tex; mode=display">\begin{aligned} \sigma^2  = \frac{1}{n} \sum \limits_{i = 1}^n (x_i - \bar{x})^2 \\  = \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \sum \limits_{i = 1}^nx_i + n \bar{x}^2) \\  = \frac{1}{n} (\sum \limits_{i = 1}^n x_i^2 - 2 \bar{x} \times n \bar{x} + n \bar{x}^2) \\  = \frac{1}{n} \sum \limits_{i = 1}^n x_i^2 - \bar{x}^2 \\ \end{aligned}</script></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rev</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmi</span>(x,mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> s1,s2;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].s1=(tr[u&lt;&lt;<span class="number">1</span>].s1+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s1)%mod;</span><br><span class="line">    tr[u].s2=(tr[u&lt;&lt;<span class="number">1</span>].s2+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s2)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,w[l],w[l]*w[l]%mod&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].s1=v;</span><br><span class="line">        tr[u].s2=v*v%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,k,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,k,v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].s1;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)res=(res+<span class="built_in">query1</span>(u&lt;&lt;<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)res=(res+<span class="built_in">query1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].s2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)res=(res+<span class="built_in">query2</span>(u&lt;&lt;<span class="number">1</span>,l,r))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)res=(res+<span class="built_in">query2</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> s1=<span class="built_in">query1</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            <span class="type">int</span> s2=<span class="built_in">query2</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            <span class="type">int</span> t=<span class="built_in">rev</span>(y-x<span class="number">+1</span>);</span><br><span class="line">            <span class="type">int</span> ave=s1*t%mod;</span><br><span class="line">            <span class="type">int</span> d=s2*t%mod-ave*ave%mod;</span><br><span class="line">            d=(d%mod+mod)%mod;</span><br><span class="line">            cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P2184-贪婪大陆-差分-线段树"><a href="#P2184-贪婪大陆-差分-线段树" class="headerlink" title="P2184 贪婪大陆 差分+线段树"></a>P2184 贪婪大陆 差分+线段树</h2><ul>
<li><p>题意：询问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若 q=1，则表示 SCV 在 [l,r] 这段区间布上一种地雷；</span><br><span class="line">若 q=2，则表示小 FF 询问当前 [l,r] 区间总共有多少种地雷。</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：其实很容易理解就是询问一段区间内有多少段不同的区间，此时可以用差分来做。然后发现：只要一个区间的开头在一个节点 $i$ 的左边，那么这个区间包含在区间 $1-i$ 中，只要一个区间的尾部在一个节点 $j$ 的左边，那么这个区间肯定不属于 $j$之后的所有区间。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum[<span class="number">2</span>];<span class="comment">//sum[0]为区间起点，sum[1]为终点</span></span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    tr[u].sum[k]=tr[u&lt;&lt;<span class="number">1</span>].sum[k]+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].sum[k]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,x,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,k);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;r||tr[u].r&lt;l)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r,k)+<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,r,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;(<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,r,<span class="number">0</span>)-<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,l<span class="number">-1</span>,<span class="number">1</span>))&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P4198-楼房重建-与-k-（斜率）有关的"><a href="#P4198-楼房重建-与-k-（斜率）有关的" class="headerlink" title="P4198 楼房重建 与 $k$ （斜率）有关的"></a>P4198 楼房重建 与 $k$ （斜率）有关的</h2><ul>
<li><p>题意：在一个平面内，求出所有的高度大于 $0$ 的点与 $(0,0)$ 的连线没有与之前的线段相交的楼房，带修改。</p>
</li>
<li><p>思路：线段树得维护 $k$ 和可见数量，其中可见数量因为右区间可能被左边的挡住了，因此得递归判断。</p>
</li>
</ul>
<blockquote>
<p>注意：右边的可见楼数一定是 $sum[n]-sum[ls]$，不是 $sum[rs]$，因为 $sum[rs]$ 是指从原点上看的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">double</span> mx;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">double</span> mls)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].mx&lt;=mls)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[u].mx&gt;mls;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u&lt;&lt;<span class="number">1</span>].mx&lt;=mls)<span class="keyword">return</span> <span class="built_in">dfs</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r,mls);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(u&lt;&lt;<span class="number">1</span>,l,mid,mls)+tr[u].sum-tr[u&lt;&lt;<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u].mx=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].mx,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+<span class="built_in">dfs</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r,tr[u&lt;&lt;<span class="number">1</span>].mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">double</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)&#123;</span><br><span class="line">        tr[u].mx=v;</span><br><span class="line">        tr[u].sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)<span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,k,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,k,v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(u,tr[u].l,tr[u].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,x,(<span class="type">double</span>)y/x);</span><br><span class="line">        cout&lt;&lt;tr[<span class="number">1</span>].sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h1><ul>
<li><p>概念：可持久化线段树，就是保留历史的线段树。可持久化线段树，就是在线段树的每次操作中保留历史记录，并且从第 $i$个线段树的根开始访问第 $i$ 个历史版本的线段树，其中初始版本编号为0。</p>
</li>
<li><p>可持久化线段树无法使用普通线段树的堆式存储法，所以要采用动态开点法。为了好写，我们把每一个节点表示的区间放到函数的参数内部，这样可以有效减小空间和代码实现难度。</p>
</li>
<li><p>使用场景：区间第 k 大/小问题、区间内有多少不同的数字、区间更新等。</p>
<h2 id="P2464-SDOI2008-郁闷的小-J"><a href="#P2464-SDOI2008-郁闷的小-J" class="headerlink" title="P2464 [SDOI2008] 郁闷的小 J"></a>P2464 [SDOI2008] 郁闷的小 J</h2></li>
<li><p>题意：给定数列上有 $n$ 个颜色，两种操作：1、单点修改。2、区间查询 $[l,r]$ 内颜色 $k$ 出现的次数。</p>
</li>
<li>思路：肯定可以考虑可持久化线段树做法，首先把书的编号设为版本号，因为本道题不需要回溯，因此我们的change函数不需要写(int&amp; u,int v)的int v可以省去。还有就是得离散化。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N*<span class="number">2</span>];<span class="comment">//b为离散化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> opt,l,r,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> root[N],tot,cnt;</span><br><span class="line"><span class="type">int</span> ls[N*<span class="number">25</span>],rs[N*<span class="number">25</span>],sum[N*<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    sum[u]=sum[ls[u]]+sum[rs[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span>&amp; u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u)u=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        sum[u]+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)<span class="built_in">change</span>(ls[u],l,mid,p,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(rs[u],mid<span class="number">+1</span>,r,p,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x&amp;&amp;r&lt;=y)<span class="keyword">return</span> sum[u];</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)s+=<span class="built_in">query</span>(ls[u],l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)s+=<span class="built_in">query</span>(rs[u],mid<span class="number">+1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[++cnt]=a[i];</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">char</span> s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            q[i].opt=<span class="number">0</span>;</span><br><span class="line">            cin&gt;&gt;q[i].l&gt;&gt;q[i].id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q[i].opt=<span class="number">1</span>;</span><br><span class="line">            cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].id;</span><br><span class="line">        &#125;</span><br><span class="line">        b[++cnt]=q[i].id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+cnt);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bn=<span class="built_in">unique</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+cnt)-b<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+bn,a[i])-b;</span><br><span class="line">        <span class="built_in">change</span>(root[a[i]],<span class="number">1</span>,n,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q[i].opt)&#123;</span><br><span class="line">            <span class="built_in">change</span>(root[a[q[i].l]],<span class="number">1</span>,n,q[i].l,<span class="number">-1</span>);</span><br><span class="line">            a[q[i].l]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+bn,q[i].id)-b;</span><br><span class="line">            <span class="built_in">change</span>(root[a[q[i].l]],<span class="number">1</span>,n,q[i].l,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> id=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+bn,q[i].id)-b;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(root[id],<span class="number">1</span>,n,q[i].l,q[i].r)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><p>如果是线性无关的话，那么它对应在线性空间中就是一个基底，简称“基”。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3iruzjw1.png" alt=""></p>
<p>线性空间的数量成为维度。</p>
<p>向量组等价：左边的向量能被右边的向量表示出来，右边也能被表示。</p>
<p>铺垫：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fo5wybkl.png" alt=""></p>
<p>要求一堆向量的基，我们可以用高斯消元来求。</p>
<p>高斯消元的过程不会影响向量的等价性。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/iq4ogzia.png" alt=""></p>
<p>此时高斯消元剩下的就是基了。</p>
<p>注意：子空间是指所有基能表示出来的向量集合。</p>
<p>性质：线性空间的任意两个基底它一定是等价的，维度一样的。</p>
<p>举一个例子：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7zj1w2ju.png" alt=""></p>
<p>极大线性无关组 $\le 60$，那么我们的线性空间的基底 $\le 60$，因此我们的线性空间表示出来的向量跟 $n=10^5$ 表示出来的是一模一样的。</p>
<ul>
<li>性质：</li>
</ul>
<ol>
<li>原序列里面的任意一个数都可以由线性基里面的一些数异或得到。</li>
<li>线性基里面的任意一些数异或起来都不能得到 $0$。</li>
<li>线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的。</li>
</ol>
<p><a href="https://blog.csdn.net/a_forever_dream/article/details/83654397">性质参考</a></p>
<h2 id="P4570-BJWC2011-元素"><a href="#P4570-BJWC2011-元素" class="headerlink" title="P4570 [BJWC2011] 元素"></a>P4570 [BJWC2011] 元素</h2><ul>
<li><p>题意：有 $n$ 个元素，每个元素能选当且仅当它的元素序号不能通过之前选过的东西的元素序号异或得到，在此前提下，求魔力的最大值。</p>
</li>
<li><p>思路：根据上述给定的性质，我们可以知道，一个序列，能够插入到线性基里面的元素是一定的，那么既然只能插那么多个，显然优先插魔力值大的进去。这样的贪心显然是最优的。<a href="https://www.luogu.com.cn/article/zhjz6jl9">为什么呢，细节可看</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N],p[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(E x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.num&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].num)&#123;</span><br><span class="line">                x.num^=p[i].num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p[i]=x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].num&gt;&gt;a[i].val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">insert</span>(a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)ans+=p[i].val;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>队内训练1</title>
    <url>/2025/02/15/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%831/</url>
    <content><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/odexe5it.png" alt=""></p>
<p><a href="https://codeforces.com/gym/103427">题目来源：2021年ICPC沈阳站</a></p>
<hr>
<p><strong>以下是对于原题目的顺序，但队内训练是抽了几道题目，具体对应关系见上图。</strong></p>
<p>签到：EF</p>
<p>铜牌题：BJ</p>
<p>银牌题：HILM</p>
<p>金牌题：G…</p>
<hr>
<h1 id="A-签到题"><a href="#A-签到题" class="headerlink" title="A 签到题"></a>A 签到题</h1><ul>
<li>简单模拟<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j<span class="number">+1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j<span class="number">+1</span>])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[j<span class="number">+1</span>]!=s[i])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[j<span class="number">+1</span>]==s[i])j++;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">5</span>)&#123;</span><br><span class="line">            j=ne[j];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="B-签到题"><a href="#B-签到题" class="headerlink" title="B 签到题"></a>B 签到题</h1><ul>
<li><p>题目可能有点难理解，就是说对于每个字母选取的是当前遍历到的字符的后面最后一个跟它相同字母的后面的字母个数。</p>
</li>
<li><p>然后求最大字典序就直接用 <code>max</code> 函数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt;S;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!S.<span class="built_in">count</span>(s[j]))f[s[j]]=S.<span class="built_in">size</span>();</span><br><span class="line">            S.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">            ans[i]+=<span class="built_in">char</span>(f[s[j]]+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ans<span class="number">+1</span>,ans<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-染色法"><a href="#C-染色法" class="headerlink" title="C 染色法"></a>C 染色法</h1><ul>
<li>可以很容易发现：把这些关系建图，然后对于每一个联通块的第一个点可以填 $0$ 也可以填 $1$，这两种情况取个最小值。</li>
<li>特判就是如果矛盾（就类似染色问题那种矛盾）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)p[i]=i,siz[i]=<span class="number">1</span>,ans[i]=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        a--,b--;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">        <span class="built_in">uni</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]!=i)<span class="keyword">continue</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(<span class="number">30</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        ans[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,w]:g[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    ans[j]=(ans[t]^w);</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    <span class="built_in">FOR</span>(k,<span class="number">0</span>,<span class="number">29</span>)&#123;</span><br><span class="line">                        cnt[k]+=((ans[j]&gt;&gt;k)&amp;<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ans[j]!=(ans[t]^w))&#123;</span><br><span class="line">                        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">29</span>)&#123;</span><br><span class="line">            res+=(<span class="number">1</span>&lt;&lt;j)*<span class="built_in">min</span>(cnt[j],siz[i]-cnt[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-bfs预处理"><a href="#D-bfs预处理" class="headerlink" title="D bfs预处理"></a>D bfs预处理</h1><ul>
<li>有很多次查询，但转移状态的次数不多，因此可以先预处理从某一个状态到某一个状态的最小花费，这里可以用 <code>bfs</code> 先预处理。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;string&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    dist[<span class="string">&quot;0000&quot;</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        string t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        string a,b;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(j,i,<span class="number">3</span>)&#123;</span><br><span class="line">                a=b=t;</span><br><span class="line">                <span class="built_in">FOR</span>(k,i,j)&#123;</span><br><span class="line">                    a[k]=(t[k]-<span class="string">&#x27;0&#x27;</span><span class="number">+1</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    b[k]=(t[k]-<span class="string">&#x27;0&#x27;</span><span class="number">+9</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dist.<span class="built_in">find</span>(a)==dist.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(a);</span><br><span class="line">                    dist[a]=dist[t]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dist.<span class="built_in">find</span>(b)==dist.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(b);</span><br><span class="line">                    dist[b]=dist[t]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="function">string <span class="title">c</span><span class="params">(<span class="number">4</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">3</span>)c[i]=(b[i]-a[i]<span class="number">+10</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;dist[c]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-思维-targin"><a href="#E-思维-targin" class="headerlink" title="E 思维+targin"></a>E 思维+targin</h1><ul>
<li><p>可以发现<strong>线图</strong>就是偶数的时候可以满足匹配，然后就是得看奇数。</p>
</li>
<li><p>奇数的时候得特殊考虑，最好转化成 <code>偶数+桥+偶数</code> 的形式，这样把桥删了不会对两边偶数的匹配产生影响。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/li_wen_zhuo/article/details/121633394?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164346130316780265469877%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164346130316780265469877&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-121633394.pc_search_result_control_group&amp;utm_term=Line%20Graph%20Matching&amp;spm=1018.2226.3001.4187">具体接替可以参考</a>，他用的是并查集，但我用 <code>targin</code> 一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;PII&gt; g[N];</span><br><span class="line"><span class="type">int</span> din[N];</span><br><span class="line"><span class="type">int</span> low[N],dfn[N];</span><br><span class="line"><span class="type">int</span> tmd,stk[N],siz[N];</span><br><span class="line"><span class="type">int</span> scc_cnt,tot,minv=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">targin</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    low[u]=dfn[u]=++tmd;</span><br><span class="line">    siz[u]=din[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [j,w]:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])&#123;</span><br><span class="line">            <span class="built_in">targin</span>(j,u);</span><br><span class="line">            siz[u]+=siz[j];</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">            <span class="keyword">if</span>(low[j]&gt;dfn[u])&#123;</span><br><span class="line">                <span class="keyword">if</span>((siz[j]<span class="number">-1</span>)/<span class="number">2</span>%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    minv=<span class="built_in">min</span>(minv,w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minv=<span class="built_in">min</span>(minv,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j!=pre)&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">            minv=<span class="built_in">min</span>(minv,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dfn[u]&lt;dfn[j])&#123;</span><br><span class="line">            tot++;<span class="comment">//联通块内边数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">        din[a]++,din[b]++;</span><br><span class="line">        res+=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(m&amp;<span class="number">1</span>))&#123;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            tot=<span class="number">0</span>;</span><br><span class="line">            minv=<span class="number">1e18</span>;</span><br><span class="line">            <span class="built_in">targin</span>(i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(tot&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                res-=minv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G-KMP"><a href="#G-KMP" class="headerlink" title="G KMP"></a>G KMP</h1><ul>
<li>就是典型KMP的border的应用，只不过KMP是前缀的border，这道题要求的是后缀的border，可以考虑 SA，也可以用KMP的fail。</li>
</ul>
<p><a href="https://www.cnblogs.com/Qing17/p/18419276">细节</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;s[p])&#123;</span><br><span class="line">            p=i,j=<span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fail[j]&amp;&amp;s[p+fail[j]]&lt;s[i])&#123;</span><br><span class="line">            j=fail[j];</span><br><span class="line">            p=i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[p+fail[j]]==s[i])&#123;</span><br><span class="line">            fail[j<span class="number">+1</span>]=fail[j]<span class="number">+1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[p+fail[j]]&gt;s[i])&#123;</span><br><span class="line">            fail[++j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;p&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>日常训练</tag>
      </tags>
  </entry>
  <entry>
    <title>好题整理</title>
    <url>/2025/02/05/%E5%A5%BD%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h1><h2 id="2018A-Card-Partition-1600-思维题"><a href="#2018A-Card-Partition-1600-思维题" class="headerlink" title="2018A-Card Partition *1600 思维题"></a>2018A-Card Partition <strong>*1600</strong> 思维题</h2><ul>
<li>这道题就是简单的枚举，因为 $n$ 不大。因此就直接枚举每组分成多少张，这样就能算出组数了，这里的总数是把加的牌也算进去的，这样就是看最坏的情况下能否满足题目条件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int mx=0,s=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],mx=max(mx,w[i]),s+=w[i];</span><br><span class="line"></span><br><span class="line">    int ls=s+k;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int t=ls/i;//假定分成t份</span><br><span class="line">        if(t&gt;=mx&amp;&amp;t*i&gt;=s&amp;&amp;t*i&lt;=ls)ans=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2004D-Colored-Portals-1600"><a href="#2004D-Colored-Portals-1600" class="headerlink" title="2004D-Colored Portals *1600"></a>2004D-Colored Portals <strong>*1600</strong></h2><p><del>真的受不了这种题，看错一个地方调了我一个半小时。</del></p>
<ul>
<li><p>思路很简单，因为只有 $4$ 种颜色取 $2$ 种，那么总共也就有 $6$ 种情况。可以推出答案就两种情况——在同一层、不在同一层（可以证明只需要一个辅助城市即可）</p>
</li>
<li><p>这里取巧：每种颜色组合在每一层出现的最远位置和最近位置记录下来，这里就直接用 <code>vector&lt;array&lt;int,6&gt;&gt;(n+1,&#123;-1,-1,-1,-1,-1,-1&#125;)</code> 来记录，就是这里，我没想到。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n,q;</span><br><span class="line">map&lt;string,int&gt;id&#123;&#123;&quot;BG&quot;,1&#125;,&#123;&quot;BR&quot;,2&#125;,&#123;&quot;BY&quot;,3&#125;,&#123;&quot;GR&quot;,4&#125;,&#123;&quot;GY&quot;,5&#125;,&#123;&quot;RY&quot;,6&#125;,</span><br><span class="line">    &#123;&quot;GB&quot;,1&#125;,&#123;&quot;RB&quot;,2&#125;,&#123;&quot;YB&quot;,3&#125;,&#123;&quot;RG&quot;,4&#125;,&#123;&quot;YG&quot;,5&#125;,&#123;&quot;YR&quot;,6&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;a(n+1,0);</span><br><span class="line">    vector&lt;string&gt;s(n+1);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        a[i]=id[s[i]];        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;int,7&gt;&gt;b(n+1,&#123;-1,-1,-1,-1,-1,-1,-1&#125;);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]=b[i-1];</span><br><span class="line">        b[i][a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;int,7&gt;&gt;c(n+2,&#123;-1,-1,-1,-1,-1,-1,-1&#125;);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=6;i++)c[n+1][i]=-1;</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        c[i]=c[i+1];</span><br><span class="line">        c[i][a[i]]=i;</span><br><span class="line">        // cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // cout&lt;&lt;c[2][2]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">        if(x&gt;y)swap(x,y);</span><br><span class="line"></span><br><span class="line">        if(x==y)&#123;</span><br><span class="line">            cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans=1e18;</span><br><span class="line"></span><br><span class="line">        if(s[x][0]==s[y][0]||s[x][0]==s[y][1]||s[x][1]==s[y][0]||s[x][1]==s[y][1])&#123;</span><br><span class="line">            cout&lt;&lt;abs(x-y)&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int t1=a[x],t2=a[y];</span><br><span class="line">        bool f=false;</span><br><span class="line">        // cout&lt;&lt;t1&lt;&lt;&#x27; &#x27;&lt;&lt;t2&lt;&lt;endl;</span><br><span class="line">        for(int i=1;i&lt;=6;i++)&#123;</span><br><span class="line">            if(i!=t1&amp;&amp;i!=t2)&#123;</span><br><span class="line">                // cout&lt;&lt;b[x][i]&lt;&lt;&#x27; &#x27;&lt;&lt;b[y][i]&lt;&lt;&#x27; &#x27;&lt;&lt;c[x][i]&lt;&lt;&#x27; &#x27;&lt;&lt;c[y][i]&lt;&lt;endl;</span><br><span class="line">                if(b[x][i]!=-1||b[y][i]!=-1||c[x][i]!=-1||c[y][i]!=-1)&#123;</span><br><span class="line">                    f=1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(!f)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=6;i++)&#123;</span><br><span class="line">            if(i!=t1&amp;&amp;i!=t2)&#123;</span><br><span class="line">                if(b[x][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(b[x][i]-x)+abs(b[x][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">                if(b[y][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(b[y][i]-x)+abs(b[y][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">                if(c[x][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(c[x][i]-x)+abs(c[x][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">                if(c[y][i]!=-1)&#123;</span><br><span class="line">                    ans=min(ans,abs(c[y][i]-x)+abs(c[y][i]-y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1996E-Decode-1600-前缀和-思维"><a href="#1996E-Decode-1600-前缀和-思维" class="headerlink" title="1996E-Decode *1600 前缀和+思维"></a>1996E-Decode <strong>*1600</strong> 前缀和+思维</h2><ul>
<li>$n$ 很大，要求两个变量的方案和，可以想到<strong>贡献法</strong>。</li>
<li>很容易想到对于某一个满足的如 $11111001111$ 如果满足题意，答案就是 $l\times r$。</li>
<li>有两个变量不好算，因此枚举一个变量：对于每一个 $l,r$，此时固定 $r$，都有：</li>
</ul>
<script type="math/tex; mode=display">ans=l_1*r+l_2*r+l_3*r+...+l_k*r</script><script type="math/tex; mode=display">ans=\sum_{i=1}^{k}{l_k}*r</script><p>因此我们只需要算 $\sum_{i=1}^{k}{l_k}$ 即可，这个我们可以用 <code>map</code> 来解决。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.size();</span><br><span class="line"></span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line">    map&lt;int,int&gt;S;</span><br><span class="line">    S[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i]=sum[i-1]+(s[i]==&#x27;1&#x27;?1:-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+(n-i+1)*(S[sum[i]])%mod)%mod;</span><br><span class="line">        S[sum[i]]+=i+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-6水题3-1600题6"><a href="#2-6水题3-1600题6" class="headerlink" title="2.6水题3+1600题6"></a>2.6水题3+1600题6</h1><h2 id="1994C-Hungry-Games-1600-二分-思维"><a href="#1994C-Hungry-Games-1600-二分-思维" class="headerlink" title="1994C-Hungry Games *1600 二分+思维"></a>1994C-Hungry Games <strong>*1600</strong> 二分+思维</h2><ul>
<li>就是一个二分去划分边界，对于一个左端点为 $i$ 的区间，可以分为两部分，一部分为 $a_i$~$a_q$​，这部分他们的总和就是 $≤x$，显然不涉及到“归零”这个操作，答案直接加上 $q−i−1$。</li>
<li><code>accumulate()</code> 第三个参数是基准值，也就是 $f_1+f_2+…+f_n+t$，$t$ 就是基准值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],s[i]=s[i-1]+w[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;f(n+2);</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=0;i--)&#123;</span><br><span class="line">        int q=upper_bound(s+1,s+1+n,s[i]+k)-s;//ai~aq</span><br><span class="line">        f[i]=f[q]+q-i-1;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;accumulate(f.begin(),f.end(),0ll)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>错误次数：2</p>
<p>错误原因：已经想到二分/双指针去做，但没有深入思考边界的处理。</p>
</blockquote>
<h2 id="1978D-Elections-1600-思维-前缀和"><a href="#1978D-Elections-1600-思维-前缀和" class="headerlink" title="1978D-Elections *1600 思维+前缀和"></a>1978D-Elections <strong>*1600</strong> 思维+前缀和</h2><p>思路很清晰，答案就三种情况：0，i，i-1。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    w[1]+=k;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+w[i];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=max(pre[i-1],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        suf[i]=max(suf[i+1],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t=*max_element(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    int cnt=0,id=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(t==w[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(t==w[i])&#123;</span><br><span class="line">            id=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(w[1]&gt;=t)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;0 &quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;1 &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(w[i]&gt;=t)&#123;</span><br><span class="line">            if(w[i]==t&amp;&amp;cnt!=1&amp;&amp;i!=id)&#123;</span><br><span class="line">                cout&lt;&lt;i-1&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cout&lt;&lt;0&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int ans=i-1;</span><br><span class="line">            if(s[i]&lt;t)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>错误次数：2</p>
<p>错误原因：要用前缀和去比较</p>
</blockquote>
<h2 id="1956C-Nene’s-Magical-Matrix-1600-构造"><a href="#1956C-Nene’s-Magical-Matrix-1600-构造" class="headerlink" title="1956C-Nene’s Magical Matrix *1600 构造"></a>1956C-Nene’s Magical Matrix <strong>*1600</strong> 构造</h2><ul>
<li>构造方案是行和列的赋值，其实通过多次画图可以知道：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">2 2 3 4 5</span><br><span class="line">3 3 3 4 5</span><br><span class="line">4 4 4 4 5</span><br><span class="line">5 5 5 5 5</span><br></pre></td></tr></table></figure></li>
<li>这种方案是最优的，而且要输出方案也很好写，我们只需要从外到内而且排列都不需要变换。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        ans+=(i*i+(i+1+n)*(n-i)/2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27; &#x27;&lt;&lt;n*2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    FORD(i,1,n)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;1 &quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        FOR(j,1,n)cout&lt;&lt;j&lt;&lt;&quot; \n&quot;[j==n];</span><br><span class="line">        cout&lt;&lt;&quot;2 &quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        FOR(j,1,n)cout&lt;&lt;j&lt;&lt;&quot; \n&quot;[j==n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误次数：1</p>
<p>错误原因：布置行了后面开始考虑列的时候忽略了行的修改。</p>
</blockquote>
<h2 id="1957C-How-Does-the-Rook-Move-1600-排列组合"><a href="#1957C-How-Does-the-Rook-Move-1600-排列组合" class="headerlink" title="1957C-How Does the Rook Move? *1600 排列组合"></a>1957C-How Does the Rook Move? <strong>*1600</strong> 排列组合</h2><ul>
<li>这种就是画个图枚举，可以发现:</li>
<li><ul>
<li>如果你画在对角线上机器人就没有地方画了，此时就是随便放，方案也就是 $C_{n}^{i}$，其中 $n$ 表示之前下完棋剩下棋盘的行数，$i$ 表示下了 $i$ 次放在对角线的棋，<strong>这里的 $n-i$ 是偶数，如果不是的情况下，那么会对下面不在对角线的情况下会下不完剩余的列</strong>。</li>
</ul>
</li>
<li><ul>
<li>除对角线画，一共有 $C_{n-i}^{j}\times j!$，$j=\frac{n-i}{2}$。</li>
</ul>
</li>
<li>那么答案就是二者乘积之和。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int qmi(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b/=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init(int x)&#123;</span><br><span class="line">    fac[0]=infac[0]=1;</span><br><span class="line">    FOR(i,1,x)&#123;</span><br><span class="line">        fac[i]=fac[i-1]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infac[x]=qmi(fac[x],mod-2);</span><br><span class="line"></span><br><span class="line">    FORD(i,1,x-1)&#123;</span><br><span class="line">        infac[i]=infac[i+1]*(i+1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int C(int x,int y)&#123;</span><br><span class="line">    return fac[x]*infac[y]%mod*infac[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    map&lt;int,int&gt;S;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,k)&#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">        S[x[i]]=S[y[i]]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n=n-S.size();</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FOR2(i,n&amp;1,n)&#123;</span><br><span class="line">        int j=(n-i)/2;</span><br><span class="line">        ans=(ans+C(n,i)*C(n-i,j)%mod*fac[j]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1971F-Circle-Perimeter-1600-数学"><a href="#1971F-Circle-Perimeter-1600-数学" class="headerlink" title="1971F-Circle Perimeter *1600 数学"></a>1971F-Circle Perimeter <strong>*1600</strong> 数学</h2><p><del>服了，我怎么会一直往那个 <strong>皮克定理</strong> 那边去想</del></p>
<ul>
<li>公式推导：</li>
</ul>
<script type="math/tex; mode=display">r\le \sqrt{x^2+y^2} < r+1</script><script type="math/tex; mode=display">r^2\le x^2+y^2<(r+1)^2</script><script type="math/tex; mode=display">r^2-y^2\le x^2 <(r+1)^2-y^2</script><script type="math/tex; mode=display">\sqrt{r^2-y^2}\le x<\sqrt{(r+1)^2-y^2}</script><ul>
<li><p>那么 $x<em>{min}=\lfloor \sqrt{r^2-y^2} \rfloor$ ，$x</em>{max}=\lceil\sqrt{(r+1)^2-y^2} \rceil$</p>
</li>
<li><p>此时直接枚举 $y$ 就可以算出 $x$ 了，最后答案 $\times 4$ 就可以了。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int mx=floor(sqrt((n+1)*(n+1)-i*i-0.5));</span><br><span class="line">        int mn=ceil(sqrt(n*n-i*i));</span><br><span class="line">        ans+=mx-mn+1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*4&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误次数： 1</p>
<p>错误原因：皮克定理是用来算多边形的面积跟整点数的关系，圆的面积不是定数，如果要用的话很难取 $eps$，因此最好不用。</p>
</blockquote>
<h2 id="1976C-Job-Interview-1600-思维"><a href="#1976C-Job-Interview-1600-思维" class="headerlink" title="1976C-Job Interview *1600 思维"></a>1976C-Job Interview <strong>*1600</strong> 思维</h2><ul>
<li>总共的职位数只有 $n+m$ 个，但总共有 $n+m+1$ 个人，为了更好的讨论，这里直接不选最后一个人，此时就很好做了，用的是贪心。</li>
<li>这里我是用 $vis_i$ 表示第 $i$ 个人被选上测试职业，$ca$ 表示选了 $ca$ 个程序员，$f_i$ 表示该人不被选上个人可以<strong>多</strong>获得的价值。</li>
<li>此时的 $f_i$ 此时就是一个差值（变化量），默认不选最后一个人的答案是 $ans$。</li>
<li>然后，发现如果改为不选第 $i$ 个人，实际上就是让下一个原本要选某一个职业但是没法选的人选某一个职业​ 然后还要有下一个人顶替他选的岗位，以此类推。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n+m+1;i++)cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=n+m+1;i++)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;f(n+m+2,0),vis(n+m+2,0);</span><br><span class="line"></span><br><span class="line">    int ca=0,cb=0,ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n+m;i++)&#123;//默认不选最后一个</span><br><span class="line">        if(ca==n)ans+=b[i],vis[i]=0;</span><br><span class="line">        else if(cb==m)ans+=a[i],vis[i]=1;</span><br><span class="line">        else if(a[i]&gt;b[i])vis[i]=1,ans+=a[i],ca++;</span><br><span class="line">        else ans+=b[i],vis[i]=0,cb++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ca=n+m+1,cb=n+m+1;</span><br><span class="line"></span><br><span class="line">    for(int i=n+m;i;i--)&#123;</span><br><span class="line">        if(ca==n+m+1&amp;&amp;vis[i])f[i]=f[ca]+a[ca];</span><br><span class="line">        else if(cb==n+m+1&amp;&amp;!vis[i])f[i]=f[cb]+b[cb];</span><br><span class="line">        else if(vis[i])f[i]=f[ca]+a[ca]-b[ca];</span><br><span class="line">        else f[i]=f[cb]+b[cb]-a[cb];</span><br><span class="line">        if(vis[i]&amp;&amp;b[i]&gt;a[i])cb=i;</span><br><span class="line">        else if(!vis[i]&amp;&amp;b[i]&lt;a[i])ca=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n+m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;(ans-(vis[i]?a[i]:b[i])+f[i])&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>没想出来这么做，憨了</del></p>
</blockquote>
<h2 id="HDU-6702-amp-位运算"><a href="#HDU-6702-amp-位运算" class="headerlink" title="HDU-6702-&amp; 位运算"></a>HDU-6702-&amp; 位运算</h2><ul>
<li>容易发现要让答案最小，对每一位进行分析很容易发现，当 $a,b$ 在同一位均为 $1$ 的情况下，此时 $c$ 填 $1$.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    for(int i=34;i&gt;=0;i--)&#123;</span><br><span class="line">        if((a&gt;&gt;i&amp;1)&amp;&amp;(b&gt;&gt;i&amp;1))&#123;</span><br><span class="line">            ans|=(1ull&lt;&lt;(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans==0)&#123;</span><br><span class="line">        if(((a^0)&amp;(b^0))==0)&#123;</span><br><span class="line">            cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-6707-Shuffle-Card-STL：栈"><a href="#HDU-6707-Shuffle-Card-STL：栈" class="headerlink" title="HDU-6707-Shuffle Card STL：栈"></a>HDU-6707-Shuffle Card STL：栈</h2><ul>
<li>没什么好说的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    stack&lt;int&gt;stk;</span><br><span class="line"></span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        stk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(stk.size())&#123;</span><br><span class="line">        int x=stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        if(!vis[x])&#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!vis[w[i]])&#123;</span><br><span class="line">            cout&lt;&lt;w[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-6708-Windows-Of-CCPC找规律"><a href="#HDU-6708-Windows-Of-CCPC找规律" class="headerlink" title="HDU-6708-Windows Of CCPC找规律"></a>HDU-6708-Windows Of CCPC找规律</h2><ul>
<li>根据这个: <img src="https://cdn.vjudge.net.cn/afbcb5c2cef9da397ceb1c5aadddc45b?v=1723071497" alt=""></li>
</ul>
<p>和：</p>
<p><img src="https://cdn.vjudge.net.cn/cba282549674e44e31536068319c9ff8?v=1723071497" alt=""></p>
<ul>
<li><p>又因为数组的大小是 $2$ 的幂次方且都是从 $2^{n-1}$ 得到，因此我们可以对上述字母分块，我们可以很容易发现：第一块和第四块是相同的，第二块和第三块是相同的。</p>
</li>
<li><p>块数划分编号：</p>
</li>
</ul>
<p>1 2 3 4</p>
<ul>
<li>然后直接打表就可以了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init()&#123;</span><br><span class="line">    s[1][1]=s[1][2]=s[2][2]=&#x27;C&#x27;;</span><br><span class="line">    s[2][1]=&#x27;P&#x27;;</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;=10;i++)&#123;</span><br><span class="line">        int l=pow(2,i-1);</span><br><span class="line">        int r=pow(2,i);</span><br><span class="line">        for(int j=1;j&lt;=l;j++)&#123;</span><br><span class="line">            for(int k=l+1;k&lt;=r;k++)&#123;</span><br><span class="line">                s[j+l][k]=s[j][k]=s[j][k-l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=l;j++)&#123;</span><br><span class="line">            for(int k=1;k&lt;=l;k++)&#123;</span><br><span class="line">                s[j+l][k]=(s[j][k]==&#x27;C&#x27;?&#x27;P&#x27;:&#x27;C&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    n=pow(2,n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-7-1600-1800乱刷"><a href="#2-7-1600-1800乱刷" class="headerlink" title="2.7 1600-1800乱刷"></a>2.7 1600-1800乱刷</h1><p><del>今天感觉什么事情都没干，昨晚睡太晚导致今天早上起不来，然后打算下午睡个觉，没想到又浪费了很多时间，服了，今天约等于也就只有5个小时刷题时间，太少了，而且做的又少，难受，今晚又做题做累了，明天又很冷，不知道会不会起得来。</del></p>
<p>这几天计划是刷1600-2400的题，康复训练，已经很久没有做 <code>codeforces</code> 的题了。</p>
<h2 id="1946C-Tree-Cutting-1600-二分-dfs"><a href="#1946C-Tree-Cutting-1600-二分-dfs" class="headerlink" title="1946C-Tree Cutting *1600 二分+dfs"></a>1946C-Tree Cutting <strong>*1600</strong> 二分+dfs</h2><ul>
<li>这个一看肯定跟子树有关系，因此就得维护 <code>siz</code> 数组。</li>
<li>如果选某一条边，此时就让它的 <code>siz</code> 清零，这样不会对后面产生影响。</li>
<li>题目的答案具有单调性（如果给的答案太大了，可以通过缩小区间来减小答案的范围），可以很容易写出二分。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    VII g(n+1);</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-1)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        g[b].emplace_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;siz(n+1,0);</span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    function&lt;void(int,int,int)&gt; dfs=[&amp;](int u,int fa,int lim)&#123;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        for(auto&amp; j:g[u])&#123;</span><br><span class="line">            if(j==fa)continue;</span><br><span class="line">            dfs(j,u,lim);</span><br><span class="line">            siz[u]+=siz[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(siz[u]&gt;=lim)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            siz[u]=0;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(u==1&amp;&amp;siz[u]&lt;lim&amp;&amp;cnt==k)cnt=0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function&lt;bool(int)&gt;check=[&amp;](int x)&#123;</span><br><span class="line">        siz.clear();</span><br><span class="line">        cnt=0;</span><br><span class="line">        dfs(1,0,x);</span><br><span class="line">        return cnt&lt;=k;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int l=0,r=n+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>总结：思路很简单的，认真考虑是可以很快的想出来。</p>
</blockquote>
<h2 id="2020C-Bitwise-Balancing-1600-位运算"><a href="#2020C-Bitwise-Balancing-1600-位运算" class="headerlink" title="2020C-Bitwise Balancing *1600 位运算"></a>2020C-Bitwise Balancing <strong>*1600</strong> 位运算</h2><ul>
<li>这道题就直接枚举每一位做，然后发现如果在第 $i$ 位下，$b=1,c=0,d=1$，这种情况是允许的，还有就是 $b=0,c=1,d=1$ 也是允许的，其他情况均不行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">    int a=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,61)&#123;</span><br><span class="line">        int x,y,z;</span><br><span class="line">        x=((b&gt;&gt;i)&amp;1);</span><br><span class="line">        y=((c&gt;&gt;i)&amp;1);</span><br><span class="line">        z=((d&gt;&gt;i)&amp;1);</span><br><span class="line">        if(x!=z)&#123;</span><br><span class="line">            if(1-y!=z)&#123;</span><br><span class="line">                cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">                return;    </span><br><span class="line">            &#125;</span><br><span class="line">            a|=(1ll&lt;&lt;(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：位运算的题很多情况下都得按位看，然后有的时候可能会用枚举答案的思想来做题。</p>
</blockquote>
<h2 id="2035C-Alya-and-Permutation-1600-构造-位运算"><a href="#2035C-Alya-and-Permutation-1600-构造-位运算" class="headerlink" title="2035C-Alya and Permutation *1600 构造+位运算"></a>2035C-Alya and Permutation <strong>*1600</strong> 构造+位运算</h2><ul>
<li>这种题你乍一看很没有思路，此时可以发现不同点：奇数和偶数它们的答案是不同的。这点可以通过样例来看。</li>
<li>因为奇数最后一次操作是与，因为与会使答案$\le n$，所以盲猜答案是 $n$。</li>
<li>因为偶数最后一次操作是或，或能让答案 $&gt;=n$，所以很容易知道答案肯定是 $2^{\lfloor{\log_{2}n}\rfloor}-1$。</li>
<li>其实最关键的是答案的构造，这里分类讨论。</li>
<li><ul>
<li>奇数：因为最后一次操作是与，然后最后一位数肯定是与 $n$，那么 $n$ 的前面操作也要使得结果为 $n$，要不然结果就不会等于 $n$ 了。发现 $1,n-1,n$ 这种组合可以，因为是先与 $1$，此时你不管前面如何，最低位必为 $1$（因为 $n$ 是奇数）。</li>
</ul>
</li>
<li><ul>
<li>偶数：因为最后一次操作是或，那么你要让答案等于 $2^{\lfloor{\log_{2}n}\rfloor+1}-1$，就得让除最高位外其余的均为 $1$，然后在此数前面的只需要提供最高位即可。那么 $n,n-1,2^{\lfloor{\log_{2}n}\rfloor}-1$ 满足要求。</li>
</ul>
</li>
<li><ul>
<li>偶数还有一种特殊情况，就是很有可能 $n=2^{\lfloor{\log_{2}n}\rfloor}$，那么前面就不能有 $n-1$，此时 $1,n-3,n-2,n-1,n$ 满足条件。因为 $n-1$ 的二进制就是全 $1$ 的数字，但你肯定不能让 $n-1$ 消失，又因为 $n-1$ 前的操作符是与，为了让 $n-1$ 能够完整的传承下去，那么必须得让前面的数字的结果为 $n-1$，那么 $1,n-3,n-2$ 符合条件。</li>
</ul>
</li>
</ul>
<p><del>就是这道题，浪费了我1个多小时的时间，真憨了。</del></p>
<ul>
<li>最后的代码也是特别的短。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    if(n&amp;1)&#123;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        FOR(i,1,n-4)cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        cout&lt;&lt;1&lt;&lt;&#x27; &#x27;&lt;&lt;n-2&lt;&lt;&#x27; &#x27;&lt;&lt;n-1&lt;&lt;&#x27; &#x27;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int t=log2(n);</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;(int(pow(2,t+1))-1)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        if((int)pow(2,t)==n)&#123;</span><br><span class="line">            FOR(i,1,n-5)cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            cout&lt;&lt;1&lt;&lt;&#x27; &#x27;&lt;&lt;n-3&lt;&lt;&#x27; &#x27;&lt;&lt;n-2&lt;&lt;&#x27; &#x27;&lt;&lt;n-1&lt;&lt;&#x27; &#x27;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            FOR(i,1,(int)(pow(2,t)-2))cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            FOR(i,(int)pow(2,t),n-2)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;n-1&lt;&lt;&#x27; &#x27;&lt;&lt;(int)pow(2,t)-1&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有认真考虑偶数的关系，偶数还有一种情况没有考虑到。</p>
</blockquote>
<h2 id="1932E-Final-Countdown-1600-贡献法-高精度"><a href="#1932E-Final-Countdown-1600-贡献法-高精度" class="headerlink" title="1932E-Final Countdown*1600 贡献法+高精度"></a>1932E-Final Countdown<strong>*1600</strong> 贡献法+高精度</h2><ul>
<li>思路特别简单，就是去算：比如123，答案就是123+12+1。</li>
<li>但这边得优化一下，就是按每一位来做，此时前缀和来做就可以了，前缀和是维护位数数字的和的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    VI sum(n),C;</span><br><span class="line"></span><br><span class="line">    sum[0]=s[0]-&#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-1)&#123;</span><br><span class="line">        sum[i]=sum[i-1]+s[i]-&#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t=0;</span><br><span class="line"></span><br><span class="line">    FORD(i,0,n-1)&#123;</span><br><span class="line">        t+=sum[i];</span><br><span class="line">        C.pb(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t)C.pb(t);</span><br><span class="line"></span><br><span class="line">    while(C.sz&gt;1&amp;&amp;C.back()==0)C.pop_back();</span><br><span class="line"></span><br><span class="line">    reverse(ALL(C));</span><br><span class="line"></span><br><span class="line">    for(auto x:C)cout&lt;&lt;x;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>错误次数：1</p>
<p>错误原因：没有对操作优化，单纯相加很耗时的。</p>
</blockquote>
<h2 id="1928C-Physical-Education-Lesson-1600-数学"><a href="#1928C-Physical-Education-Lesson-1600-数学" class="headerlink" title="1928C-Physical Education Lesson *1600 数学"></a>1928C-Physical Education Lesson <strong>*1600</strong> 数学</h2><ul>
<li><p>这道题可以很容易知道：题目的函数的周期 $T=2(k-1)$。</p>
</li>
<li><p>然后要求的是 $k$，然后可以知道求的东西是： <script type="math/tex">n\equiv x (\mod 2(k-1))</script></p>
</li>
<li><p>以及： <script type="math/tex">n\equiv 2k-x (\mod 2(k-1)) \iff n\equiv 2-x(\mod 2(k-1))</script></p>
</li>
<li><p>所以题目就转化成了求满足以上两个式子不同的 $k$ 的个数。</p>
</li>
<li><p><strong>特别知道：$a\equiv b(\mod x)$，求 $x$ 的个数，那么也就是求 $a-b|x$的个数，此时就转化成了求 $a-b$ 因子的个数</strong>。</p>
</li>
<li><p>注意：当 $x=k$ 的时候，会多算一次；因子必须是<strong>偶数</strong>，因为是 $2(k-1)$，这个数是偶数。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int i,int b,int x)&#123;</span><br><span class="line">    int k=i/2+1;</span><br><span class="line">    if(!(i&amp;1)&amp;&amp;i&gt;=2&amp;&amp;(k&gt;=x)&amp;&amp;!(b!=x&amp;&amp;(k==x)))return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calc(int a,int b,int x)&#123;</span><br><span class="line">    int p=a-b,res=0;</span><br><span class="line">    for(int i=1;i&lt;=p/i;i++)&#123;</span><br><span class="line">        if(p%i==0)&#123;</span><br><span class="line">            if(check(i,b,x))res++;</span><br><span class="line">            if(i!=p/i)&#123;</span><br><span class="line">                if(check(p/i,b,x))res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    int res=calc(n,x,x);</span><br><span class="line">    if(x!=1)res+=calc(n,2-x,x);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：卡在黑体部分内容。</p>
</blockquote>
<h2 id="510C-Fox-And-Names-1600-拓扑序"><a href="#510C-Fox-And-Names-1600-拓扑序" class="headerlink" title="510C-Fox And Names *1600 拓扑序"></a>510C-Fox And Names <strong>*1600</strong> 拓扑序</h2><ul>
<li>又是一道把字母转化到图的题目。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;s[i];</span><br><span class="line"></span><br><span class="line">    string s2=s[1],s1;</span><br><span class="line"></span><br><span class="line">    VII g(300);</span><br><span class="line">    VI din(300,0),ans;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        s1=s[i];</span><br><span class="line"></span><br><span class="line">        int a=0;</span><br><span class="line">        </span><br><span class="line">        int m=min&lt;int&gt;(s1.sz,s2.sz);</span><br><span class="line"></span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            if(s1[a]!=s2[a])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(a&gt;=m&amp;&amp;s2.sz&gt;s1.sz)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // cout&lt;&lt;s2[a]&lt;&lt;&#x27; &#x27;&lt;&lt;s1[a]&lt;&lt;endl;</span><br><span class="line">        if(s2[a]&gt;=&#x27;a&#x27;)&#123;</span><br><span class="line">            g[s2[a]].emplace_back(s1[a]);</span><br><span class="line">            din[s1[a]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        s2=s1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line"></span><br><span class="line">    FOR(i,&#x27;a&#x27;,&#x27;z&#x27;)&#123;</span><br><span class="line">        if(!din[i])q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(q.sz)&#123;</span><br><span class="line">        int t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ans.pb(t);</span><br><span class="line">        for(auto x:g[t])&#123;</span><br><span class="line">            --din[x];</span><br><span class="line">            if((din[x])==0)&#123;</span><br><span class="line">                q.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans.sz&lt;26)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(auto x:ans)cout&lt;&lt;char(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：对于很多字符的题目要找什么关系的时候，往往会转化到图<del>（还记得ICPC杭州区域赛A题用的也是字符串的关系建图）</del></p>
</blockquote>
<h2 id="Maximum-AND-1800-位运算"><a href="#Maximum-AND-1800-位运算" class="headerlink" title="Maximum AND *1800 位运算"></a>Maximum AND <strong>*1800</strong> 位运算</h2><p><del>不得不说位运算的挺有意思的，出题人总有很特殊的角度进行考察。</del></p>
<ul>
<li>$b$ 数组是可以任意排序的。</li>
<li>因为是先异或再与的，可以发现：要让最后的结果最大，那肯定对于每一位来说都要有 $1$ 是最好的。</li>
<li>可以发现：$0 \^\ 1 =1$，那么可以知道 $a$ 数组的 $0$ 的个数是可以跟 $b$ 数组的 $1$ 数组是相等的（前提是在第 $i$ 位的情况下），反过来也相等。</li>
<li>那么也就是说匹配是相同的。</li>
<li>此时就可以先枚每一位，如果答案的这一位要是 $1$ 的情况下，那么必须让 $a$ 数组和 $b$ 数组的匹配是相同的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int t)&#123;</span><br><span class="line">    VI x,y;</span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        x.pb(a[i]&amp;t);</span><br><span class="line">        y.pb((b[i]&amp;t)^t);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ALL(x));</span><br><span class="line">    sort(ALL(y));</span><br><span class="line">    return x==y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;a[i];</span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FORD(i,0,30)&#123;</span><br><span class="line">        if(check(ans|(1ll&lt;&lt;i)))&#123;</span><br><span class="line">            ans|=(1&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有想到每一位的匹配是相同的。</p>
</blockquote>
<h1 id="2-8-专题速练-水题乱刷"><a href="#2-8-专题速练-水题乱刷" class="headerlink" title="2.8 专题速练+水题乱刷"></a>2.8 专题速练+水题乱刷</h1><p><del>今天特别冷，我靠，手放在键盘上一种冻僵的感觉很难受，所以今天的做题体验是特别的差，但今天算下来我也收获了挺多。</del></p>
<p><del>后面决定启动仪式的时候得做几道水题，要不然没有状态。</del></p>
<h2 id="1920C-Partitioning-the-Array-1600-数学"><a href="#1920C-Partitioning-the-Array-1600-数学" class="headerlink" title="1920C-Partitioning the Array *1600 数学"></a>1920C-Partitioning the Array <strong>*1600</strong> 数学</h2><ul>
<li>要分成 $k$ 份，那么 $k$ 必须是 $n$ 的因数。</li>
<li>要让每个组的数相同，那么也就是让 $a<em>i \equiv a</em>{i+k}(\mod m)$，那么算这个之前做过类似的，就是变成： $a<em>i -a</em>{i+k}\equiv 0(\mod m)$，也就是 $|a<em>i-a</em>{i+k}|$ 能被 $m$ 整除，那么 $m$ 也就是它的因数。</li>
<li>要求 $m$ 的个数也就是求 $|a<em>i-a</em>{i+k}|$ 的最小公倍数。</li>
<li><p>如果最小公倍数等于 $1$ 则不满足条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    int t=0;</span><br><span class="line">    FOR(i,x+1,n)&#123;</span><br><span class="line">        t=__gcd(t,abs(w[i]-w[i-x]));</span><br><span class="line">        if(t==1)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n/i;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            if(check(i))res++;</span><br><span class="line">            if(i!=n/i&amp;&amp;check(n/i))res++;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>最关键的是得考虑多个数都能被 $x$ 整除，那么 $x$ 是它们的最小公倍数。</p>
</blockquote>
<h2 id="1899F-Alex’s-whims-1600-思维-构造"><a href="#1899F-Alex’s-whims-1600-思维-构造" class="headerlink" title="1899F-Alex’s whims *1600 思维+构造"></a>1899F-Alex’s whims <strong>*1600</strong> 思维+构造</h2><ul>
<li>这就是骗分题，直接让树是一条链，此时的边长是 $n-1$。</li>
<li>然后如果 $d\&lt;n-1$，此时就断开 $(n,n-1)$，连接 $(n,d)$<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-1)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;i+1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    int t=n-1;</span><br><span class="line"></span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int d;</span><br><span class="line">        cin&gt;&gt;d;</span><br><span class="line">        if(d==t)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1 -1 -1&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;&#x27; &#x27;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">            t=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>最关键的就是能想到是一条链，然后在链条上修修补补就可以了。因此对于构造题，可以想象特殊情况是什么，这样就能更好的构造了。（<del>千万不要被难度吓到，其实有的难度是虚高的</del>）</p>
</blockquote>
<h2 id="1801A-The-Very-Beautiful-Blanket-1600-构造"><a href="#1801A-The-Very-Beautiful-Blanket-1600-构造" class="headerlink" title="1801A-The Very Beautiful Blanket *1600 构造"></a>1801A-The Very Beautiful Blanket <strong>*1600</strong> 构造</h2><ul>
<li>嘿嘿，我直接看样例发现这样构造可以满足：</li>
</ul>
<script type="math/tex; mode=display">0\ 1 \ 4\ 5</script><script type="math/tex; mode=display">2\ 3 \ 6 \ 7</script><script type="math/tex; mode=display">512 \ 513 \ 516 \ 517</script><script type="math/tex; mode=display">514 \ 515 \ 518 \ 518</script><ul>
<li>这个也很容易证明：$a\oplus a+1 \oplus a+2 \oplus a+3 =0$（<del>这个非常重要，很多时候都会用到</del>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;n*m&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    w[1][1]=0,w[1][2]=1,w[2][1]=2,w[2][2]=3;</span><br><span class="line"></span><br><span class="line">    FOR2(i,3,n)&#123;</span><br><span class="line">        w[i][1]=w[i-2][1]+512,w[i][2]=w[i-2][2]+512;</span><br><span class="line">        w[i+1][1]=w[i-1][1]+512,w[i+1][2]=w[i-1][2]+512;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR2(j,3,m)&#123;</span><br><span class="line">        FOR(i,1,n)&#123;</span><br><span class="line">            w[i][j]=w[i][j-2]+4;</span><br><span class="line">            w[i][j+1]=w[i][j-1]+4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            cout&lt;&lt;w[i][j]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造题哈哈哈。</p>
</blockquote>
<h2 id="1707A-Doremy’s-IQ-1600-贪心-正难则反思想"><a href="#1707A-Doremy’s-IQ-1600-贪心-正难则反思想" class="headerlink" title="1707A-Doremy’s IQ *1600 贪心+正难则反思想"></a>1707A-Doremy’s IQ <strong>*1600</strong> 贪心+正难则反思想</h2><ul>
<li>这道题一上来其实可以知道对于每个物品有 <strong>选</strong> 和 <strong>不选</strong> 两种情况，对于这种情况，通常的方法有：<code>dfs</code> ，<code>01背包</code>，<code>贪心</code>。</li>
<li>发现数据规模大，因此选择贪心。</li>
<li>如果选择正向贪心的话，可以发现后效性非常严重，根本不确定某个比赛到底要不要选，因此考虑反向贪心。</li>
<li>可以无脑先选最后一个，然后往前推，直到智商增加到了 $k$。</li>
</ul>
<blockquote>
<p>Q：那为什么这样贪心能保证没有后效性呢？</p>
<p>A：1. 反向能使得智商没有得到浪费。</p>
<ol>
<li><p>能使得智商不减的操作（见代码的注释 <code>//</code> 处）变得更多。</p>
</li>
<li><p>如果正着来的话起点的选择是多样的。</p>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i];</span><br><span class="line">    </span><br><span class="line">    int k=0;</span><br><span class="line">    string ans;</span><br><span class="line">    ans.resize(n+1);</span><br><span class="line">    </span><br><span class="line">    FORD(i,1,n)&#123;</span><br><span class="line">        if(k&gt;=w[i])ans[i]=&#x27;1&#x27;;//这个会更多</span><br><span class="line">        else if(k&lt;q)ans[i]=&#x27;1&#x27;,k++;</span><br><span class="line">        else if(k&gt;q)break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cout&lt;&lt;(ans[i]?1:0);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1137B-Camp-Schedule-1600-KMP"><a href="#1137B-Camp-Schedule-1600-KMP" class="headerlink" title="1137B-Camp Schedule *1600 KMP"></a>1137B-Camp Schedule <strong>*1600</strong> KMP</h2><ul>
<li>如果纯纯贪心得考虑一种情况 <code>10101</code>，这个是被算作两次的 <code>101</code>。</li>
<li>如果单纯贪心的话这种情况是考虑不到的。</li>
<li>因此就得用 kMP 的 <code>next</code> 数组了。</li>
<li>此时如果匹配到了 <code>101</code>，那么就用 <code>next</code> 数组，此时 <code>next=1</code>，这样就不会出现输出结果为：<code>101101</code> 了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    scanf(&quot;%s %s&quot;,a+1,b+1);</span><br><span class="line"></span><br><span class="line">    n=strlen(a+1),m=strlen(b+1);</span><br><span class="line"></span><br><span class="line">    int j=0;</span><br><span class="line">    FOR(i,2,m)&#123;</span><br><span class="line">        while(j&amp;&amp;b[j+1]!=b[i])j=ne[j];</span><br><span class="line">        if(b[j+1]==b[i])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cnt[a[i]]++;</span><br><span class="line"></span><br><span class="line">    int t=1;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        if(cnt[b[t]])ans[i]=b[t],cnt[ans[i]]--;</span><br><span class="line">        else ans[i]=(b[t]^1),cnt[ans[i]]--;</span><br><span class="line">        if(t==m)t=ne[t];</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cout&lt;&lt;ans[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有想到 KMP 还可以这样被应用，<code>next</code> 数组用法。</p>
</blockquote>
<h2 id="346C-Lucky-Common-Subsequence-2000-dp-KMP"><a href="#346C-Lucky-Common-Subsequence-2000-dp-KMP" class="headerlink" title="346C-Lucky Common Subsequence *2000 dp+KMP"></a>346C-Lucky Common Subsequence <strong>*2000</strong> dp+KMP</h2><ul>
<li>如果没有 $virus$ 数组的话，那么这道题就是很典型的 <code>LCS</code> 的题目，dp 方程也就很好写了：<code>f[i][j]</code> 表示 $s_1$ 前 $i$ 个字符和 $s_2$ 前 $j$ 个字符能匹配的最长公共子序列，转移也就很好写了。</li>
<li>这道题多一个匹配，匹配就得请 KMP 出场了，此时 <code>f[i][j][k]</code> 表示：设当第一个串匹配到 $i$ 位，第二个串匹配到 $j$ 位时，能匹配到第三个串的 $k$ 位的最长公共子序列的方案。</li>
<li>状态转移方程：</li>
<li>$f<em>{i,j,t}=max{f</em>{i,j,t},f<em>{i-1,j-1,k}+s_1{_i}}f</em>{i,j,k}=max{f<em>{i-1,j,k},f</em>{i,j-1,k},f_{i,j,k}}$</li>
<li>这里特别要注意一下范围，范围是 $[0,virus.size()-1]$，为什么呢？因为可以不匹配也可以最多匹配到最后一个字母的前一个字母。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string max(string a,string b)&#123;</span><br><span class="line">    if(a.sz&gt;b.sz)&#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3;</span><br><span class="line">    </span><br><span class="line">    la=s1.sz,lb=s2.sz,lc=s3.sz;</span><br><span class="line">    s1=&#x27; &#x27;+s1,s2=&#x27; &#x27;+s2,s3=&#x27; &#x27;+s3;</span><br><span class="line"></span><br><span class="line">    if(la&gt;lb)&#123;</span><br><span class="line">        swap(la,lb);</span><br><span class="line">        swap(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int j=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,lc)&#123;</span><br><span class="line">        while(j&amp;&amp;s3[j+1]!=s3[i])j=ne[j];</span><br><span class="line">        if(s3[j+1]==s3[i])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,la)&#123;</span><br><span class="line">        FOR(j,1,lb)&#123;</span><br><span class="line">            FOR(k,0,lc-1)&#123;</span><br><span class="line">                if(s1[i]==s2[j])&#123;</span><br><span class="line">                    int t=k;</span><br><span class="line">                    while(t&gt;0&amp;&amp;s1[i]!=s3[t+1])&#123;</span><br><span class="line">                        t=ne[t];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(s1[i]==s3[t+1])t++;</span><br><span class="line">                    f[i][j][t]=max(f[i][j][t],f[i-1][j-1][k]+s1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                f[i][j][k]=max(f[i][j][k],f[i-1][j][k]);</span><br><span class="line">                f[i][j][k]=max(f[i][j][k],f[i][j-1][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string ans;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,lc-1)&#123;</span><br><span class="line">        if(f[la][lb][i].sz&gt;=ans.sz)&#123;</span><br><span class="line">            ans=f[la][lb][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans.sz==0)&#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类似这种匹配的还是得把 KMP 放在考虑的范围上。</p>
</blockquote>
<h2 id="59E-Shortest-Path-2000-最短路-hash-路径记录"><a href="#59E-Shortest-Path-2000-最短路-hash-路径记录" class="headerlink" title="59E-Shortest Path *2000 最短路+hash+路径记录"></a>59E-Shortest Path <strong>*2000</strong> 最短路+hash+路径记录</h2><ul>
<li>就是一个最短路，因为边权为 $1$，直接用 <code>bfs</code> 做。</li>
<li>还有就是得记录路径（<strong>这部分是难点</strong>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].emplace_back(b);</span><br><span class="line">        g[b].emplace_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,k)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        S.insert(&#123;a,b,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PII ans=&#123;-1,-1&#125;;</span><br><span class="line"></span><br><span class="line">    queue&lt;array&lt;int,2&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    q.push(&#123;1,1&#125;);</span><br><span class="line"></span><br><span class="line">    while(q.sz)&#123;</span><br><span class="line">        auto [u,v]=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        if(v==n)&#123;</span><br><span class="line">            ans=&#123;u,v&#125;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(auto j:g[v])&#123;</span><br><span class="line">            if(S.count(&#123;u,v,j&#125;)||p[v][j])continue;</span><br><span class="line">            p[v][j]=u;</span><br><span class="line">            q.push(&#123;v,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans.fi==-1)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    VI res;</span><br><span class="line"></span><br><span class="line">    while(ans.se!=1)&#123;</span><br><span class="line">        res.push_back(ans.se);</span><br><span class="line">        ans=&#123;p[ans.fi][ans.se],ans.fi&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res.sz&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    res.push_back(1);</span><br><span class="line">    reverse(ALL(res));</span><br><span class="line"></span><br><span class="line">    for(auto x:res)cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最关键是路径记录。</p>
</blockquote>
<h2 id="653E-Bear-and-Forgotten-Tree-2-2400-bfs-思维"><a href="#653E-Bear-and-Forgotten-Tree-2-2400-bfs-思维" class="headerlink" title="653E- Bear and Forgotten Tree 2 *2400 bfs+思维"></a>653E- Bear and Forgotten Tree 2 <strong>*2400</strong> bfs+思维</h2><ul>
<li>不满足条件的特判很好写，略。</li>
<li>此时把 $1$ 去掉，看其它的点相互连边（排除掉禁止连边的边），如果其他点相互连接的产生的连通块比 $k$ 大，此时就说明 $1$ 就得向这些连通块连超过 $k$ 条边的边。</li>
<li>这里用 <code>bfs</code> 去算连通块，这里偷个懒，直接用 <code>set</code> 把所有的点加进去，如果在一个连通块内，就把这些点全部删掉，如果删掉剩下的点跟 $1$ 有边相连，说明这个连通块是靠近 $1$ 相邻点，此时这个点就不能被 $1$ 访问到，此时就不是一棵树了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bfs(int u)&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    VI t;</span><br><span class="line">    q.push(u);</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int v=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(auto j:S)&#123;</span><br><span class="line">            if(!g[v].count(j))&#123;</span><br><span class="line">                t.pb(j);</span><br><span class="line">                q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(t.sz)S.erase(t.back()),t.pop_back();</span><br><span class="line">        if(!g[v].count(1))f=false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    int d=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,m)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b]=1;</span><br><span class="line">        g[b][a]=1;</span><br><span class="line">        if(a==1||b==1)d++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(n-d-1&lt;k)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        S.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int cnt=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        if(S.count(i))&#123;</span><br><span class="line">            S.erase(i);</span><br><span class="line">            f=1;</span><br><span class="line">            bfs(i);</span><br><span class="line">            cnt++;</span><br><span class="line">            if(f)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cnt&lt;=k)cout&lt;&lt;&quot;possible&quot;&lt;&lt;endl;</span><br><span class="line">    else cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>典型的连通块问题，可以用 <code>bfs</code> 、 并查集 、<code>targin</code> 等来做。</p>
</blockquote>
<h2 id="1923A-Moving-Chips"><a href="#1923A-Moving-Chips" class="headerlink" title="1923A-Moving Chips"></a>1923A-Moving Chips</h2><ul>
<li>水题：就是简单统计 $1$ 直接 $0$ 的个数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s[i]=s[i-1]+(w[i]==0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int l=0,r=n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        if(w[i]==1)&#123;</span><br><span class="line">            l=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FORD(i,1,n)&#123;</span><br><span class="line">        if(w[i]==1)&#123;</span><br><span class="line">            r=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1879A-Rigged"><a href="#1879A-Rigged" class="headerlink" title="1879A-Rigged!"></a>1879A-Rigged!</h2><ul>
<li>水题，直接让答案等于第一个数的第一个数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i].fi&gt;&gt;w[i].se;</span><br><span class="line"></span><br><span class="line">    int ans=1e18;</span><br><span class="line"></span><br><span class="line">    FOR(i,2,n)&#123;</span><br><span class="line">        if(w[i].se&gt;=w[1].se&amp;&amp;w[i].fi&gt;=w[1].fi)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;w[1].fi&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Fire-Again-1500-多路bfs"><a href="#Fire-Again-1500-多路bfs" class="headerlink" title="Fire Again *1500 多路bfs"></a>Fire Again <strong>*1500</strong> 多路bfs</h2><ul>
<li>很好写的，本题最坑的就是得用 <code>freopen(&quot;&quot;,&quot;&quot;,stdin/stdout)</code>，因为在文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    queue&lt;array&lt;int,3&gt;&gt;q;</span><br><span class="line">    </span><br><span class="line">    FOR(i,1,k)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        vis[x][y]=1;</span><br><span class="line">        q.push(&#123;x,y,0&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            w[i][j]=1e9;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(q.sz)&#123;</span><br><span class="line">        auto [x,y,step]=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        w[x][y]=min(w[x][y],step);</span><br><span class="line">        FOR(i,0,3)&#123;</span><br><span class="line">            int a=dx[i]+x,b=dy[i]+y;</span><br><span class="line">            if(a&lt;1||b&lt;1||a&gt;n||b&gt;m||vis[a][b])continue;</span><br><span class="line">            vis[a][b]=1;</span><br><span class="line">            q.push(&#123;a,b,step+1&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int t=0;</span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            t=max(t,w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            if(t==w[i][j])&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有的不是标准输入输出，就得用 <code>freopen</code>。</p>
</blockquote>
<h2 id="Gym-100866A-Anti-factorial-高精度-小技巧"><a href="#Gym-100866A-Anti-factorial-高精度-小技巧" class="headerlink" title="Gym-100866A-Anti factorial 高精度/小技巧"></a>Gym-100866A-Anti factorial 高精度/小技巧</h2><ul>
<li>哈哈哈，其实不用高精度也可以做，可以：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    int t=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,s.sz-1)&#123;</span><br><span class="line">        t=(t*10+s[i]-&#x27;0&#x27;)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[0]=1;</span><br><span class="line">    FOR(i,1,255)&#123;</span><br><span class="line">        fac[i]=fac[i-1]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,255)&#123;</span><br><span class="line">        if(t==fac[i])&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>高精度做法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solbve()&#123;</span><br><span class="line">    VI p;</span><br><span class="line">    p.pb(1);</span><br><span class="line">    VI pd;</span><br><span class="line">    for(auto x:s)&#123;</span><br><span class="line">        pd.push_back(x-&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,255)&#123;</span><br><span class="line">        int t=0;</span><br><span class="line">        VI c;</span><br><span class="line">        for(int j=0;j&lt;p.sz||t;j++)&#123;</span><br><span class="line">            if(j&lt;p.sz)t+=p[j]*i;</span><br><span class="line">            c.pb(t%10);</span><br><span class="line">            t/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        p=c;</span><br><span class="line">        reverse(ALL(c));</span><br><span class="line">        if(c==pd)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1735D-Meta-set-1700-思维"><a href="#1735D-Meta-set-1700-思维" class="headerlink" title="1735D-Meta-set *1700 思维"></a>1735D-Meta-set <strong>*1700</strong> 思维</h2><ul>
<li><p>可以很容易发现，对于 <script type="math/tex">a:\ 0 \ 1 \ 2</script> <script type="math/tex">b:\ 0 \ 2 \ 1</script></p>
</li>
<li><p>那么 $c$ 串也就可以很容易判断出来是 $0 \ 0 \ 0$。</p>
</li>
<li><p>题目说只要 $&gt;1$ 个满足这样的，就可以认为是符合条件的。</p>
</li>
<li><p>因为 $n\le 10^3$ ，所以可以直接先枚举其中的两个，由于这些数字最大也就 $2$，因此可以想到三进制，由于要定位第三个串，所以必须要让每个串能被十进制数表示，因此就得用三进制来维护。</p>
</li>
<li><p>那么为了使该五元集合法，五元集中必须能提取出至少两个的合法三元集。我们之前已经求出 $sum$ 数组，记录含有 $i$ 串的合法三元集的个数。于是当前第 $i$ 串对结果的贡献就是 $C_{sum_i}^2$。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calc(int x,int y)&#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=1,t=1;i&lt;=m;i++,t*=3)&#123;</span><br><span class="line">        if(w[x][i]==w[y][i])&#123;</span><br><span class="line">            res+=w[x][i]*t;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res+=(3-w[x][i]-w[y][i])*t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        int t=1,s=0;</span><br><span class="line">        FOR(j,1,m)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">            a[i]+=w[i][j]*t;</span><br><span class="line">            t*=3;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n-2)&#123;</span><br><span class="line">        FOR(j,i+1,n-1)&#123;</span><br><span class="line">            int t=calc(i,j);</span><br><span class="line">            if(mp[t]&gt;j)&#123;</span><br><span class="line">                sum[i]++;</span><br><span class="line">                sum[j]++;</span><br><span class="line">                sum[mp[t]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)&#123;</span><br><span class="line">        ans+=sum[i]*(sum[i]-1)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数字不大，要定位第三个的话，可以考虑进制。</p>
</blockquote>
<h2 id="803D-Magazine-A-1900-二分"><a href="#803D-Magazine-A-1900-二分" class="headerlink" title="803D-Magazine A *1900 二分"></a>803D-Magazine A <strong>*1900</strong> 二分</h2><ul>
<li>这道题就是直接二分答案就可以了，如果遇到 <code>-</code> 或 ``的话，考虑换行，然后贪心就可以了。</li>
<li>题目具有单调性，二分生效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    int c1=1,c2=0,c3=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,0,s.sz-1)&#123;</span><br><span class="line">        if(s[i]==&#x27; &#x27;||s[i]==&#x27;-&#x27;)c3=i;</span><br><span class="line">        c2++;</span><br><span class="line">        if(c2&gt;=x&amp;&amp;i!=s.sz-1)&#123;</span><br><span class="line">            if(!c3)return false;</span><br><span class="line">            c1++;</span><br><span class="line">            c2=i-c3;</span><br><span class="line">            c3=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return c1&lt;=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    int mx=0;</span><br><span class="line">    </span><br><span class="line">    cin.ignore();</span><br><span class="line">    getline(cin,s);</span><br><span class="line"></span><br><span class="line">    int l=0,r=1e12;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="883I-Photo-Processing-1900-二分-dp"><a href="#883I-Photo-Processing-1900-二分-dp" class="headerlink" title="883I-Photo Processing *1900 二分+dp"></a>883I-Photo Processing <strong>*1900</strong> 二分+dp</h2><ul>
<li>题目说了<strong>最大值最小</strong>，所以就是二分没错了。</li>
<li>然后现在是二分，此时也就是给定了答案，如果贪心去分配的话，感觉是有后效性的，因此就得用 <code>dp</code> 去做。</li>
<li>因为题目只要求分组，不需要具体方案，可以将输入的数排序，然后定义一个 $f_i$ 存的是前 $i$ 个数能满足条件的最后一个数的位置，那么只需判断 <code>f[n]</code> 是否等于 $n$。</li>
<li>转移：从前往后枚举，因为要求每组至少 $m$ 个数，对于当前的第 $i$ 个数，要使每个数都明确得分到一个组，看 <code>f[i−m]</code> 存的前一位，即没分到组的第一个数，如果 <code>a[i]−a[t+1]</code> 小于 <code>mid</code> 则可以分为一组更新 <code>f[i]=i</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(int x)&#123;</span><br><span class="line">    VI f(n+1,0);</span><br><span class="line"></span><br><span class="line">    int pos=0;</span><br><span class="line"></span><br><span class="line">    FOR(i,m,n)&#123;</span><br><span class="line">        int t=f[i-m];</span><br><span class="line">        if(w[i]-w[t+1]&lt;=x)pos=i;</span><br><span class="line">        f[i]=pos;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[n]==n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    FOR(i,1,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    sort(w+1,w+1+n);</span><br><span class="line"></span><br><span class="line">    int l=-1,r=w[n]-w[1]+1;</span><br><span class="line"></span><br><span class="line">    while(l+1!=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))r=mid;</span><br><span class="line">        else l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    if(check(l))r=l;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>到这里一天又结束了，感慨时间过得真快，我花了 $2$ 小时也终于写到了这里。</p>
<hr>
<h1 id="2-9-2-14-26"><a href="#2-9-2-14-26" class="headerlink" title="2.9-2.14  26"></a>2.9-2.14  <sup>26</sup></h1><p><del>期间发生了许多事情，其中有 $3$ 天时间把这个刷题给搁置了，因为流感是真的严重，在修养身体。</del></p>
<p>2.14统一更新：</p>
<h2 id="706B-Interesting-drink-1100"><a href="#706B-Interesting-drink-1100" class="headerlink" title="706B-Interesting drink *1100"></a>706B-Interesting drink <strong>*1100</strong></h2><ul>
<li>没什么说的，二分的水题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">upper_bound</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n,x)-w<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1198B-Welfare-State-1600-思维-值得重构"><a href="#1198B-Welfare-State-1600-思维-值得重构" class="headerlink" title="1198B-Welfare State *1600 思维 值得重构"></a>1198B-Welfare State <strong>*1600</strong> 思维 值得重构</h2><ul>
<li><p>看题目，有单点修改和区间修改以及查询，因此很容易可以想到线段树。</p>
</li>
<li><p>但我们可以仔细考虑一下，发现有的操作是无用的，这样的思维就可以让我们离线处理查询。</p>
</li>
<li><p>比如补平均以下的 $2$，然后我此时的值是 $5$，那么此时这种操作就失效了。</p>
</li>
<li><p>还有一个性质就是：数字单调不降，除修改外。</p>
</li>
<li><p>综合以上性质，可以很容易写出：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].fi;</span><br><span class="line">        w[i].se=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,Q)&#123;</span><br><span class="line">        <span class="type">int</span> opt,p,x;</span><br><span class="line">        cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;p&gt;&gt;x;</span><br><span class="line">            w[p]=&#123;x,i&#125;;</span><br><span class="line">            q[i]=<span class="number">-1e18</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">0</span>,Q)&#123;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,q[i]);</span><br><span class="line">        pre[i]=mx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(pre[w[i].se],w[i].fi)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线段树做法更容易。</p>
<p>反思：本来有这种离线处理的思想，但总是往排序那边想了，可能是被分块的题目误导了，分块的题目经常要把查询进行排序。<br>这道题其实只需要倒叙来做就可以了，倒叙维护最大值。</p>
</blockquote>
<h2 id="1239A-Ivan-the-Fool-and-the-Probability-Theory-1700-找规律"><a href="#1239A-Ivan-the-Fool-and-the-Probability-Theory-1700-找规律" class="headerlink" title="1239A-Ivan the Fool and the Probability Theory *1700 找规律"></a>1239A-Ivan the Fool and the Probability Theory <strong>*1700</strong> 找规律</h2><ul>
<li><p>如果只有一行的情况，如果是 $1\times1$ ，答案为 $2$，如果是 $1\times 2$ ，答案为 $4$。</p>
</li>
<li><p>那么可以很容易发现如果是 $1\times n$ 的情况，答案就是斐波那契数列的 $2f<em>1+2f</em>{n}-2$。</p>
</li>
<li><p>至于证明，<del>其实不太会</del>。</p>
</li>
<li><p>简略证明为什么是斐波那契数列：</p>
</li>
</ul>
<p>令 $f<em>{i,0}$ 为第 $i$ 行涂黑色的方案数， $f</em>{i,1}$ 为第 $i$ 行涂白色的方案数。</p>
<p>由于同一个颜色的最多只能有 $1$ 个相邻，那么看前面几行可以得出：</p>
<script type="math/tex; mode=display">f_{i,0}=f_{i-1,0}+f_{i-2,0}</script><script type="math/tex; mode=display">f_{i,1}=f_{i-1,1}+f_{i-2,1}</script><p>所以：</p>
<script type="math/tex; mode=display">f_{i}=f_{i-1}+f_{i-2}</script><p>证明完毕。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,<span class="built_in">max</span>(n,m)<span class="number">+2</span>)&#123;</span><br><span class="line">        f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">2</span>*(f[n]+f[m]<span class="number">-1</span>)%mod&lt;&lt;endl;<span class="comment">//-1就是同色相邻的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果出什么求方案数，它很有可能是排列组合或者通过找规律来得出结论的。</p>
</blockquote>
<h2 id="1364C-Ehab-and-Prefix-MEXs-1600-构造题"><a href="#1364C-Ehab-and-Prefix-MEXs-1600-构造题" class="headerlink" title="1364C-Ehab and Prefix MEXs *1600 构造题"></a>1364C-Ehab and Prefix MEXs <strong>*1600</strong> 构造题</h2><ul>
<li><p>这是一道 $mex$ 的题目，mex的性质有单调不降，然后当 $w_i \le i$，其中 $w_i$ 指的是当前 mex 值。</p>
</li>
<li><p>特判很容易，关键是构造，这里直接采用如果 $w<em>i=w</em>{i-1}$，此时就找下一个的下一个（不是下一个的最小的下一个），这里的原始答案默认按照 $0,1,…,n-1$ 的方式来。</p>
</li>
<li><p>如果 $w<em>i\not= w</em>{i-1}$ ，那么就取 $w_{i-1}$，可以很容易证明这样一定是最优的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;i)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        vis[w[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(w[<span class="number">1</span>]==<span class="number">1</span>)vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]==w[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">while</span>(p&lt;=n<span class="number">+1</span>&amp;&amp;vis[p])p++;</span><br><span class="line">            vis[p]=<span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;p&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;w[i<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mex的性质得多掌握，mex如果是连续的情况下，往往跟上一个mex的差值是1。</p>
</blockquote>
<h2 id="1514C-Product-1-Modulo-N-1600-构造-数学"><a href="#1514C-Product-1-Modulo-N-1600-构造-数学" class="headerlink" title="1514C-Product 1 Modulo N *1600 构造+数学"></a>1514C-Product 1 Modulo N <strong>*1600</strong> 构造+数学</h2><ul>
<li><p>设乘积为 $s$，那么 $s\equiv 1 \ (\mod n)$。</p>
</li>
<li><p>此时可以设除 $a_i$ 外其他数的乘积是 $p$，那么：$a_ip\equiv 1\ (\mod n)$，根据裴蜀定理，此时 $gcd(a_i,n)=1$。</p>
</li>
<li><p>之后把所有与 $n$ 互质的数在模 $n$ 意义下乘起来，可以得到一个小于 $n$ 的数 $ans$ ， $ans$ 一定与 $n$ 互质。（辗转相除的原理）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(i,n)==<span class="number">1</span>)&#123;</span><br><span class="line">            w[i]=<span class="number">1</span>;</span><br><span class="line">            s=s*i%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="number">1</span>)w[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i])cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最关键的就是得知道裴蜀定理的应用。</p>
</blockquote>
<h2 id="1548B-Integers-Have-Friends-1800-数学"><a href="#1548B-Integers-Have-Friends-1800-数学" class="headerlink" title="1548B- Integers Have Friends *1800 数学"></a>1548B- Integers Have Friends <strong>*1800</strong> 数学</h2><ul>
<li><p>要让 $a<em>i \mod m =a</em>{i+1} \mod m=…a<em>j \mod m$，此时很容易知道，对于相邻两项，有：$|a_i-a</em>{i+1}| \mod m=0$，然后前面的式子有 $j-i$ 个，此时要让所有数 $\mod m=0$，就是得让 $\gcd(|a<em>i-a</em>{i+1}|,|a<em>{i+1}-a</em>{i+2}|,…)&gt;1$。</p>
</li>
<li><p>那个 $\gcd$ 的值是自定义的并且是寻找最长的区间使得 $\gcd&gt;1$，因此可以采用<strong>取尺法</strong>。</p>
</li>
<li><p>区间的 $\gcd$ 值可以用 st 表维护。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">20</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)f[i][j]=c[i];</span><br><span class="line">            <span class="keyword">else</span> f[i][j]=__gcd(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> __gcd(f[l][len],f[r-(<span class="number">1</span>&lt;&lt;len)<span class="number">+1</span>][len]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],c[i]=<span class="built_in">abs</span>(w[i]-w[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">query</span>(l<span class="number">+1</span>,r)&lt;=<span class="number">1</span>)l++;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,r-l<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;mx&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>求最长区间满足某个条件的题目可以考虑取尺法。取尺法本质就是两个同向指针。<br><strong>尺取法处理是问题是一段连续的区间，区间是单调的。</strong></p>
<p><a href="https://www.acwing.com/blog/content/4409/">引用</a></p>
<p>使用尺取法时应清楚以下四点：</p>
<p>1、  什么情况下能使用尺取法?  2、何时推进区间的端点？ 3、如何推进区间的端点？ 3、何时结束区间的枚举？</p>
<p>尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步</p>
<p>得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。</p>
</blockquote>
<h2 id="1633D-Make-Them-Equal-1600-dp-数学"><a href="#1633D-Make-Them-Equal-1600-dp-数学" class="headerlink" title="1633D-Make Them Equal *1600 dp+数学"></a>1633D-Make Them Equal <strong>*1600</strong> dp+数学</h2><ul>
<li><p>对于每个数 $a_i$，有 $a_i+\lfloor \frac{a_i}{x} \rfloor$，又因为数组的数最大也就 $10^3$，因此可以预处理出最小操作次数，即： $i=i+i/j$，这个可以暴力取枚举。</p>
</li>
<li><p>对于后面的操作就是直接 <code>01背包</code>，因为每个数可以操作和不操作两种情况，对于 <code>01背包</code> 也就是选和不选两种情况。</p>
</li>
<li><p>特判：如果操作次数大于等于 $a$ 数组的和，此时说明所有的数都可以被遍历到。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">1000</span>)g[i]=<span class="number">1e18</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">            <span class="type">int</span> k=i+i/j;</span><br><span class="line">            g[k]=<span class="built_in">min</span>(g[k],g[i]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>,tc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i],tot+=a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i],tc+=b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k&gt;=tot)&#123;</span><br><span class="line">        cout&lt;&lt;tc&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,k<span class="number">+1</span>)f[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORD</span>(j,g[a[i]],k)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-g[a[i]]]+b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[k]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数小的时候多考虑预处理和dp，题目中是操作次数有选和不选两种情况。</p>
<p><strong>卡：没有想到去预处理，然后想了非常复杂的贪心，<del>太菜了</del></strong></p>
</blockquote>
<h2 id="1758D-Range-√Sum-1800-构造"><a href="#1758D-Range-√Sum-1800-构造" class="headerlink" title="1758D-Range = √Sum *1800 构造"></a>1758D-Range = √Sum <strong>*1800</strong> 构造</h2><ul>
<li><p>可以很容易想到偶数的构造是：<script type="math/tex">...,n-2,n-1,n+1,n+2,...</script>，这个的和是 $n^2$，而且最大值减最小值就是 $n$。</p>
</li>
<li><p>奇数考虑：<script type="math/tex">\frac{n}{2}+2,...,n,...,n+3,...,\frac{3n}{2}+3</script>。这个的和是 $(n+1)^2$，最大值减最小值是 $(n+1)$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,n/<span class="number">2</span><span class="number">+2</span>,n)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,n<span class="number">+3</span>,n+n/<span class="number">2</span><span class="number">+3</span>)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,n-n/<span class="number">2</span>,n+n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=n)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造的题还是多多举例，有的时候很经常要 <strong>奇偶分讨</strong>。</p>
</blockquote>
<h2 id="1774B-Coloring-1500-数学"><a href="#1774B-Coloring-1500-数学" class="headerlink" title="1774B-Coloring *1500 数学"></a>1774B-Coloring <strong>*1500</strong> 数学</h2><ul>
<li><p>本题要求构造一个序列，要求连续 $k$ 个数不能重复。</p>
</li>
<li><p>可以将每 $k$ 个数看作一组，显然有 $(n + k - 1) / k$ 组，一个数最多只能在每组中出现一次，<br>因此如果存在 $a_i &gt; (n + k - 1) / k$，则一定无解。</p>
</li>
<li><p>最后一组并不一定有 $k$ 个，而是有 $(n - 1) % k + 1$（最后一组不可能为 $0$，特殊处理一下），<br>这意味着只有 $(n - 1) % k + 1$ 能出现 $(n + k - 1) / k$ 次，因此统计一下出现 $(n + k - 1) / k$<br>次的数的个数 $cnt$，如果 $cnt &gt; (n - 1) % k + 1$，则也一定无解。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=(n+k<span class="number">-1</span>)/k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;t)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w[i]==t)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;=(n<span class="number">-1</span>)%k<span class="number">+1</span>)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有想到平均分组，当时想的太混乱了。如果想到平均分组的话，那这道题就很简单了。<del>qwq</del></p>
</blockquote>
<h2 id="1774D-Same-Count-One-1600-思维"><a href="#1774D-Same-Count-One-1600-思维" class="headerlink" title="1774D-Same Count One *1600 思维"></a>1774D-Same Count One <strong>*1600</strong> 思维</h2><ul>
<li><p>就是先把横向统计一下，然后看纵向的 $1$ 的个数，这里有维护每一行的 $1$ 的个数。</p>
</li>
<li><p>特判比较容易，这里就不强调了。</p>
</li>
<li><p>然后就把某一列多余平均的给少于平均的，然后更新一下它们的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">w</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">col</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">            <span class="keyword">if</span>(w[i][j])&#123;</span><br><span class="line">                tot++;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        col[i]=s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tot%n!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tot/=n;</span><br><span class="line"></span><br><span class="line">    VI zero,one;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt;res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        one.<span class="built_in">clear</span>(),zero.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[j]&gt;tot&amp;&amp;w[j][i]==<span class="number">1</span>)one.<span class="built_in">pb</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(col[j]&lt;tot&amp;&amp;w[j][i]==<span class="number">0</span>)zero.<span class="built_in">pb</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(one.sz,zero.sz)<span class="number">-1</span>)&#123;</span><br><span class="line">            res.<span class="built_in">pb</span>(&#123;zero[j],one[j],i&#125;);</span><br><span class="line">            col[one[j]]--;</span><br><span class="line">            col[zero[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res.sz&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y,z]:res)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是很单纯的贪心，个人已经想到预处理每一行 $1$ 的个数，然后肯定跟平均值有关，然后肯定是从多余平均的转移到少于平均的。然后就不想去了。<del>服了，就差一步。</del></p>
</blockquote>
<h2 id="1776L-Controllers-1500-数学"><a href="#1776L-Controllers-1500-数学" class="headerlink" title="1776L-Controllers *1500 数学"></a>1776L-Controllers <strong>*1500</strong> 数学</h2><ul>
<li>因为给定的数只有两个 $a,b$，因此可以很容易的建立如下方程组：</li>
</ul>
<p>设 $a$ 的 <code>+</code> 使用次数为 $u$，<code>-</code> 使用次数为 $v$，设使用字符串中的 <code>+</code> 的数量是 $x$， <code>-</code> 的数量是 $y$，那么有：</p>
<script type="math/tex; mode=display">au-av+b(x-u)-b(y-v)=0</script><script type="math/tex; mode=display">(u−v)⋅(a−b)=−(x−y)⋅b</script><ul>
<li><p>接下来是分类讨论一下：</p>
</li>
<li><ul>
<li>当 $a-b=0$，，$x−y$ 必为 $0$，否则无解。</li>
</ul>
</li>
<li><ul>
<li>当 $a−b\not=0$ 时，显然 $u−v=a−b−(x−y)⋅b$​。根据，$0≤u≤x，0≤v≤y$，通过这两个不等式解得 $−y≤u−v≤x$。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==y)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m=x-y;</span><br><span class="line">        <span class="keyword">if</span>(b*m%(b-a))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> k=b*m/(b-a);</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=-y&amp;&amp;k&lt;=x)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考的就是方程组，还是解不等式的。</p>
</blockquote>
<h2 id="1868B1-Candy-Party-Easy-Version-1700-位运算"><a href="#1868B1-Candy-Party-Easy-Version-1700-位运算" class="headerlink" title="1868B1-Candy Party (Easy Version) *1700 位运算"></a>1868B1-Candy Party (Easy Version) <strong>*1700</strong> 位运算</h2><ul>
<li><p>由于题目说什么转移 $2^x$ 颗糖果，此时就得考虑二进制——位运算了。</p>
</li>
<li><p>对于每一个数与平均数的差值 $b_i$，可以将它拆成 $2^x-2^y$ 的形式。</p>
</li>
<li><p>如果 $b_i$ 变不成这种形式，那么不可能满足条件——得到和付出 $2^x$ 颗糖果。</p>
</li>
<li><p>此时存储满足的 $x$ 和 $y$ 值，如果所有的 $x=y$，那么满足条件。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],sum+=w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum%n!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum/=n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m1,m2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> k=w[i]-sum;</span><br><span class="line">        <span class="keyword">if</span>(!k)<span class="keyword">continue</span>;<span class="comment">//bi=2^x-2^y</span></span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">abs</span>(k);</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">log2</span>(c)<span class="number">+1</span>,y=<span class="built_in">log2</span>((<span class="number">1</span>&lt;&lt;x)-c);</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;x)-(<span class="number">1</span>&lt;&lt;y)!=c)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;nO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        m1[x]++,m1[y]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">32</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m1[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;yEs&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>想到了位运算，但卡在：没有把形式很清晰的拆成 $2^x-2^y$ 的形式来做。</p>
<p>以后遇到类似的话，可以考虑某一个东西（比如差值，变化量等）有一种比较清晰的形式去表示。</p>
</blockquote>
<h2 id="1948C-Arrow-Path-1300"><a href="#1948C-Arrow-Path-1300" class="headerlink" title="1948C-Arrow Path *1300"></a>1948C-Arrow Path <strong>*1300</strong></h2><ul>
<li>大型 <code>bfs</code> 水题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x,y]=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=dx[i]+x,b=dy[i]+y;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>||b&lt;<span class="number">1</span>||a&gt;<span class="number">2</span>||b&gt;n)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[a][b]==<span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vis[a][b])<span class="keyword">continue</span>;</span><br><span class="line">            vis[a][b]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            vis[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;s[<span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;s[<span class="number">2</span>][i];</span><br><span class="line"></span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(vis[<span class="number">2</span>][n]?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1948D-Tandem-Repeats-1700-贪心-模拟"><a href="#1948D-Tandem-Repeats-1700-贪心-模拟" class="headerlink" title="1948D-Tandem Repeats? *1700 贪心+模拟"></a>1948D-Tandem Repeats? <strong>*1700</strong> 贪心+模拟</h2><ul>
<li>由于这个数组长度不大，直接暴力枚举就可以了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    n=s.sz;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x=i,mx=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+x&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==s[j+x]||s[j]==<span class="string">&#x27;?&#x27;</span>||s[j+x]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;=i)ans=<span class="built_in">max</span>(ans,<span class="number">2</span>*i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>刚开始还想着二分答案，没想到答案不具有单调性，比如 <code>c?csadasihd</code>，可能后面还能让它更优但二分不下去了。</p>
</blockquote>
<h2 id="1954B-Make-It-Ugly-1200"><a href="#1954B-Make-It-Ugly-1200" class="headerlink" title="1954B-Make It Ugly *1200"></a>1954B-Make It Ugly <strong>*1200</strong></h2><ul>
<li><p>其实总的思路就是从两端往中间靠，就是得注意这种情况：<code>1 2 2 1</code> ，此时答案为 <code>0</code>。</p>
</li>
<li><p>因此考虑的情况有：</p>
</li>
<li><ul>
<li>删除持续删除队尾。</li>
</ul>
</li>
<li><ul>
<li>删除持续删除队头。</li>
</ul>
</li>
<li><ul>
<li>删除中间元素。</li>
</ul>
</li>
<li><p>综上所述，只需要当 $a_i=a_1$ 的时候，再删除。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[w[<span class="number">1</span>]]==n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=n,len=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]==w[<span class="number">1</span>])&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,len);</span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=<span class="built_in">min</span>(ans,len);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>漏了考虑中间元素的删除情况。</p>
</blockquote>
<h2 id="1969C-Minimizing-the-Sum-1700-dp"><a href="#1969C-Minimizing-the-Sum-1700-dp" class="headerlink" title="1969C-Minimizing the Sum *1700 dp"></a>1969C-Minimizing the Sum <strong>*1700</strong> dp</h2><ul>
<li><p>题目说用相邻的元素去替换，那么当把时间范围拉长，此时就是一段区间一段区间的了。</p>
</li>
<li><p>由于一个数可以更新多个之相邻的连续的数，最终效果就是这一段的数都变成了这一段的最小值。</p>
</li>
<li><p>所以不妨枚举每个段，使之变为最小值，再进行转移。</p>
</li>
<li><p>所以设 $f_{i,j}$ 为在前 $i$ 个元素，最多操作 $k$ 次的最小总和。</p>
</li>
<li><p>状态转移：$f<em>{i+l,j+l}=\min(f</em>{i-1,j}+(l-1)*minv)$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;K;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,K)&#123;</span><br><span class="line">            f[i][j]=<span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,K)&#123;</span><br><span class="line">            <span class="type">int</span> minv=<span class="number">1e18</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l+j&lt;=K&amp;&amp;l+i&lt;=n;l++)&#123;<span class="comment">//固定长度去枚举最小值</span></span><br><span class="line">                minv=<span class="built_in">min</span>(minv,w[i+l]);</span><br><span class="line">                f[i+l][l+j]=<span class="built_in">min</span>(f[i+l][l+j],f[i<span class="number">-1</span>][j]+(l<span class="number">+1</span>)*minv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,K)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是想到dp了，但没有想到优化，就是按照固定长度去枚举最小值放入。而且如果不按照区间的转移，转移方程很难写。（就是卡在对于相邻问题没有考虑区间进行转移）。</p>
</blockquote>
<h2 id="1971G-XOUR-1700-构造"><a href="#1971G-XOUR-1700-构造" class="headerlink" title="1971G-XOUR *1700 构造"></a>1971G-XOUR <strong>*1700</strong> 构造</h2><ul>
<li><p>要让 $a_i \oplus a_j&lt;4$，此时：$\lfloor \frac{a_i}{4}\rfloor = \lfloor \frac{a_j}{4} \rfloor$。</p>
</li>
<li><p>也就是：所有除四下取整相同的 $a_i$​ 都可以按照原来的位置排序。</p>
</li>
<li><p>此时就用小堆来维护 $\lfloor \frac{a_i}{4}\rfloor$ 的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt;&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        S[w[i]/<span class="number">4</span>].<span class="built_in">push</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;S[w[i]/<span class="number">4</span>].<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        S[w[i]/<span class="number">4</span>].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有想到 $\lfloor \frac{a_i}{4}\rfloor = \lfloor \frac{a_j}{4} \rfloor$。</p>
</blockquote>
<h2 id="1983A-Array-Divisibility-水题"><a href="#1983A-Array-Divisibility-水题" class="headerlink" title="1983A-Array Divisibility 水题"></a>1983A-Array Divisibility 水题</h2><ul>
<li>思路就是直接输出 $1,2,3,…,n$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1983B-Corner-Twist-1200-思维"><a href="#1983B-Corner-Twist-1200-思维" class="headerlink" title="1983B-Corner Twist *1200 思维"></a>1983B-Corner Twist <strong>*1200</strong> 思维</h2><ul>
<li>首先得发现一个性质：每次变化每行和每列模 $3$ 的值都是不变的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            s[i][j]=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sa[i]=<span class="number">0</span>,ta[i]=<span class="number">0</span>;</span><br><span class="line">            tb[j]=<span class="number">0</span>,sb[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            t[i][j]=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            sa[i]=(sa[i]+s[i][j])%<span class="number">3</span>;</span><br><span class="line">            ta[i]=(ta[i]+t[i][j])%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            sb[i]=(sb[i]+s[j][i])%<span class="number">3</span>;</span><br><span class="line">            tb[i]=(tb[i]+t[j][i])%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sa[i]!=ta[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sb[i]!=tb[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1983C-Have-Your-Cake-and-Eat-It-Too-1400-双指针"><a href="#1983C-Have-Your-Cake-and-Eat-It-Too-1400-双指针" class="headerlink" title="1983C-Have Your Cake and Eat It Too *1400 双指针"></a>1983C-Have Your Cake and Eat It Too <strong>*1400</strong> 双指针</h2><ul>
<li><p>就直接枚举每一种情况，然后如果有这种情况，就直接输出即可。</p>
</li>
<li><p>枚举的每一种情况就是用双指针维护。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b[],<span class="type">int</span> c[],<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z,<span class="type">int</span> tot)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;<span class="built_in">res</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>,sc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sa&lt;tot)sa+=a[l++];</span><br><span class="line">    <span class="keyword">while</span>(sc&lt;tot)sc+=c[r--];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,l,r)&#123;</span><br><span class="line">        sb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27; &#x27;&lt;&lt;sa&lt;&lt;&#x27; &#x27;&lt;&lt;sb&lt;&lt;&#x27; &#x27;&lt;&lt;sc&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sb&lt;tot)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    res[<span class="number">1</span>]=&#123;<span class="number">1</span>,l<span class="number">-1</span>&#125;;</span><br><span class="line">    res[<span class="number">2</span>]=&#123;l,r&#125;;</span><br><span class="line">    res[<span class="number">3</span>]=&#123;r<span class="number">+1</span>,n&#125;;</span><br><span class="line">    </span><br><span class="line">    id[x]=<span class="number">1</span>,id[y]=<span class="number">2</span>,id[z]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res[id[<span class="number">1</span>]].fi&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;res[id[<span class="number">1</span>]].se&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;res[id[<span class="number">2</span>]].fi&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;res[id[<span class="number">2</span>]].se&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;res[id[<span class="number">3</span>]].fi&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;res[id[<span class="number">3</span>]].se&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i],s+=a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    s=(s<span class="number">+2</span>)/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(a,b,c,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(a,c,b,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(b,a,c,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(b,c,a,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(c,a,b,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(c,b,a,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,s))<span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误原因：没有正确处理好对应关系，就是 <code>f</code> 函数里面的对应关系。<br>以后就多考虑，自己先写认真考虑一遍再写。</p>
</blockquote>
<h2 id="2001A-Make-All-Equal-水题"><a href="#2001A-Make-All-Equal-水题" class="headerlink" title="2001A-Make All Equal 水题"></a>2001A-Make All Equal 水题</h2><ul>
<li>不说了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        S[w[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:S)&#123;</span><br><span class="line">        t=<span class="built_in">max</span>(t,y);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2001B-Generate-Permutation-水题"><a href="#2001B-Generate-Permutation-水题" class="headerlink" title="2001B-Generate Permutation 水题"></a>2001B-Generate Permutation 水题</h2><ul>
<li>可以很容易发现规律就是：如果是偶数就不行，奇数的话按照这种输出：$\lceil \frac{n}{2} \rceil+1,…,n,1,\lceil \frac{n}{2} \rceil$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(n&amp;<span class="number">1</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> t=(n<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FORD</span>(i,t<span class="number">+1</span>,n)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,t)cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2001C-Guess-The-Tree-1500-交互题-分治思想"><a href="#2001C-Guess-The-Tree-1500-交互题-分治思想" class="headerlink" title="2001C-Guess The Tree *1500 交互题+分治思想"></a>2001C-Guess The Tree <strong>*1500</strong> 交互题+分治思想</h2><ul>
<li><p>本质上就是先从 $1$ 开始猜，如果这里有边的话，就递归 $a,mid$ 和 $mid,b$。</p>
</li>
<li><p>这样的时间复杂度是优秀的。</p>
</li>
</ul>
<p>递归的总思路：<a href="https://www.luogu.com.cn/article/dwk0k5zu">来源</a></p>
<blockquote>
<p>总的思路：每次询问树根与一个未被标记的点 。然后递归处理：</p>
<p>先把询问的 b 点标记，并得到中点 x。现在需要处理 x 到 b 的路径和 a 到 x 的路径。</p>
<p>对于前者，直接递归下去即可。</p>
<p>对于后者，分类讨论一下：若 x 已被标记，说明 x 到根上的路径已经被确定，不需要处理；如果未被标记，则递归处理 a 到 x 的路径。</p>
<p>递归的终止条件为询问的点 a 与得到的点 x 相同（因为这时询问的 a,b 两点相邻），此时要把 a,b 连边。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="comment">//分治思想</span></span><br><span class="line">    vis[b]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid=<span class="built_in">query</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(mid==a)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;a,b&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!vis[mid])<span class="built_in">dfs</span>(a,mid);</span><br><span class="line">    <span class="built_in">dfs</span>(mid,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;! &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:ans)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有想到用分治去优化时间复杂度，如果按照暴力的话时间复杂度是 $O(n^2)$，如果是分治的话，时间复杂度可以降到 $O(n\sqrt n)$。</p>
</blockquote>
<h2 id="2005B2-The-Strict-Teacher-Hard-Version-1200-水题二分"><a href="#2005B2-The-Strict-Teacher-Hard-Version-1200-水题二分" class="headerlink" title="2005B2-The Strict Teacher (Hard Version) *1200 水题二分"></a>2005B2-The Strict Teacher (Hard Version) <strong>*1200</strong> 水题二分</h2><p><del>这道题是我最开始刷codeforces的比赛题目，我记得当时我连这种题目做的都很困难，现在看来我当时是真傻。</del></p>
<ul>
<li>不说了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> lt=<span class="built_in">upper_bound</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+m,x)-b<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rt=lt<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!lt)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,b[<span class="number">1</span>]<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rt&gt;m)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,n-b[lt])&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t=(b[lt]+b[rt])/<span class="number">2</span>;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">min</span>(<span class="built_in">abs</span>(b[lt]-t),<span class="built_in">abs</span>(b[rt]-t))&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2032C-Trinity-1400-双指针-思维"><a href="#2032C-Trinity-1400-双指针-思维" class="headerlink" title="2032C-Trinity *1400 双指针+思维"></a>2032C-Trinity <strong>*1400</strong> 双指针+思维</h2><ul>
<li><p>这道题就先排序，因为排序不会影响答案的个数。</p>
</li>
<li><p>其次把问题转化，题目问三角形数组的个数，此时就转化成总的个数减去不满足三角形数组的个数。</p>
</li>
<li><p>不满足三角形个数的可以直接用双指针维护。</p>
</li>
<li><p>为什么可以呢？因为不满足的个数有两个指针就是相邻的，这样可以把三维的变量转化成二维的变量，然后二维的变量就可以用双指针算法去解决。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=n&amp;&amp;w[l]+w[l<span class="number">+1</span>]&lt;=w[r])l++;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,r-l<span class="number">+1</span>);</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;n-ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三维变量转化为二位变量可以采取：CDQ分治、排序、转化题意（变成双指针形式）。</p>
</blockquote>
<h2 id="Gym-102992F-Fireworks-三分-概率"><a href="#Gym-102992F-Fireworks-三分-概率" class="headerlink" title="Gym-102992F Fireworks 三分+概率"></a>Gym-102992F Fireworks 三分+概率</h2><ul>
<li><p>假设一个 $E(x)$，表示多次造 $k$ 个烟花后燃放，出现至少一个完美烟花的概率最大的最小期望，简称最优。</p>
</li>
<li><p>形象的讲（不保证正确，但是好理解）：每次都造 $k$ 个后燃放出现完美烟花的概率是最大的，所以每次我们都只造 $k$ 个烟花后燃放。</p>
</li>
<li><p>因此：</p>
</li>
</ul>
<script type="math/tex; mode=display">E(x)=(k×n+m)×(1−(1−p)^k)+(k×n+m)×(1−p)^k+E(x)×(1−p)^k</script><ul>
<li>化简：</li>
</ul>
<script type="math/tex; mode=display">E(x)=\frac{1−(1−p)^k}{k×n+m}​</script><ul>
<li>求导可以看出该函数是个具有波谷的函数，用三分找到 $k$ 次就可求出 $E(x)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">EK</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n*x+m)/(<span class="number">1</span>-<span class="built_in">pow</span>((<span class="number">1</span>-p),x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">    p=p/<span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l=<span class="number">1</span>,r=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((r-l)&gt;eps)&#123;</span><br><span class="line">        <span class="type">double</span> midl=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="type">double</span> midr=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">EK</span>(midl)&gt;<span class="built_in">EK</span>(midr))l=midl;</span><br><span class="line">        <span class="keyword">else</span> r=midr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,<span class="built_in">EK</span>(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>具有波谷或波峰的函数可以采用三分来维护。</p>
</blockquote>
<p>这几天总结与评价：刷题还是得看重质量，往后还是按照 $+100$ <code>rating</code> $2-5$ 题的模式做，最重要的是认真总结。接下来大概花2-3天去把我之前把牛客的专题的题给总结了。</p>
<h1 id="2-15-2-17"><a href="#2-15-2-17" class="headerlink" title="2.15-2.17"></a>2.15-2.17</h1><p><del>妈的，怎么又感冒了，服了，才好几天哪。</del></p>
<h2 id="abc190-f-Shift-and-Inversions-逆序对；好题"><a href="#abc190-f-Shift-and-Inversions-逆序对；好题" class="headerlink" title="abc190-f Shift and Inversions 逆序对；好题"></a>abc190-f Shift and Inversions 逆序对；好题</h2><ul>
<li><p>如果没有移动的话，就是经典的逆序对，逆序对的求法有<strong>分治法</strong>和<strong>树状数组法</strong>。</p>
</li>
<li><p>如果有移动操作，那么逆序对的变化量就是 $n-w_i-(w_i-1)$，其中 $n-w_i$ 是 $w_i$ 移到第一位产生新的逆序对数，$w_i-1$ 是 $w_i$ 去掉损失的逆序对数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],w[i]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        res+=i<span class="number">-1</span>-<span class="built_in">query</span>(w[i]);</span><br><span class="line">        <span class="built_in">add</span>(w[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        res=res+(n-w[i])-w[i]<span class="number">+1</span>;<span class="comment">//把数字移动到前面逆序对变化量</span></span><br><span class="line">        <span class="comment">//n-w[i] 为增加逆序对的个数（比该数大的到该数前面，形成逆序对）</span></span><br><span class="line">		<span class="comment">//w[i]-1 为减少逆序对的个数（比该数到该数小的后面，拆散逆序对）</span></span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逆序对的应用题目，数字移动到端点逆序对的变化。</p>
</blockquote>
<h2 id="1714D-Color-with-Occurrences-1600-dp"><a href="#1714D-Color-with-Occurrences-1600-dp" class="headerlink" title="1714D-Color with Occurrences *1600 dp"></a>1714D-Color with Occurrences <strong>*1600</strong> dp</h2><ul>
<li><p>因为这里的数都是在 $100$ 以内，因此可以用 dp 来解决，那么此时状态表示很容易：$f_{i}$ 表示已经匹配好了前 $i$ 个字母需要花费的最小步数。</p>
</li>
<li><p>状态转移：$f<em>i=\min(f</em>{i-|s|}+1)$。</p>
</li>
<li><p>这里的匹配直接用 <code>strsub</code> 来做即可。（因为字符串不长）</p>
</li>
<li><p>然后要统计方案数，那就在转移的时候记录这个状态是从哪里来的，最后倒着遍历即可。（一般求方案都是这样）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=s.sz;</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;p[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)ans[i]=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n<span class="number">+2</span>,<span class="number">1e18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=p[j].sz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j]==s.<span class="built_in">substr</span>(i-p[j].sz<span class="number">+1</span>,p[j].sz))&#123;</span><br><span class="line">                    <span class="built_in">FOR</span>(k,i-p[j].sz,i<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(f[i]&gt;f[k]<span class="number">+1</span>)&#123;</span><br><span class="line">                            f[i]=f[k]<span class="number">+1</span>;</span><br><span class="line">                            ans[i]=&#123;k,j&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[n]==<span class="number">1e18</span>)&#123;</span><br><span class="line">        f[n]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> x=n;</span><br><span class="line">    <span class="keyword">while</span>(ans[x].first!=<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans[x].second&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;x-p[ans[x].second].sz<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">        x=ans[x].fi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以后遇到数比较小的时候又不至于太小的时候可以考虑dp来做。（非常重要）</p>
</blockquote>
<h2 id="1848C-Binary-String-Copying-1600-找规律"><a href="#1848C-Binary-String-Copying-1600-找规律" class="headerlink" title="1848C- Binary String Copying *1600 找规律"></a>1848C- Binary String Copying <strong>*1600</strong> 找规律</h2><ul>
<li>首先发现：<script type="math/tex">00110011</script></li>
</ul>
<p>如果选区间 $[1,8]$，那么它的操作结果其实跟 $[3,6]$ 是一样的。换句话说，就是：对区间 $[1,8]$ 排序也就是对 $[3,6]$ 排序。</p>
<ul>
<li><p>所以可以记录下每一个 $0$ 右边第一个 $1$ 的位置 $L$​ 和每一个 $1$ 左边第一个 $0$ 的位置 $R​$，那么对区间 $[l,r]$ 排序就相当于对区间 $[L​,R​]$ 排序。对于一组数据，最终的答案就是不同的 $[L,R​​]$ 的数量。</p>
</li>
<li><p>只不过就是得注意，如果一个区间的 $0$ 右边的第一个 $1$ 的位置是大于 $1$ 左边第一个 $0$ 的位置，此时说明无需排序。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    S.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)pos=i;</span><br><span class="line">        L[i]=pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos=n<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)pos=i;</span><br><span class="line">        R[i]=pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        x=R[x];</span><br><span class="line">        y=L[y];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)x=<span class="number">1</span>,y=<span class="number">1</span>;<span class="comment">//无需排序</span></span><br><span class="line">        <span class="keyword">if</span>(!S[<span class="built_in">make_pair</span>(x,y)])&#123;</span><br><span class="line">            S[<span class="built_in">make_pair</span>(x,y)]=<span class="number">1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种题就是得去发现规律，发现什么是变的什么是不变的，然后发现二者的关系。所以这种低于 $2000$ 的题得多发现规律。</p>
<p>这道题很容易发现只有 $1$ 在前 $0$ 在后才会产生新的串。</p>
</blockquote>
<h2 id="1857F-Sum-and-Product-1600-数学；水题"><a href="#1857F-Sum-and-Product-1600-数学；水题" class="headerlink" title="1857F-Sum and Product *1600 数学；水题"></a>1857F-Sum and Product <strong>*1600</strong> 数学；水题</h2><ul>
<li><p>当你看到 $a_i\times a_j=y$ 和 $a_i+a_j=x$，你肯定会想到韦达定理。</p>
</li>
<li><p>那么 $a_i,a_j$ 就是 $a^2-xa+y=0$ 的两个解。</p>
</li>
<li><p>然后根据求根公式算出答案就可以了。只不过这边要把所有数的个数放入桶中，然后从桶中取出来算方案数（组合数知识）。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],mp[w[i]]++;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> t=x*x<span class="number">-4</span>*y;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;0 &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">int</span>)<span class="built_in">sqrt</span>(t)*(<span class="type">int</span>)<span class="built_in">sqrt</span>(t)!=t)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;0 &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> p=x/<span class="number">2</span>;</span><br><span class="line">                cout&lt;&lt;(mp[p]*(mp[p]<span class="number">-1</span>)/<span class="number">2</span>)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;0 &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x1=(x-<span class="built_in">sqrt</span>(t))/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> x2=(x+<span class="built_in">sqrt</span>(t))/<span class="number">2</span>;</span><br><span class="line">        cout&lt;&lt;mp[x1]*mp[x2]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1867D-Cyclic-Operations-1800-找规律，拓扑排序"><a href="#1867D-Cyclic-Operations-1800-找规律，拓扑排序" class="headerlink" title="1867D-Cyclic Operations *1800 找规律，拓扑排序"></a>1867D-Cyclic Operations <strong>*1800</strong> 找规律，拓扑排序</h2><ul>
<li><p>根据 $a<em>{l_i}$​​ 改变为 $l</em>{(i\%k)+1}$，当 $k=1$ 时，就是：$a<em>{l_i}$​​ 改变为 $l</em>{1}$，此时就是说明 $a_1=1,a_2=2$ 这样的。</p>
</li>
<li><p>当 $k=1$ 的时候类似自环，那么此时当 $k&gt;=2$ 时，能否类比 $k=1$ 的时候呢？</p>
</li>
<li><p>发现可以的，此时把 $i\rightarrow w_i$，如果环的大小为 $k$，那么满足条件。</p>
</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/epb7iias.png" alt=""></p>
<p><a href="https://cdn.luogu.com.cn/upload/image_hosting/epb7iias.png">参考图片来源</a></p>
<ul>
<li><p>那么只要缩点，然后看缩点的联通块的大小即可。</p>
</li>
<li><p><strong>这里得注意：<code>targin</code> 是算不了自环的情况，这个得单独判断。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="function">VII <span class="title">g</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        g[i].<span class="built_in">emplace_back</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=w[i])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//注意targin无法统计自环的</span></span><br><span class="line">        <span class="keyword">if</span>(i==w[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">dfn</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">low</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> tmd=<span class="number">0</span>,top=<span class="number">0</span>,scc_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="function">VI <span class="title">scc_size</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">stk</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">in_stk</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; targin=[&amp;](<span class="type">int</span> u)&#123;</span><br><span class="line">        dfn[u]=low[u]=++tmd;</span><br><span class="line">        stk[++top]=u,in_stk[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[j])&#123;</span><br><span class="line">                <span class="built_in">targin</span>(j);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            scc_cnt++;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                y=stk[top--];</span><br><span class="line">                in_stk[y]=<span class="literal">false</span>;</span><br><span class="line">                scc_size[scc_cnt]++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">targin</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,scc_cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(scc_size[i]!=<span class="number">1</span>&amp;&amp;scc_size[i]!=k)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(scc_size[i]==k)f=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(f?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>有的时候规律都是从特殊情况类比到一般情况的。</p>
</blockquote>
<h2 id="1870D-Prefix-Purchase-1800-贪心；好题"><a href="#1870D-Prefix-Purchase-1800-贪心；好题" class="headerlink" title="1870D-Prefix Purchase *1800 贪心；好题"></a>1870D-Prefix Purchase <strong>*1800</strong> 贪心；好题</h2><ul>
<li><p>可以很容易有个贪心策略：价格越便宜的多买；尽量买越靠后的。</p>
</li>
<li><p>也就是：如果满足 $a<em>i​&gt;a</em>{i+1}$​ 的话，那么选 $i+1$ 位置一定比选 $i$ 位置更优。所以我们就可以先将 $a<em>i$​ 赋值为 $\min(a_i​,a</em>{i+1}​)$，这样就可以避免掉上面所说的这种情况了。</p>
</li>
<li><p>题目要求字典序最大，所以我们肯定要贪心的去先选前面的。但是我们会发现选完 $a_1$​ 之后 $k$ 还会剩下一些，如果直接不管的话肯定不是最优的。所以我们就可以用 $k$ 剩下的这些值去将一些选 $a_1$​ 的变成选 $a_2$​ 的，这样既可以保证当前的字典序不变（选 $1$ 的个数没变），还可以让后面的字典序变大（选 $2$ 的个数变多）。</p>
</li>
<li><p>那么就可以算出选 $a_2$​ 的数量就应该是：$(k−k÷a1​×a1​)÷(a2​−a1​)$。意思是用 $k$ 剩下的值除以每一次变化需要的代价。</p>
</li>
</ul>
<p><a href="https://www.luogu.com.cn/article/1kkd2zpq"><del>因为这道题我卡在第二步，没想出来，这里附一个参考解题</del></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">b</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">1e18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mi=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        mi=<span class="built_in">min</span>(mi,w[i]);</span><br><span class="line">        b[i]=mi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==b[i<span class="number">-1</span>])ans[i]=ans[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> ans[i]=<span class="built_in">min</span>(k/(b[i]-b[i<span class="number">-1</span>]),ans[i<span class="number">-1</span>]);</span><br><span class="line">        k-=(b[i]-b[i<span class="number">-1</span>])*ans[i];</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>卡在第二步，没有想到居然可以倒着维护最小值来解决最优解问题（意思就是<strong>价格越便宜的多买，尽量买越靠后的</strong>），这样倒着求最小值就能让价格便宜的靠后了。</p>
</blockquote>
<h2 id="1875D-Jellyfish-and-Mex-1600-dp"><a href="#1875D-Jellyfish-and-Mex-1600-dp" class="headerlink" title="1875D-Jellyfish and Mex *1600 dp"></a>1875D-Jellyfish and Mex <strong>*1600</strong> dp</h2><ul>
<li><p>看到数据规模比较小，考虑dp，特别注意是 $n$ 比较小，那么也就说 $mex$ 值不大，因此 dp 只能 dp $mex$ 值。</p>
</li>
<li><p>首先状态表示：$f_i$ 表示当前的 <strong>$mex$ 值</strong> 是 $i$ 的 $m$ 的最小值。</p>
</li>
<li><p>状态转移：$f<em>i=min(f</em>{j}+(c_i-1)*j+i)$，其中 $j&gt;i$。</p>
</li>
<li><p>答案就是 $f_0$。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],cnt[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt[mex])mex++;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(mex<span class="number">+1</span>,<span class="number">1e18</span>)</span></span>;</span><br><span class="line">    f[mex]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,mex)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[i]+(cnt[j]<span class="number">-1</span>)*i+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没想到居然是用 $mex$ 来 dp 的，服了。</p>
</blockquote>
<h2 id="1879D-Sum-of-XOR-Functions-1700-套路题；位运算"><a href="#1879D-Sum-of-XOR-Functions-1700-套路题；位运算" class="headerlink" title="1879D-Sum of XOR Functions *1700 套路题；位运算"></a>1879D-Sum of XOR Functions <strong>*1700</strong> 套路题；位运算</h2><ul>
<li>上公式：</li>
</ul>
<script type="math/tex; mode=display">\sum_{l=1}^{n}\sum_{r=l}^{n}f(l,r)\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{l=1}^{r}f(l,r)\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{l=1}^{r}\sum_{i=0}^{32} s_{l,i} \operatorname{xor} s_{r,i}\times 2^i\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{i=0}^{32} \sum_{l=1}^{r}[ s_{r,i}\operatorname{xor}s_{l,i} =1]\times 2^i\times(r-l+1)</script><script type="math/tex; mode=display">=\sum_{r=1}^{n}\sum_{i=0}^{32} 2^i\times\sum_{l=1}^{r}[ s_{r,i}\operatorname{xor}s_{l,i} =1]\times r-[ s_{r,i}\operatorname{xor}s_{l,i} =1] \times (l-1)</script><ul>
<li><p>此时把 $r$ 当作变量，后面的 $\sum<em>{l=1}^{r}[ s</em>{r,i}\operatorname{xor}s<em>{l,i} =1]\times r-[ s</em>{r,i}\operatorname{xor}s_{l,i} =1] \times (l-1)$ 可以直接算出来的，给它一个含义：前缀中与 $s_r$ 值相反的数的个数。</p>
</li>
<li><p>注意这里是 $l-1$，因此它的增幅会慢一拍。</p>
</li>
<li><p>在代码中体现就是: <code>cnt[i][j]</code>是中括号满足条件的，<code>sum[i][j]</code> 就是 $l-1$ 那一项的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]^w[i];</span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">0</span>,<span class="number">32</span>)&#123;</span><br><span class="line">            sep[i][j]=((s[i]&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">32</span>)cnt[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//固定r</span></span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">0</span>,<span class="number">32</span>)&#123;<span class="comment">//sep[i][j]^1就是与当前不同的前缀，这样能满足</span></span><br><span class="line">            ans=(ans+(cnt[j][sep[i][j]^<span class="number">1</span>]*i%mod-sum[j][sep[i][j]^<span class="number">1</span>]%mod<span class="number">+2</span>*mod)*(<span class="number">1</span>&lt;&lt;j))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORD</span>(j,<span class="number">0</span>,<span class="number">32</span>)&#123;<span class="comment">//r扩展，个数也得扩展,因为是l-1,所以会慢一拍</span></span><br><span class="line">            sum[j][sep[i][j]]+=i;</span><br><span class="line">            cnt[j][sep[i][j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>公式推导牢记。</p>
</blockquote>
<h2 id="1889B-Doremy’s-Connecting-Plan-1700-排序，思维"><a href="#1889B-Doremy’s-Connecting-Plan-1700-排序，思维" class="headerlink" title="1889B-Doremy’s Connecting Plan *1700 排序，思维"></a>1889B-Doremy’s Connecting Plan <strong>*1700</strong> 排序，思维</h2><ul>
<li><p>要求 $\sum_{k \in S}a_k \ge i \cdot j\cdot c$ ，此时公式里面有三个变量，不好搞，此时就让 $i=1$，这样就能优化掉一个变量。</p>
</li>
<li><p>为什么选 $1$ 可以呢？</p>
</li>
</ul>
<p>证明：假设它们都不能和 1 连边，那么：</p>
<script type="math/tex; mode=display">\begin{aligned}
a_i + a_j \ge i \cdot j\cdot c \\
a_i + a_1 < i \cdot c \\
a_j + a_1 < j \cdot c
\end{aligned}</script><p>后两行相加与第一行比较，又由于 $a_1​≥0$，得出：</p>
<script type="math/tex; mode=display">(i + j) \cdot c \gt i\cdot j \cdot c</script><script type="math/tex; mode=display">i + j \gt i\cdot j</script><p>那么显然这个式子是矛盾的，因此必须跟 $1$ 相连。</p>
<ul>
<li>那么只需要考虑和 $1$ 连边的情况了，此时只需要算：$a_i - i \cdot c$ 即可。此时就按这个从大到小排序，只要 $sum+a_i&lt;i\cdot c$ 就输出 <code>NO</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; a,<span class="type">const</span> E&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x-c*a.y&gt;b.x-c*b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i].x,w[i].y=i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+2</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=w[<span class="number">1</span>].x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum+w[i].x&lt;w[i].y*c)&#123;</span><br><span class="line">            No;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=w[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    Yes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当出现多个变量，可以考虑去掉一个变量的方法去做。</p>
</blockquote>
<h2 id="1923D-Slimes-1800-二分；细节题"><a href="#1923D-Slimes-1800-二分；细节题" class="headerlink" title="1923D-Slimes *1800 二分；细节题"></a>1923D-Slimes <strong>*1800</strong> 二分；细节题</h2><ul>
<li><p>看某个点是否能被史莱姆吃掉，就看它前面或者后面是否能累加起来（必须只有严格大的才能累加）比当前大，因此这里可以用二分来判断存不存在以及最小值。</p>
</li>
<li><p>由于题目说一个史莱姆只能在严格大于其邻居的情况下吃掉该邻居，因此我这里处理相等情况以及前缀和。</p>
</li>
<li><p>然后就是愉快的二分过程了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],pre[i]=pre[i<span class="number">-1</span>]+w[i],c[i]=c[i<span class="number">-1</span>]+<span class="built_in">abs</span>(w[i]-w[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>((w[i<span class="number">-1</span>]&gt;w[i]&amp;&amp;i&gt;<span class="number">1</span>)||(w[i<span class="number">+1</span>]&gt;w[i]&amp;&amp;i&lt;n))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;1 &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&amp;&amp;pre[i<span class="number">-1</span>]&gt;w[i])&#123;</span><br><span class="line">            l=<span class="number">0</span>,r=i;</span><br><span class="line">            <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre[i<span class="number">-1</span>]-pre[mid<span class="number">-1</span>]&lt;=w[i]||(c[i<span class="number">-1</span>]-c[mid]==<span class="number">0</span>&amp;&amp;i<span class="number">-1</span>!=mid))r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,i-l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i-n&amp;&amp;pre[n]-pre[i]&gt;w[i])&#123;</span><br><span class="line">            l=i,r=n<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre[mid]-pre[i]&lt;=w[i]||(c[mid]-c[i<span class="number">+1</span>]==<span class="number">0</span>&amp;&amp;i<span class="number">+1</span>!=mid))l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r!=n<span class="number">+1</span>)&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,r-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;(ans==<span class="number">1e18</span>?<span class="number">-1</span>:ans)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二分思路其实很简单的，因为你要找最小值，那么此时二分一个答案，看看能不能满足，不能满足就继续二分，具备二段性和单调性。</p>
<p>但这道题的细节特别多，一不小心就错了。</p>
</blockquote>
<h2 id="1934C-Find-a-Mine-1700-猜答案"><a href="#1934C-Find-a-Mine-1700-猜答案" class="headerlink" title="1934C-Find a Mine *1700 猜答案"></a>1934C-Find a Mine <strong>*1700</strong> 猜答案</h2><ul>
<li><p>因为只有 $4$ 次查询机会，保证网格中恰好有 $2$ 个地雷。还可以发现对于一个地雷，它产生的最小曼哈顿距离在同一个对角线上都是相同的。</p>
</li>
<li><p>第一次查询：可以先查询 $(1,1)$ 这个点，把距离记为 $d_1$。</p>
</li>
<li><p>第二次查询和第三次查询：根据 $d_1$ 的值跟 $n$ 和 $m$ 进行比较，进而将坐标推进到对角线上。</p>
</li>
<li><p>第四次查询：现在已经查找到了对角线的两个端点 $(x_1,y_1)$ 和 $(x_2,y_2)$，此时根据 $d_2$ 和 $d_3$ 定位到一个地雷的位置，如果这个位置得到的 $d_4$ 是 $0$ 的话，那么就是答案了。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/chunyou_/article/details/136593611">图</a>：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/74a342d23c7cb4bfb36407435f5ae6bc.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? 1 1&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;d[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(d[<span class="number">0</span>]&lt;n)&#123;</span><br><span class="line">        x1=d[<span class="number">0</span>]<span class="number">+1</span>,y1=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x1=n,y1=d[<span class="number">0</span>]<span class="number">+2</span>-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[<span class="number">0</span>]&lt;m)x2=<span class="number">1</span>,y2=d[<span class="number">0</span>]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">else</span> x2=d[<span class="number">0</span>]<span class="number">+2</span>-m,y2=m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;d[<span class="number">1</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x2&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;d[<span class="number">2</span>];</span><br><span class="line">    d[<span class="number">1</span>]/=<span class="number">2</span>,d[<span class="number">2</span>]/=<span class="number">2</span>;</span><br><span class="line">    x1-=d[<span class="number">1</span>],y1+=d[<span class="number">1</span>];</span><br><span class="line">    x2+=d[<span class="number">2</span>],y2-=d[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;d[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(!d[<span class="number">3</span>])cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;x1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;x2&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>卡在：已经知道第一次查询，然后也知道扩展坐标到对角线的端点，但我无法确定第二次查询和第三次查询该如何操作。</p>
</blockquote>
<hr>
<p>又结束咯，题目不在于多，而在于精。</p>
<hr>
<p>这个后期改为好题归类，因为计划变更为：每天得VP一场古老cf。相信自己能变得越来越强吧</p>
<hr>
<h1 id="2-17-3-4"><a href="#2-17-3-4" class="headerlink" title="2.17-3.4"></a>2.17-3.4</h1><p>已经好久都没有更新了，这次准备大更新。</p>
<h2 id="580B-Kefa-and-Company-1500-尺取法"><a href="#580B-Kefa-and-Company-1500-尺取法" class="headerlink" title="580B-Kefa and Company *1500 尺取法"></a>580B-Kefa and Company <strong>*1500</strong> 尺取法</h2><ul>
<li><p>题意：给定 $n$ 个人的金额和友谊因素，当选的人的钱 $&lt;d$ 的情况下，那么可以选他，问最后选的人的最大总友谊因素和。</p>
</li>
<li><p>思路：因为题目判定是否为朋友的条件是钱 $&lt;d$，那么我们可以先对钱进行排序，然后我们采用 <strong>尺取法</strong>，在尺子内的朋友都是满足条件的，我们求一下它们的友谊因素和，取个最大值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].a&gt;&gt;w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w+n<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+w[i].b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(l,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=n&amp;&amp;w[r].a-w[l].a&lt;m)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="616D-Longest-k-Good-Segment-1600-尺取法"><a href="#616D-Longest-k-Good-Segment-1600-尺取法" class="headerlink" title="616D-Longest k-Good Segment *1600 尺取法"></a>616D-Longest k-Good Segment <strong>*1600</strong> 尺取法</h2><ul>
<li><p>题意：给定一个包含 $n$ 个整数的数组 $a$。我们将数组中一个或多个连续元素的序列称为 $a$ 的 段。同时，如果一个段包含的不同值不超过 $k$ 个，则称该段为 $k-好$。找到任意最长的 $k-好$段。</p>
</li>
<li><p>思路：对于这种找到某一段的xxx性质，此时都得考虑尺取法。它说什么不同元素的，此时这个可以用桶来做。此后，就是尺子内的元素都满足有 $k$ 个不同的元素。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,len;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len&gt;t.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;E&gt;ans;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(l,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;n&amp;&amp;S.sz&lt;=k)&#123;</span><br><span class="line">            S[w[++r]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S.sz&lt;=k<span class="number">+1</span>&amp;&amp;r&lt;n)&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(&#123;l,r<span class="number">-1</span>,r-l&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r==n&amp;&amp;S.sz&lt;=k)&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(&#123;l,r,r-l<span class="number">+1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--S[w[l]]==<span class="number">0</span>)&#123;</span><br><span class="line">            S.<span class="built_in">erase</span>(w[l]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(ans));</span><br><span class="line">    cout&lt;&lt;ans[<span class="number">0</span>].l&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans[<span class="number">0</span>].r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="702C-Cellular-Network-1500-二分-尺取法"><a href="#702C-Cellular-Network-1500-二分-尺取法" class="headerlink" title="702C-Cellular Network *1500 二分+尺取法"></a>702C-Cellular Network <strong>*1500</strong> 二分+尺取法</h2><ul>
<li><p>题意：给定一条直线上的 $n$ 个村庄和 $m$ 个基站，现在要找出最小的 $r$，使得每个城市都被移动通信网络覆盖。</p>
</li>
<li><p>思路：我们发现这道题有二段性，就是当 $r$ 比较小肯定不满足，$r$ 比较大肯定满足，此时就会有一个分界线，因此满足二分答案条件。那么现在已知 $r$，要看是否能覆盖所有村庄，此时我们可以用尺取法把能覆盖的村庄都标记一下，然后最后遍历所有村庄看哪些村庄没有被标记。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="function">VI <span class="title">vis</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=m&amp;&amp;<span class="built_in">abs</span>(a[i]-b[j])&gt;x)j++;</span><br><span class="line">        <span class="keyword">if</span>(j==m<span class="number">+1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i]-b[j])&lt;=x)vis[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">-1</span>,r=<span class="number">1e12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l<span class="number">+1</span>!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尺取法用处：解决连续段满足特定性质的个数、起始下标等。</p>
</blockquote>
<h2 id="1995C-Squaring-1800-贪心"><a href="#1995C-Squaring-1800-贪心" class="headerlink" title="1995C-Squaring *1800 贪心"></a>1995C-Squaring <strong>*1800</strong> 贪心</h2><ul>
<li>题意：给你一个大小为 $n$ 的数组，你每次可以把数组中的数 $a_i$ 改成 $a_i^2$，问最小的操作次数使得数列非递减。</li>
<li>思路：我们可以先考虑最简单的情况，那就是当 $a<em>i=1$ 的情况，因为 $1$ 不管怎么平方都是等于 $1$，如果 $1$ 在中间那就很不好说了，此时就无解；现在考虑一般情况，如果 $a</em>{i-1}&gt;a<em>i$，那么此时我们就可以把 $a_i$ 一直平方直到它彻底比 $a</em>{i-1}$ 大，此时为了避免每一次都计算，我们可以考虑用dp，也就是设：第 $i$ 个数操作次数为 $f[i]$。然后只需要比较相邻的数就行，因为如果本来这个数就是单调递增的话，此时就不会被算进去了，此时就可以节省计算量。但这里要注意的是：比如 <code>16 2 4 2</code>，这种，因为 <code>16 2</code> 是递减的，因此我们要让不递减的话，就让 <code>2</code> 操作 $3$ 次即可，然后就开始处理 <code>2 4</code>，我们发现这两个数本来就是单调递增的，此时我们直接延用上一次操作，但直接沿用上一次操作可能会出现的问题就是会平方过头了，所以我们要开根号来避免这种情况。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> now=w[i],cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(now&lt;w[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(now==<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(now&lt;w[i<span class="number">-1</span>])&#123;</span><br><span class="line">                now=now*now;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>((w[i<span class="number">-1</span>]==<span class="number">1</span>)&amp;&amp;<span class="built_in">sqrt</span>(now)&gt;w[i<span class="number">-1</span>]||(w[i<span class="number">-1</span>]!=<span class="number">1</span>&amp;&amp;<span class="built_in">sqrt</span>(now)&gt;=w[i<span class="number">-1</span>]))&#123;</span><br><span class="line">                now=<span class="built_in">sqrt</span>(now);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(&#123;f[i],(<span class="type">int</span>)<span class="number">0</span>,f[i<span class="number">-1</span>]+cnt&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)ans+=f[i];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了避免重复计算，我们可以考虑沿用上一次操作（类似相对值的操作）</p>
</blockquote>
<h2 id="2006C-Action-Figures-1500-思维"><a href="#2006C-Action-Figures-1500-思维" class="headerlink" title="2006C-Action Figures *1500 思维"></a>2006C-Action Figures <strong>*1500</strong> 思维</h2><ul>
<li>题意：给定一个人每天的出行情况，$1$ 表示去商场购物，$0$ 表示没有。如果他在用一天买了两个以上的玩具，那么他可以免费获得他购买的最贵的玩偶（玩具的价钱和天数 $i$ 有关，且他只能买前 $i$ 天的玩具）。问它买所有玩具需要的最少花费。</li>
<li>思路：我们可以发现，我们如果在有 $1$ 的那天出门，此时我们买的都是之前 $0$ 的那几天的玩具。因此我们可以倒叙遍历，把 $1$ 对应的下标都存下来，然后到 $0$ 的时候拿出来，这样也就相当于有 $1$ 的时候我们就买它前面 $0$ 的玩具，注意是尽可能的买，当出现 <code>10001</code> 这样的情况，我们就是得把前面的 <code>0</code> 全部买了。如果我们的 $1$ 有剩的话，我们就搭配最小的和最大的买即可（也就是比如第 $1$ 个和第 $n$ 个买）。这里可以用栈或者堆来维护。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.sz)q.<span class="built_in">pop_front</span>();</span><br><span class="line">            ans+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.sz)&#123;</span><br><span class="line">        ans+=q.<span class="built_in">back</span>();</span><br><span class="line">        q.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(q.sz==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>一下是被1200的题虐的现场，也不知道怎么回事，我居然1200的题会卡半天。</p>
<h2 id="1979C-Earning-on-Bets-1200-数学、构造"><a href="#1979C-Earning-on-Bets-1200-数学、构造" class="headerlink" title="1979C-Earning on Bets *1200 数学、构造"></a>1979C-Earning on Bets <strong>*1200</strong> 数学、构造</h2><ul>
<li><p>题意：有一种游戏，在这种游戏中，有 $n$ 种可能的结果，对于每一种结果，如果获胜的话，将会得到你在该结果上押注的硬币数量乘以 $k_i$ 的硬币数。你的任务是合理分配好硬币，以便在任何获胜的结果发生时都能获利，获胜的条件是：你在所有结果上押注的硬币总数必须小于每个可能获胜结果所获得的硬币数。求每次押注的硬币。</p>
</li>
<li><p>思路：题目也就是要构造一个数组 $b<em>i$，使得 $a_ib_i&gt;\sum</em>{j=1}^{n}b_j$。我们此时发现，只要 $a_ib_i$ 都相等时最优。那怎样让它们相等，此时就是算 $a_i$ 的 $lcm$（最小公倍数），但数不能超过 $20$，因为超过 $20$ 的 lcm 就飞天了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y/__gcd(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">20</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">lcm</span>(w[<span class="number">1</span>],w[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">3</span>,n)&#123;</span><br><span class="line">        t=<span class="built_in">lcm</span>(t,w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans+=t/w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=t)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;t/w[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我靠，我居然被1200的题干成这样，服了。</p>
</blockquote>
<h2 id="1954C-Long-Multiplication-1200-数学"><a href="#1954C-Long-Multiplication-1200-数学" class="headerlink" title="1954C-Long Multiplication *1200 数学"></a>1954C-Long Multiplication <strong>*1200</strong> 数学</h2><ul>
<li><p>题意：给定长度相同的数字 $x,y$，数字由 $0$ 到 $9$ 组成，你可以进行以下操作任意次：交换 $x$ 中的第 $i$ 位数字和 $y$ 中的第 $i$ 位数字，最后使得它们的乘积最大。</p>
</li>
<li><p>思路：我们可以知道，当两个数的差值越小，它们的乘积越大。因为长度最长也就 $100$，那么我们可以贪心的枚举每一位，然后交换之后看看差值会不会变小。具体来说的话就是：如果 $s&gt;t$ 并且 $s_i&gt;t_i$，此时交换更优。 </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=s.sz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(s&gt;t&amp;&amp;s[i]&gt;t[i])<span class="built_in">swap</span>(s[i],t[i]); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s&lt;t&amp;&amp;s[i]&lt;t[i])<span class="built_in">swap</span>(s[i],t[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;t)<span class="built_in">swap</span>(s,t);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1990C-Mad-MAD-Sum-1500-找规律"><a href="#1990C-Mad-MAD-Sum-1500-找规律" class="headerlink" title="1990C-Mad MAD Sum *1500 找规律"></a>1990C-Mad MAD Sum <strong>*1500</strong> 找规律</h2><ul>
<li><p>题意：给出一个初始数组。重复同时将数组的每一位变为从数组到此为止出现至少两次的数中最大者，直到数组元素全为 $0$。求该过程中每一步得到的数组（包括初始数组）元素和。</p>
</li>
<li><p>思路：我们可以把每一步列出来，我们会发现它有规律：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>9</td>
<td>1</td>
<td>9</td>
<td>8</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p>然后我们计算的时候注意，这样算更方便：对角线 <code>\</code> 类似这种线来算。还有就是得注意：得操作一次之后才会有这种性质。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],ans+=w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)a[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;P;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(P.<span class="built_in">count</span>(w[i]))&#123;</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        a[i]=mx;</span><br><span class="line">        P.<span class="built_in">insert</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)ans+=a[i];</span><br><span class="line">    <span class="built_in">fill</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n,<span class="number">0</span>);</span><br><span class="line">    mx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(P.<span class="built_in">count</span>(a[i]))&#123;</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        w[i]=mx;</span><br><span class="line">        P.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)ans+=w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)ans+=(n-i)*w[i];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1806C-Sequence-Master-1600-打表"><a href="#1806C-Sequence-Master-1600-打表" class="headerlink" title="1806C-Sequence Master *1600 打表"></a>1806C-Sequence Master <strong>*1600</strong> 打表</h2><ul>
<li><p>题意：给定长为 $2n$ 的数组 $p$，你需要构造一个长度为 $2n$ 的数组 $q$，满足 $ S \subseteq U $ 且 $ |S|=m $，$ \prod\limits<em>{i \in S} q_i = \sum\limits</em>{i \in U \setminus S} q<em>i $。<br>且你构造的 $q$ 数组需要让 $ans = \sum\limits</em>{i=1}^k|a_i-b_i| $ 最小，输出这个 $ans$。</p>
</li>
<li><p>思路： 不难构造一个全零数组 $q$，即可满足题目要求。<br>接下来观察样例，由第一组样例发现 $n=1$ 时容易构造 $q={q_1,q_1}$，即可使答案最小。<br>由第二组样例发现 $n=2$ 时可以构造 $q={2,2,2,2}$，可能可以使答案最小。<br>第三组样例发现很难找出什么性质，甚至无法手玩出样例，此时尝试写一个爆搜程序暴力枚举 $q$ 数组，观察样例输出 $5$，$p={-2,-2,2,2}$，所以我们可以尝试将 $p$ 数组的每个元素都加上 $-5 \sim 5$ 来尝试得到 $q$ 数组，当枚举出一个 $q$ 数组时就更新一下答案。<br>发现最后得到的 $q={-1,-1,-1,2}$，尝试将 $n$ 推广到更大，发现当 $n$ 为偶数时可以构造出 $q={-1,-1,……,-1,n}$，而 $n$ 为奇数时则无法构造。<br>最后观察第四组样例，进一步确认了 $q={-1,-1,……,-1,n}$ 的正确性。<br>分讨一下 $n \le 2$ 的情况和 $n$ 的奇偶即可。<a href="https://www.luogu.com.cn/article/gvdude8h">思路引用</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n*<span class="number">2</span>)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span><span class="number">+2</span>*n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;w[<span class="number">2</span>]-w[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">            sum+=<span class="built_in">abs</span>(w[i]<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">2</span>*n<span class="number">-1</span>)&#123;</span><br><span class="line">            sum+=<span class="built_in">abs</span>(<span class="number">-1</span>-w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=<span class="built_in">abs</span>(n-w[n*<span class="number">2</span>]);</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">        sum+=<span class="built_in">abs</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1903C-Theofanis’-Nightmare-1400-前缀和"><a href="#1903C-Theofanis’-Nightmare-1400-前缀和" class="headerlink" title="1903C-Theofanis’ Nightmare *1400 前缀和"></a>1903C-Theofanis’ Nightmare <strong>*1400</strong> 前缀和</h2><ul>
<li>题意：给你一个数组，现在要求你构造一种分发，把数组分成 $k$ 份，使得 $\sum_{i=1}^{k}i\times sum_i$ 最大，求出这个的最大值。</li>
<li>思路：我们有个很明显的思路就是，按照后缀只要一旦大于 $0$ 的，我们就分割，这样肯定是最优的，因为不是大于 $0$ 的分，那么 $sum_i&lt;0$，此时就会使得答案变小。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">suf</span><span class="params">(n<span class="number">+2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        suf[i]=suf[i<span class="number">+1</span>]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    VI p;</span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(suf[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            p.<span class="built_in">pb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p.sz||p.<span class="built_in">back</span>()!=<span class="number">1</span>)&#123;</span><br><span class="line">        p.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pp=p.sz;</span><br><span class="line">    <span class="type">int</span> lst=n<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:p)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">        ans+=pp*(suf[x]-suf[lst]);</span><br><span class="line">        lst=x;</span><br><span class="line">        pp--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1909C-Heavy-Intervals-1400-贪心"><a href="#1909C-Heavy-Intervals-1400-贪心" class="headerlink" title="1909C-Heavy Intervals *1400 贪心"></a>1909C-Heavy Intervals <strong>*1400</strong> 贪心</h2><ul>
<li>题意：给定了长度为 $n$ 的三个序列 $l,r,c$，保证 $l<em>i&lt;r_i$，并且 ${l_1,l_2,l_3,…,l_n,r_1,r_2,…,r_n}$。你需要重新排列这三个序列，排完序依然保证 $l_i&lt;r_i$。但是你需要最小化 $∑</em>{i=1}^{n}(r_i−l_i)×c_i$ 的值。</li>
<li>思路：因为你要最小化这个值，因此我们可以考虑从小到大排序，然后固定 $r_i$ 来找所有满足 $r_i&gt;l_i$ 的 $l_i$，此时如果长度比较长的话，我们就分配小的 $c_i$ 即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;l[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;r[i];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(l<span class="number">+1</span>,l<span class="number">+1</span>+n),<span class="built_in">sort</span>(r<span class="number">+1</span>,r<span class="number">+1</span>+n),<span class="built_in">sort</span>(c<span class="number">+1</span>,c<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r[i]&gt;l[j]&amp;&amp;j&lt;=n)&#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=r[i]-l[stk.<span class="built_in">top</span>()];</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>()<span class="number">+1</span>,ans.<span class="built_in">end</span>(),<span class="built_in">GI</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        res+=(ans[i]*c[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1916C-Training-Before-the-Olympiad-1200-数学-思维"><a href="#1916C-Training-Before-the-Olympiad-1200-数学-思维" class="headerlink" title="1916C-Training Before the Olympiad *1200 数学+思维"></a>1916C-Training Before the Olympiad <strong>*1200</strong> 数学+思维</h2><ul>
<li>题意：有一个正整数序列 $a$，两人进行游戏，规则如下：</li>
</ul>
<ol>
<li>当序列中只有一个元素时，游戏结束。</li>
<li>否则，两人交替操作，每次需要选出 $a$ 中的两个元素 $a_i,a_j(i\ne j)$，将它们删除并插入一个值为 $\lfloor\frac{a_i+a_j}{2}\rfloor\cdot 2$ 的元素。</li>
</ol>
<ul>
<li><p>先手希望使得最终 $a$ 中留下的数最大化，后手希望最小化，两人都按最优策略进行游戏，求对于给定的长为 $n$ 的序列 $a$ 的每个非空前缀，对该前缀进行游戏的结果，即最后留下的数。每个测试点 $t$ 组测试用例。</p>
</li>
<li><p>思路：我们发现，对于这种下取整，如果分母是奇数的话，那么除 $2$ 下取整再乘 $2$ 得到的结果就会比之前少 $1$。那么根据这个特性，我们就可以很容易按照如下方式构造：因为如果先手要获胜的话，它肯定是最好取两个偶数出来，很明显是吧。然后后手肯定是把偶数都变成奇数更好，所以对于一轮回合来说，就是偶数最好是被取 $3$ 个 $3$ 个的。因为你模三肯定会有剩余的数，所以如果余 $1$ 的话，此时这个数不管被先手拿还是后手拿这个数必然 $-1$。然后题目问每一次操作，那么我们可以用前缀和来维护前缀中的奇数的个数和偶数的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">pre</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">pt</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&amp;<span class="number">1</span>)pre[i]=pre[i<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> pre[i]=pre[i<span class="number">-1</span>];</span><br><span class="line">        pt[i]=pt[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)cout&lt;&lt;w[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t=pre[i];</span><br><span class="line">            <span class="type">int</span> p=t/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(t%<span class="number">3</span>==<span class="number">1</span>)p++;</span><br><span class="line">            cout&lt;&lt;pt[i]-p&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>认真分析题目性质得到：必须得奇偶分析。</p>
</blockquote>
<h2 id="1923C-Find-B-1400"><a href="#1923C-Find-B-1400" class="headerlink" title="1923C-Find B *1400"></a>1923C-Find B <strong>*1400</strong></h2><ul>
<li>题意：给你一个数组，再给你 $q$ 次查询，判断这个子数组是不是好的，如果是好的必须满足：它能构造出一个长度跟自身相同且构造数组的和跟原数组的和相同并且对于同一个位置的元素值不同。</li>
<li>思路：因为题目说两个要是好的当且仅当和是相同的，因此我们可以用前缀和来维护区间的和，然后我们可以这样构造：如果区间中某个数不是 $1$ 的话，我们就分配 $1$，如果是的话，我们就平均分配不是 $1$ 的个数。这样构造是最优的。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">pre</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">pre2</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+w[i]<span class="number">-1</span>;</span><br><span class="line">        pre2[i]=pre2[i<span class="number">-1</span>]+(w[i]==<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            NO;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[r]-pre[l<span class="number">-1</span>]&lt;pre2[r]-pre2[l<span class="number">-1</span>])&#123;</span><br><span class="line">                NO;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1933D-Turtle-Tenacity-Continual-Mods-1200-思维"><a href="#1933D-Turtle-Tenacity-Continual-Mods-1200-思维" class="headerlink" title="1933D-Turtle Tenacity: Continual Mods *1200 思维"></a>1933D-Turtle Tenacity: Continual Mods <strong>*1200</strong> 思维</h2><ul>
<li>题意：给定一个数组 $a$，问是否存在一种把 $a$ 数组排列的方案数组 $b$，使得 $b$ 所有的元素模数不等于零。</li>
<li>思路：我们首先考虑特殊情况：所有数都相同，那么此时肯定是NO。我们发现，如果我们从小到大排序数组的话，此时是更优秀的，因为假如没有重复的数的情况下，比如说 <code>1 2 3 4 5</code>，那么最终答案就是 <code>1</code>。所以我们就把数组从小到大排序，此时我们又发现如果 $a_1\not= a_2$ 的情况下，最后答案肯定不为 $0$。反之，如果比如这种情况 <code>2 2 3</code>，此时如果不调整顺序的话，那么它的值是零。但如果我们把 <code>3</code> 放在 <code>2</code> 的前面就可以了。因此对于这种情况的话，就是去找 $a_i \% a_1 \not= 0$ 的就行了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[w[<span class="number">1</span>]]==n)&#123;</span><br><span class="line">        NO;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[<span class="number">1</span>]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        NO;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w+n<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(w[<span class="number">1</span>]!=w[<span class="number">2</span>])&#123;</span><br><span class="line">        YES;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]%w[<span class="number">1</span>])&#123;</span><br><span class="line">            YES;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>思维题得慢慢积淀。</p>
</blockquote>
<h2 id="1935B-Informatics-in-MAC-1200-思维"><a href="#1935B-Informatics-in-MAC-1200-思维" class="headerlink" title="1935B-Informatics in MAC *1200 思维"></a>1935B-Informatics in MAC <strong>*1200</strong> 思维</h2><ul>
<li>题意：给定一个长度为 $n$ 的数组 $a$，你要把它分成 $k&gt;1$ 段，此时每一段的 MEX 值都相同，求出此时的 MEX 值和方案。</li>
<li>思路：根据 MEX 的性质，因为要分成至少两段，那么我们一般采取的策略就是分成两段。那么此时就得分类讨论了。如果数组中没有 $0$，那就随便分，如果存在一个零，则无解，如果存在两个以上的零，此时我们就得维护前缀 MEX 值和后缀 MEX 的值，当它们相等的时候就记录下来此时的分界线即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!S[<span class="number">0</span>]&amp;&amp;n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;1 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;2 &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">pre</span><span class="params">(n<span class="number">+2</span>,<span class="number">0</span>)</span>,<span class="title">suf</span><span class="params">(n<span class="number">+2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;P;</span><br><span class="line">    <span class="type">int</span> mex1=<span class="number">0</span>,mex2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        P.<span class="built_in">insert</span>(w[i]);</span><br><span class="line">        <span class="keyword">while</span>(P.<span class="built_in">count</span>(mex1))mex1++;</span><br><span class="line">        pre[i]=mex1;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        P.<span class="built_in">insert</span>(w[i]);</span><br><span class="line">        <span class="keyword">while</span>(P.<span class="built_in">count</span>(mex2))mex2++;</span><br><span class="line">        suf[i]=mex2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[i]==suf[i<span class="number">+1</span>])&#123;</span><br><span class="line">            id=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(id==n)&#123;</span><br><span class="line">            cout&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;id<span class="number">+1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1990B-Array-Craft-1200-思维"><a href="#1990B-Array-Craft-1200-思维" class="headerlink" title="1990B-Array Craft *1200 思维"></a>1990B-Array Craft <strong>*1200</strong> 思维</h2><ul>
<li>题意：构造一个数组（元素只包含 $-1$ 和 $1$）满足它的前缀和等于前缀和的最大值的最小索引，后缀和等于后缀和的最大值的最大索引，并且这个最大值是给了你的。</li>
<li>思路：一个初步的想法就是在前缀的最小索引的后面全部变成 <code>-1</code>，然后后缀的前面全部变成 <code>-1</code>。但这个只是想到了一半，因为如果是这样的 <code>5 4 3</code>，如果按照我们之前的想法答案就是 <code>-1 -1 -1 1 -1</code>，那么 <code>x=1</code>，它就不会等于 <code>4</code> 了。所以我们想到了交替的来，就是构造成这样 <code>-1 1 -1 1 -1</code>，也就是 <code>-1</code> 和 <code>1</code> 交替进行。<del>这样就能理解出题人为什么 $y&lt;x$ 了。</del><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(<span class="built_in">ALL</span>(ans),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,x<span class="number">+1</span>,n)&#123;</span><br><span class="line">        ans[i]=ans[i<span class="number">-1</span>]*<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,y<span class="number">-1</span>)&#123;</span><br><span class="line">        ans[i]=ans[i<span class="number">+1</span>]*<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>有的结论很不好猜，比如这道题你肯定一开始就觉得是从x+1到n都是-1，y-1到1都是-1。</p>
</blockquote>
<h2 id="2013C-Password-Cracking-1400-交互题"><a href="#2013C-Password-Cracking-1400-交互题" class="headerlink" title="2013C-Password Cracking *1400 交互题"></a>2013C-Password Cracking <strong>*1400</strong> 交互题</h2><ul>
<li>题意：猜二进制密码，最多有 $2n$ 次操作，当我们询问一个字符串，它能返回当前字符串是不是答案字符串的子串。</li>
<li>思路：题目说最多有 $2n$ 次操作，说明此时我们可以按每次添位数来询问，就是假设当前字符串是 $s$，我们可以在 $s$ 的前面放 $0$ 或者 $1$，或者在它的后面放 $0$ 或者 $1$，这里最多询问 $2$ 次。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    cin&gt;&gt;res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="built_in">query</span>(s+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">1</span>)s+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t=<span class="built_in">query</span>(s+<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(t)&#123;</span><br><span class="line">                    s+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    f=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="built_in">query</span>(<span class="string">&#x27;0&#x27;</span>+s);</span><br><span class="line">            <span class="keyword">if</span>(t)s=<span class="string">&#x27;0&#x27;</span>+s;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s=<span class="string">&#x27;1&#x27;</span>+s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.sz==n)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>很多交互题都是看询问次数来确定怎么去猜答案。</p>
</blockquote>
<h2 id="2064B-Variety-is-Discouraged-1100-思维"><a href="#2064B-Variety-is-Discouraged-1100-思维" class="headerlink" title="2064B-Variety is Discouraged *1100 思维"></a>2064B-Variety is Discouraged <strong>*1100</strong> 思维</h2><ul>
<li>题意：定义数组 $b$ 的贡献为 $b$ 中元素个数减去 $b$ 中不同元素的数量。空数组贡献为 $0$。给出一个数组 $a$。拥有<strong>一次</strong>对其操作的机会，删除 $a$ 的一个子段。即选择两个整数 $l$ 和 $r$，其中 $1 \le l \le r \le n$，删除连续的子数组 $[a_l,\ldots,a_r]$。也可以不进行操作。如果有多个答案，则输出贡献最大的<strong>操作</strong>。请最小化 $a$ 的贡献。如果还是有多个答案，输出其中的任何一个。</li>
<li>思路：我们发现如果我们删除数组中只出现一次的数，那么此时删掉这个数，答案是不会变化的。如果删除重复的数，此时我们答案会减少 $1$。因此这道题也就是去找出现一次的最长的连续字串的长度。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">b</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)b[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(b[w[<span class="number">1</span>]]==n&amp;&amp;n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[w[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(j<span class="number">+1</span>&lt;=n&amp;&amp;b[w[j<span class="number">+1</span>]]==<span class="number">1</span>)j++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j-i<span class="number">+1</span>&gt;ans)&#123;</span><br><span class="line">                ans=j-i<span class="number">+1</span>;</span><br><span class="line">                l=i,r=j;</span><br><span class="line">            &#125;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!ans)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>我怎么感觉 <strong>1600</strong> 以下的题都是要善于转化的题（思维题）</p>
</blockquote>
<h2 id="2064C-Remove-the-Ends-1300-思维"><a href="#2064C-Remove-the-Ends-1300-思维" class="headerlink" title="2064C-Remove the Ends *1300 思维"></a>2064C-Remove the Ends <strong>*1300</strong> 思维</h2><ul>
<li>题意：给你一个硬币序列，如果 $a_i&lt;0$，此时获得当前硬币的数量然后把数组后缀删除，反之删除前缀，问在过程结束时你可以拥有的最大硬币数。</li>
<li>思路：我们发现，如果 $a_i&lt;0$ 就是删除后缀，反之删除前缀，那么也就是说，我们此时可以维护所有小于零的后缀，然后再维护所有大于零的前缀，然后枚举在某个点结束即可。（可能讲的不清楚，可以看看代码）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">pre</span><span class="params">(n+n,<span class="number">0</span>)</span>,<span class="title">suf</span><span class="params">(n+n,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)<span class="keyword">if</span>(w[i]&gt;<span class="number">0</span>)pre[i]=pre[i<span class="number">-1</span>]+w[i];<span class="keyword">else</span> pre[i]=pre[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)<span class="keyword">if</span>(w[i]&lt;<span class="number">0</span>)suf[i]=suf[i<span class="number">+1</span>]+w[i];<span class="keyword">else</span> suf[i]=suf[i<span class="number">+1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">abs</span>(w[<span class="number">1</span>])&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,pre[i]+<span class="built_in">abs</span>(suf[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2064D-Eating-1900-位运算"><a href="#2064D-Eating-1900-位运算" class="headerlink" title="2064D-Eating *1900 位运算"></a>2064D-Eating <strong>*1900</strong> 位运算</h2><ul>
<li>题意：给你一个数组，每次询问在初始数组后面加入一个数字，如果倒数第一个数字大于倒数第二个数字，则可以吞噬倒数第二个数字，并把倒数第一个数字更新为二者的异或和，问每次能吞噬初始数组多少个数字。</li>
<li>思路：对于 <code>xor</code> 的问题，首先按位进行考虑。由于我们能干掉的史莱姆权值都比我们小，所以可以很显然的观察到他们的最高位一定是小于等于我们的，并且我们的最高位在合并史莱姆的过程中只会下降。这启示我们观察到可能使当前结束的点，最高位是大于等于当前值的最高位的。所以我们用 $\text{O}(N\log V)$ 的时间预处理出一个 $pre_{i,j}$ 数组用来存储离当前点 $i$ 最近的最高位大于等于当前值的最高位 $j$ 的下标。而且每次跳转我们要么直接结束，要么最高位至少下降 $1$ 位，所以每次询问的复杂度是 $\text{O}(\log V)$ 的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">pre</span><span class="params">(n<span class="number">+2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">+1</span>)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]^w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VII <span class="title">ne</span><span class="params">(n<span class="number">+2</span>,VI(<span class="number">30</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,<span class="number">29</span>)&#123;</span><br><span class="line">        ne[n<span class="number">+1</span>][i]=n<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x=w[i];</span><br><span class="line">        ne[i]=ne[i<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">29</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                ne[i][j]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">+1</span>;</span><br><span class="line">        <span class="built_in">FORD</span>(i,<span class="number">0</span>,<span class="number">29</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x^pre[l])&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r==ne[l<span class="number">+1</span>][i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ne[l<span class="number">+1</span>][i]&lt;r&amp;&amp;(x^pre[ne[l<span class="number">+1</span>][i]<span class="number">-1</span>])&gt;=w[ne[l<span class="number">+1</span>][i]])&#123;</span><br><span class="line">                    l=ne[l<span class="number">+1</span>][i];</span><br><span class="line">                    r=<span class="built_in">min</span>(r,ne[l<span class="number">+1</span>][i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r=<span class="built_in">min</span>(r,ne[l<span class="number">+1</span>][i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r=<span class="built_in">min</span>(r,<span class="built_in">max</span>(ne[l<span class="number">+1</span>][i],l<span class="number">+1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;r<span class="number">-1</span>&lt;&lt;<span class="string">&quot; \n&quot;</span>[q==<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>逐步模拟显然会超时，涉及二进制要比大小首先看最高位，最高位一定是单调不递增的，如果最后两个数字最高位相同，那么异或后就会变小，由于最高位最多只会变化 $30$ 次，所以可以从这里考虑，我们要找的其实是当前范围内最右侧的和最后一个数字最高位相同的那个值的位置，这样能跳过中间部分快速更新最后一个位置，可以预处理二进制数最高位的信息，然后再用异或前缀和快速更新最后的值。</p>
</blockquote>
<hr>
<p>这道题等待新的解法更新</p>
<hr>
<h2 id="abc377d-Many-Segments-2-贡献法"><a href="#abc377d-Many-Segments-2-贡献法" class="headerlink" title="abc377d-Many Segments 2 贡献法"></a>abc377d-Many Segments 2 贡献法</h2><ul>
<li>题意：给出 $N$ 个区间 $<a href="1\le i\le N,l_i\le r_i\le M">l_i,r_i</a>$，问有多少个区间 $<a href="1\le l\le r\le M">l,r</a>$ 满足不会包含任意给出区间。</li>
<li>思路：此时我们可以先固定一个左端点，然后看 $[l,n]$ 有多少满足不完全包含的条件。此时不包含条件可以变成在区间 $[l,n]$ 中，找到一个 $r$ ，这个 $r$ 很明显肯定就是左端点离 $l$ 最近的线段的右端点减一（这个很明显，建议画图理解）。那么为了研究方便，我们是从大到小枚举 $l$ 的，这样就不会有后效性（也就是如果我们从小到大枚举的话，如果用双指针时间复杂度就高了）。然后我们用双指针维护即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lst=m<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORD</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">1</span>&amp;&amp;w[j].fi&gt;=i)&#123;</span><br><span class="line">            lst=<span class="built_in">min</span>(lst,w[j].se);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=(lst-i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>对于这种数据规模很大的，要统计个数，我们最多只能枚举一维度变量。此时我们就可以通过画图来解决，也就是固定端点做法。</p>
</blockquote>
<h2 id="1883D-In-Love-1500-思维-STL"><a href="#1883D-In-Love-1500-思维-STL" class="headerlink" title="1883D-In Love *1500 思维+STL"></a>1883D-In Love <strong>*1500</strong> 思维+STL</h2><ul>
<li>题意：你有 $T$ 次操作，每次操作为添加或删除一条区间范围为 $[l,r]$ 的线段，问每次操作后是否存在两条线段，使得它们的区间范围没有交集。</li>
<li>思路：对于线段的维护，我们可以用 <code>multiset</code> 来维护，然后判断是否存在两条线段，使得它们的区间范围没有交集，我们就可以取最左边的线段和最右边的线段。在实际代码中，我们也就是开两个 <code>multiset</code>，一个放左端点，一个放右端点。此时如果右端点最小的端点都小于我们左端点最大的点，那么肯定是存在。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;s1,s2;</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">insert</span>(l);</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">insert</span>(r);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.f</span>ind(l));</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">erase</span>(s<span class="number">2.f</span>ind(r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">1.</span>sz&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*s<span class="number">2.</span><span class="built_in">begin</span>()&lt;(*s<span class="number">1.</span><span class="built_in">rbegin</span>()))&#123;</span><br><span class="line">                YES;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>multiset</code> 比 <code>set</code> 能够处理重复元素。</p>
</blockquote>
<h2 id="1925B-A-Balanced-Problemset-1200-数学"><a href="#1925B-A-Balanced-Problemset-1200-数学" class="headerlink" title="1925B-A Balanced Problemset? *1200 数学"></a>1925B-A Balanced Problemset? <strong>*1200</strong> 数学</h2><ul>
<li>题意：给定 $n,x$，要求你把 $n$ 拆成 $x$ 个数，使得它们的 $\gcd$ 最大。</li>
<li>思路：对于这种拆数问题并且要求 $\gcd$ 最大，那么我们可以考虑把这个数质因数分解。也就是变成 $x=p_1^{x_1}p_2^{x_2}…p_n^{x_n}$ 的形式，如果求 $\gcd$ 的话，就是求这些数指数的 $\min$，反之求 $\max$。那这道题的结论就是答案就是 $n$ 的因数。以下是证明过程：<br><a href="https://www.luogu.com.cn/article/c8uotusr">证明</a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=n)ans=<span class="built_in">max</span>(ans,x/i);</span><br><span class="line">            <span class="keyword">if</span>(x/i&gt;=n)ans=<span class="built_in">max</span>(ans,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>知道的结论：$\gcd(A,B)=\gcd(A,A+B)$（一个序列的 $\gcd$ 等于该序列前缀和后的 $\gcd$），也就是 $\gcd(a_1,a_2,a_3…)=\gcd(a_1,a_1+a_2,a_1+a_2+a_3,…)$。</p>
</blockquote>
<h2 id="1991D-Prime-XOR-Coloring-1900-结论题"><a href="#1991D-Prime-XOR-Coloring-1900-结论题" class="headerlink" title="1991D-Prime XOR Coloring *1900 结论题"></a>1991D-Prime XOR Coloring <strong>*1900</strong> 结论题</h2><ul>
<li>题意：给定一张图。若 $u⊕v$ 为质数则 $u,v$ 间有一条连边。求最少颜色数，使得将图染色后，没有一条边的两个端点的颜色相同，并给出每个点的染色方案。</li>
<li>思路：我们发现如果两个整数之差为 $4$ 的倍数，那么他们异或也一定是 $4$ 的倍数，显然是合数。也就是说此时差值为 $4$ 的位置可以颜色相同，那意思就是说最终的答案也就只要 $4$ 种颜色。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl&lt;&lt;<span class="string">&quot;1 2 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;3\n1 2 2 3&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">5</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;3\n1 2 2 3 3&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">6</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;4\n1 2 2 3 3 4&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">6</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">4</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cout&lt;&lt;(i<span class="number">-1</span>)%<span class="number">4</span><span class="number">+1</span>&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>很重要的结论：如果两个整数之差为 $4$ 的倍数，那么他们异或也一定是 $4$ 的倍数，显然是合数。</p>
</blockquote>
<h2 id="739A-Alyona-and-mex-1700-构造"><a href="#739A-Alyona-and-mex-1700-构造" class="headerlink" title="739A-Alyona and mex *1700 构造"></a>739A-Alyona and mex <strong>*1700</strong> 构造</h2><ul>
<li>题意：你有 $m$ 个区间，要求构造一个长度为 $n$ 的序列使得这 $m$ 个区间中 $mex$ 最小的最大（$mex$ 定义为一个区间内没有出现过的最小自然数）。</li>
<li>思路：我们先把问题简单化，也就是如果只有一个区间的情况下，此时我们的 $mex$ 值就等于区间的长度。那么当我们出现多个区间的话，那么答案就是这些区间长度的最小值。那么方案怎么输出呢？我们可以让整个数组的 $mex$ 值都是那个最小值，也就是比如 <code>1 2 0 1 2 0 1 2 ...</code> 这样的数组，这样你任意取一段区间长度大于最小值的它的 $mex$ 都是一样的。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,r[i]-l[i]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;i%ans&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这道题的构造先得考虑特殊情况，再考虑一般情况。也就是先得想最一般的构造是怎样的，然后通过数学归纳法得出结论（或者可以猜结论）。</p>
</blockquote>
<hr>
<p>从这里开始，我都会分析我自己错在哪里了。</p>
<h2 id="1690E-Price-Maximization-1500-思维"><a href="#1690E-Price-Maximization-1500-思维" class="headerlink" title="1690E-Price Maximization *1500 思维"></a>1690E-Price Maximization <strong>*1500</strong> 思维</h2><ul>
<li><p>题意：给你 $n$ 件物品，再给你 $n/2$ 个包裹，每个包裹可以放 $2$ 件物品，每个包装的成本是包的重量除 $k$ （给定值）下取整的值，求最大可能总成本。</p>
</li>
<li><p>正解思路：首先我们可以先算所有数对 $k$ 下取整的值，题目要求最大总成本，因为我们有可能选的两个数不会导致被下取整（就是刚好整除这样的），因此我们得维护每个包裹重量模 $k$ 的余数，然后我们对余数排序，那么此时的余数就具备单调性了，然后我们就用双指针去维护就可以了（也就是如果再 $l<r$ 的范围内出现 $a_l+a_r>=k$ 答案就得加一）</p>
</li>
<li><p>卡在：不知道怎么去处理包裹重量和的下取整，没有想到要维护余数来做。（<del>其实我第一眼看到 $k$ 很小，就打算从 $k$ 入手，没想到就不知道怎么下去了</del>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],a[i]=w[i]%k,ans+=w[i]/k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;a[l]+a[r]&lt;k)l++;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)ans++;</span><br><span class="line">        l++,r--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1789C-Serval-and-Toxel’s-Arrays-1500-思维题"><a href="#1789C-Serval-and-Toxel’s-Arrays-1500-思维题" class="headerlink" title="1789C-Serval and Toxel’s Arrays *1500 思维题"></a>1789C-Serval and Toxel’s Arrays <strong>*1500</strong> 思维题</h2><ul>
<li>题意：给定一个不重的数组和 $m$ 次操作，每次操作更改数组中的一个数，时刻保证数组不重。求包括的初始数组的 $m+1$ 个数组两两的并集的元素个数之和。</li>
<li>思路：我们发现，对于第 $i$ 次修改操作，计算当前数组与前 $i$ 个历史版本的贡献。因为数组不重，所以并集中一定有自身的 $n$ 个元素，可以先给答案增加 $i \times n$。前面这句话很好理解。接下来计算前 $i$ 个历史版本出现但是当前不存在的数字的个数，下文记为 $sum$。统计进答案即可。也就是说，在修改操作时同时维护 $sum$。如将 $p$ 位置更改为 $q$，我们就可以给 $sum$ 加上 $a<em>p$ 之前出现的次数，减去 $q$ 之前对 $sum$ 的贡献 $del</em>{q}$（其中 $dek_{q}$ 指的是上次 $a_q$ 被替换完到现在被替换的操作次数，然后 $add$ 数组指的是 $q$ 最后一次出现的操作次数。总的来说就是，$del$ 维护的是被删除掉的数的贡献，为什么要维护这个呢？是因为如果后面一不小心又把数换回来，如果不减掉的话，此时这样我们是默认那个被删掉的数仍然还在数组里面的，那么两个数组并集就会重复计算了。就是为了避免重复（也就是如果这个数之前出现过后面被删了然后后面又出现然后又被删了，此时前面的 <code>i-add[w[x]]+del[w[x]]</code> 计算就会重复））。维护这些信息，只需要记录每一个数字出现的时间和删除时给 $sum$ 的贡献即可。总的来说这种思路就是按每个数字出现次数来算贡献的，而我的思路就是看成一个整体来做，这样就有明显问题。</li>
</ul>
<ul>
<li>错误思路：就是我没有考虑到一个数还有可能会重新在后面出现出现，然后它可能会贡献答案。当时考虑的太理想了。具体思路就是：因为每两个变化的数组都会被计算一下，此时我就先算出除了原数组以外其他数组相比元素组数的变化情况，如果在某个位置变化则在这个地方+1。（思路到这里就彻底错了）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">del</span><span class="params">(n+m<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">add</span><span class="params">(n+m<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> t=i+del[w[x]]-add[w[x]];</span><br><span class="line">        sum+=t;</span><br><span class="line">        del[w[x]]=t;</span><br><span class="line">        add[y]=i;</span><br><span class="line">        sum-=del[y];</span><br><span class="line">        ans+=n*i+sum;</span><br><span class="line">        w[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>特难理解我觉得</p>
</blockquote>
<h2 id="1792C-Min-Max-Sort-1500-思维"><a href="#1792C-Min-Max-Sort-1500-思维" class="headerlink" title="1792C-Min Max Sort *1500 思维"></a>1792C-Min Max Sort <strong>*1500</strong> 思维</h2><ul>
<li>题意：给你一个数组，每次操作可以取出两个数 $x,y$，较大的数放在数组末尾，较小的数放在开头。问多少次操作能让数组升序。</li>
<li>思路：因为这道题给定是序列，因此你要升序，此时就得是按照这样 <code>1 2 3 4...</code> 这样排列。同时我们也发现，最大的交换次数就是 $n/2$ 。什么时候会比那个少呢？那当然就是比如 <code>2 1 4 3</code>，此时只需要一次操作，那么我们发现：我们从已排序的数组角度出发，分别位于首尾的 $1$ 和 $n$ 一定是在最后一次操作中归位的。类似地，$2$ 和 $n−1$ 一定是在倒数第二次操作中归位的。以此类推。假设共操作 $k$ 次，则 $1$∼$k$ 和 $n−k+1$∼$n$ 都被归位，而中间的 $k+1$∼$n−k$ 按原顺序排列。设元素 $i$ 的初始位置为 $pos<em>i$ 。那么 $k$ 次操作能将 $p$ 排序，当且仅当 $pos</em>{k+1} \lt pos<em>{k+2}\lt \cdots\lt pos</em>{n-k}$ 。首先 $k<em>0=\lfloor\frac n2\rfloor$ 一定可行。如果 $k$ 可行，并且 $pos_k\lt pos</em>{k+1},~pos<em>{n-k}\lt pos</em>{n-k+1}$ ，那么 $k-1$ 也可行。从 $k_0$ 开始枚举，找到最小的 $k$ 即可。注意这里的 $pos_i$ 指的是 $w_x=i$，也就是如果要变成有序的情况下，这个地方填的数是原数组索引的哪个位置。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        w[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ans&amp;&amp;w[ans]&lt;w[ans<span class="number">+1</span>]&amp;&amp;w[n-ans]&lt;w[n-ans<span class="number">+1</span>])ans--;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>其实发现还可以用二分来做。</p>
</blockquote>
<h2 id="1817A-Almost-Increasing-Subsequence-1500-前缀和"><a href="#1817A-Almost-Increasing-Subsequence-1500-前缀和" class="headerlink" title="1817A-Almost Increasing Subsequence *1500 前缀和"></a>1817A-Almost Increasing Subsequence <strong>*1500</strong> 前缀和</h2><ul>
<li>题意：如果数组不包含满足 $z \le y \le x$ 的情况，那么说明这个序列是几乎递增的，对于每组询问数组中几乎递增的长度。</li>
<li>思路：因为只需要不存在三元组，那么如果是两个数的话，那么它肯定不存在这个情况。那么这个我们可以用前缀和来维护，只有当三元组结束了才 $+1$。询问时，只需要用区间的长度减去区间当中有多少满足条件的元素即可。但需要注意的是，$s[l]$ 由 $w[l-1]$ 和 $w[l-2]$ 决定，$s[l+1]$ 由 $w[l]$ 和 $w[l-1]$ 决定，含有不在区间内的元素，所以算的时候应该从 $s[l+2]$ 开始算，当然还要减 $1$。所以满足要求的元素个数为 $s[r]-s[(l+2)-1]$，即 $s[r]-s[l+1]+2$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;!(w[i<span class="number">-2</span>]&gt;=w[i<span class="number">-1</span>]&amp;&amp;w[i<span class="number">-1</span>]&gt;=w[i]))&#123;</span><br><span class="line">            s[i]=s[i<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[i]=s[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(r-l&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;r-l<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;(s[r]-s[l<span class="number">+1</span>]<span class="number">+2</span>)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前缀和也是可以维护三元甚至四元组的情况。</p>
</blockquote>
<h2 id="1842C-Tenzing-and-Balls-1500-dp"><a href="#1842C-Tenzing-and-Balls-1500-dp" class="headerlink" title="1842C-Tenzing and Balls *1500 dp"></a>1842C-Tenzing and Balls <strong>*1500</strong> dp</h2><ul>
<li><p>题意：给定数组 $a$，可选择 $i,j$，$1\le i &lt; j\le |a|$ 且 $a_i = a_j$，删去 $[i, j]$ 的所有数，后面的数（如果有）接上，问最多能删几个数。</p>
</li>
<li><p>思路：这是很典型的线性 dp 问题，每个数可以选和不选，我们可以设 $f<em>i$ 表示前 $i$ 个数里面能删多少个数，则有：$f_i=\max(f</em>{j-1}+i-j+1,f<em>i)$，其中 $a_i=a_j$，如果我们暴力求 $j$ 就肯定超时了，因为我们根据 $a_i=a_j$ 可以知道，此时可以用桶来装，这个桶 $mx_x$ 表示对于所有的 $x$ 满足 $a_i=x$ 最大的 $f</em>{j-1}+i-j+1$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span>,<span class="title">mx</span><span class="params">(n<span class="number">+1</span>,<span class="number">-1e18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],mx[w[i]]+i);</span><br><span class="line">        mx[w[i]]=<span class="built_in">max</span>(mx[w[i]],f[i<span class="number">-1</span>]-i<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这道题真服了，我没有想到用dp来做，因为我看数据规模很大。以后得注意了，数据规模比较大也得想想dp，因为可能有些性质可以让dp变成线性dp的。因此我们得多列列状态转移方程。</p>
</blockquote>
<h2 id="1876B-Effects-of-Anti-Pimples-1500-贡献法"><a href="#1876B-Effects-of-Anti-Pimples-1500-贡献法" class="headerlink" title="1876B-Effects of Anti Pimples *1500 贡献法"></a>1876B-Effects of Anti Pimples <strong>*1500</strong> 贡献法</h2><ul>
<li>题意：你有一个长为 $n$ 的序列 $a(1≤n≤10^5)$。现在你可以在序列中可重地选若干个下标，这个位置和下标的倍数的位置也会被选。获得的价值是选出的位置上数的最大值，不能不选。你显然有 $2^n−1$ 种选法，现在请你求出这些选法的价值总和，模 $998244353$。</li>
<li>思路：肯定是贡献法。我们可以发现，如果其中如果选择了对应位是最大值的下标，那么无论其他的，结果一定是最大值。一次往下，选择了次大值的下标，结果一定是次大值。我们可以考虑预处理每一个下标 $i$，看它以及的所有倍数下标 $j$ 所能产生的最大值是多少。预处理完之后，我们先看看，所有含最大值的子集有多少个，答案是 $2^{n-1}$ 个。以下是推理：含某一个数字的子集个数，我们可以看作是总的子集个数减去不含那个数字的子集个数。不含那个数，集合大小就是 $n−1$，子集个数为 $2^{n−1}$−1。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            w[i]=<span class="built_in">max</span>(w[i],w[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w<span class="number">+1</span>,w<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tot=n;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">qmi</span>(<span class="number">2</span>,i<span class="number">-1</span>)%mod*w[i]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans%mod;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>其实也可以不必推导，直接得出结论。</p>
</blockquote>
<h2 id="1793C-Dora-and-Search-1200-STL"><a href="#1793C-Dora-and-Search-1200-STL" class="headerlink" title="1793C-Dora and Search *1200 STL"></a>1793C-Dora and Search <strong>*1200</strong> STL</h2><ul>
<li>题意：找到一个子段满足 $a<em>l\not = \min(a_l,a</em>{l+1},…,a<em>r)，a_r\not = \max(a_l,a</em>{l+1},…,a<em>r)$，或者a_l\not = \max(a_l,a</em>{l+1},…,a<em>r)，a_r\not = \min(a_l,a</em>{l+1},…,a_r)$。如果存在输出下标。</li>
<li>思路：这又是一道维护区间最大值最小值问题（而且这些数可能重复），这种问题要么用线段树/ST表/树状数组维护，但写的比较多，此时也可以用 <code>multiset</code> 维护。然后后面就模拟即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;S;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],S.<span class="built_in">insert</span>(w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mx=*S.<span class="built_in">rbegin</span>(),mi=*S.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> a=((mx==w[l])||(mi==w[l]));</span><br><span class="line">        <span class="type">int</span> b=((mx==w[r])||(mi==w[r]));</span><br><span class="line">        <span class="keyword">if</span>(a&amp;&amp;b)S.<span class="built_in">erase</span>(w[l++]),S.<span class="built_in">erase</span>(w[r--]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a)S.<span class="built_in">erase</span>(w[l++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b)S.<span class="built_in">erase</span>(w[r--]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>维护区间最大值最小值问题（而且这些数可能重复），这种问题要么用线段树/ST表/树状数组/multiset维护。</p>
</blockquote>
<h2 id="1822D-Super-Permutation-1200-思维"><a href="#1822D-Super-Permutation-1200-思维" class="headerlink" title="1822D-Super-Permutation *1200 思维"></a>1822D-Super-Permutation <strong>*1200</strong> 思维</h2><ul>
<li>题意：给定排列 $a$，构造数组 $b$，其中 $b_i=(a_1+a_2+…+a_i)\mod n$,如果 $a$ 数组是超级排列，当且仅当 $[b_1+1,b_2+2,…,b_n+1]$ 是排列。</li>
<li>思路：我们可以通过暴力打表来找规律，发现奇数是不可能的（除 $1$ 外），如果是偶数的话，则可以这样构造： $n,n-1,2,n-3,4,n-5,6…$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;2 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p1=<span class="number">2</span>,p2=n<span class="number">-1</span>;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2!=<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p2&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;p1&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        p1+=<span class="number">2</span>,p2-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1932C-Contrast-Value-1200-思维"><a href="#1932C-Contrast-Value-1200-思维" class="headerlink" title="1932C-Contrast Value *1200 思维"></a>1932C-Contrast Value <strong>*1200</strong> 思维</h2><ul>
<li>题意：给你一个数组 $a$，我们称相邻两个数的绝对值为对比度，你可以删除 $a$ 数组一些元素，要求你删除的数越多（即 $a$ 数组的长度越小）且对比度不变。</li>
<li>思路：很简单，我们发现如果是连续的递减或递增，此时中间的数都可以删掉了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i],S[w[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S[w[<span class="number">1</span>]]==n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]==w[i<span class="number">+1</span>])&#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w[i]&lt;w[i<span class="number">+1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(j<span class="number">+1</span>&lt;=n&amp;&amp;w[j<span class="number">+1</span>]&gt;=w[j])j++;</span><br><span class="line">            ans++;</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(j<span class="number">+1</span>&lt;=n&amp;&amp;w[j<span class="number">+1</span>]&lt;=w[j])j++;</span><br><span class="line">            ans++;</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1870B-Friendly-Arrays-1200-位运算-思维"><a href="#1870B-Friendly-Arrays-1200-位运算-思维" class="headerlink" title="1870B-Friendly Arrays *1200 位运算+思维"></a>1870B-Friendly Arrays <strong>*1200</strong> 位运算+思维</h2><ul>
<li>题意：给定长度为 $n$ 的数组 $a$ 和长度为 $m$ 的数组 $b$，此时可以无限次进行操作 $a_i|=a_j$，问操作完成后 $a$ 数组的异或和的最大值和最小值。</li>
<li>思路：我们可以分奇偶来讨论，当 $n$ 为奇数的情况下，此时异或要最大，也就是每个数都给它搞奇数个 $1$，也就是说我们可以把 $b$ 的每个数都或起来，然后再全部给 $a$ 数组或上，这样对于每一位都有奇数个 $1$ 了，那么异或起来肯定大，此时的最小值很明显就是原异或值，反之偶数情况。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        ans1^=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        ans2|=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans^=(ans2|a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>异或这玩意得考虑奇数偶数情况。</p>
</blockquote>
<h2 id="1877C-Joyboard-1200-数学"><a href="#1877C-Joyboard-1200-数学" class="headerlink" title="1877C-Joyboard *1200 数学"></a>1877C-Joyboard <strong>*1200</strong> 数学</h2><ul>
<li>题意：给你三个整数 $n,m,k$，你将会选一个数 $x(0 \le x \le m)$ 作为 $a<em>{n+1}$ 的值，然后从 $n$ 到 $1$ 遍历使得 $a_i=a</em>{i+1} \bmod i$。问有多少个这样的数 $x$，使得 $a_i$ 的值恰好有 $k$ 种。</li>
<li>思路：这就是一道诈骗题。我们可以发现我们只需要讨论 $k&lt;=3$ 的情况就好，因为不可能有超过 $3$ 的情况。当 $k=1$ 时候，此时 $a_{n+1}=0$ ，否则 $a$ 序列一定会取到至少两个值。故输出 $1$。当 $k=2$ 时候，此时这要求值一步从初始值变为 $0$，显然初始值要么小于 $n$ 要么是 $n$ 的倍数。故输出 $\min(n−1,m)+⌊n/m⌋$。当 $k=3$：总数减去 $k&lt;3$ 的情况，故输出 $m−\min(n−1,m)−⌊n/m⌋$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">min</span>(n<span class="number">-1</span>,m)+m/n&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">3</span>)&#123;</span><br><span class="line">        cout&lt;&lt;m-<span class="built_in">min</span>(n<span class="number">-1</span>,m)-m/n&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1903E-StORage-room-1200-位运算-思维"><a href="#1903E-StORage-room-1200-位运算-思维" class="headerlink" title="1903E-StORage room *1200 位运算+思维"></a>1903E-StORage room <strong>*1200</strong> 位运算+思维</h2><ul>
<li>题意：给出一个矩阵 $m$，问是否能构造一个序列 $a$，满足 $a<em>{i}|a</em>{j}=m_{i,j}(i \ne j)$，如果有，输出这个矩阵。</li>
<li>思路：我们可以发现：给我们的矩阵如果不考虑对角线上的，如果某个数的某一位有 $1$ 的情况下，那么最后的或值就是有 $1$。那么这里可以用一个技巧，一般的，对于已知或值求某个数的位数状态，我们可以用与来做，具体来说就是先把每个数的位数都变成 $1$，然后如果不存在 $1$ 的话，此时这个数就是 $0$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VI <span class="title">f</span><span class="params">(n<span class="number">+1</span>,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                f[i]&amp;=w[i][j];</span><br><span class="line">                f[j]&amp;=w[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((f[i]|f[j])!=w[i][j])&amp;&amp;i!=j)&#123;</span><br><span class="line">                NO;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;f[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这种与和或互相转化的思路得好好了解。</p>
</blockquote>
<h2 id="1919C-Grouping-Increases-1400-思维题"><a href="#1919C-Grouping-Increases-1400-思维题" class="headerlink" title="1919C-Grouping Increases *1400 思维题"></a>1919C-Grouping Increases <strong>*1400</strong> 思维题</h2><ul>
<li><p>题意：给定一个长为 $n$ 的序列 $a$，你需要将该序列恰好分成两个子序列 $s,t$。定义一个长为 $m$ 的序列 $b$ 的代价为 $ p(b)=\sum<em>{i=1}^{m-1}[b_i&lt;b</em>{i+1}]$，求 $p(s)+p(t)$ 的最小值。每个测试点 $t$ 组测试用例。</p>
</li>
<li><p>思路：为了避免我们下面的错误思路，我们可以把原数组当成一个堆，然后从堆中取出一些数放在两个数组中去，这里我们把这两个数组的末尾给维护下。此时我们就会考虑：对于一个新元素 $a_i$ ，我们要考虑将其放入哪个子序列后，而且我们希望修改后 $x,y$ 的值尽量变大，其中 $x,y$ 指的是两个序列的末尾值，因为这会对后续造成更有利的影响。（这种放入的贪心比我们在原数组的贪心就少了后效性）然后我们只需要分类讨论即可。也即是：当 $a_i&gt;x$ 这意味着无论放在哪个子序列都会导致答案多一，但是显然将 $a_i$ 放在 $y$ 最优，因为这会使 $x,y$ 增大的尽量多（如果你放在 $x$ 后面，那么你 $y$ 就不大了），$a_i&gt;y$ 我们就把数放在 $y$ 后面，$a_i \le y$ 显然此时放在哪个子序列中答案都不会加一。但是这样修改后一定会让它们变小，所以我们就放在 $y$ 这里了。</p>
</li>
<li>错误思路：认为当出现递增的数就把数放在第二个数组中去。那么这个很明显就是错的，因为：<code>1 2 3 9 6 3 1</code> 输出了 $3$，但答案是 $2$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1e18</span>,y=<span class="number">1e18</span>;</span><br><span class="line">    <span class="comment">//之前做法错了原因：1 2 3 9 6 3 1 输出了3，但答案是2</span></span><br><span class="line">    <span class="comment">//因为我们这样子有可能会因为数特别大，然后第一位可以牺牲一次法式换来后面的舒服。</span></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;=x)&#123;</span><br><span class="line">            x=w[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w[i]&gt;x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;=y)&#123;</span><br><span class="line">                y=w[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                x=w[i];</span><br><span class="line">                <span class="built_in">swap</span>(x,y);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1974D-Ingenuity-2-1400-模拟"><a href="#1974D-Ingenuity-2-1400-模拟" class="headerlink" title="1974D-Ingenuity-2 *1400 模拟"></a>1974D-Ingenuity-2 <strong>*1400</strong> 模拟</h2><ul>
<li>题意：给定一个长度为 $n$ 且仅包含 <code>N、S、E、W</code> 的指令串，将这些指令分给一个的机器人和直升机，它们会沿着这个方向移动一步，问它们能否从同一个点走到另一个相同的点？</li>
<li>思路：我们其实可以在如果 <code>N</code> 是奇数的情况下给 <code>R</code>，如果是偶数的情况下给 <code>H</code>，这样一定是最优的，因为不管怎样二者都有移动过。然后最后只需要判断是不是会重合即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>,c3=<span class="number">0</span>,c4=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(n,<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;N&#x27;</span>)&#123;</span><br><span class="line">            c1++;</span><br><span class="line">            <span class="keyword">if</span>(c1&amp;<span class="number">1</span>)ans[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[i]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">            c2++;</span><br><span class="line">            <span class="keyword">if</span>(c2&amp;<span class="number">1</span>)ans[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[i]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">            c3++;</span><br><span class="line">            <span class="keyword">if</span>(c3&amp;<span class="number">1</span>)ans[i]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">            c4++;</span><br><span class="line">            <span class="keyword">if</span>(c4&amp;<span class="number">1</span>)ans[i]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rx=<span class="number">0</span>,ry=<span class="number">0</span>,hx=<span class="number">0</span>,hy=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> f1=<span class="literal">false</span>,f2=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;R&#x27;</span>)f1=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;H&#x27;</span>)f2=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;N&#x27;</span>)ry++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;S&#x27;</span>)ry--;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;W&#x27;</span>)rx--;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;E&#x27;</span>)rx++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;H&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;N&#x27;</span>)hy++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;H&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;S&#x27;</span>)hy--;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;H&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;W&#x27;</span>)hx--;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;H&#x27;</span>&amp;&amp;s[idx]==<span class="string">&#x27;E&#x27;</span>)hx++;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hx==rx&amp;&amp;hy==ry&amp;&amp;f1&amp;&amp;f2)cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>别想太复杂了，这是我之前的代码：(写的跟屎山一样)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">&quot;SN&quot;</span>||s==<span class="string">&quot;NS&quot;</span>||s==<span class="string">&quot;EW&quot;</span>||s==<span class="string">&quot;WE&quot;</span>)&#123;</span><br><span class="line">        NO;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        S[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((S[<span class="string">&#x27;N&#x27;</span>]+S[<span class="string">&#x27;S&#x27;</span>])%<span class="number">2</span>||(S[<span class="string">&#x27;E&#x27;</span>]+S[<span class="string">&#x27;W&#x27;</span>])%<span class="number">2</span>)&#123;</span><br><span class="line">        NO;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cn=<span class="number">0</span>,ce=<span class="number">0</span>,cw=<span class="number">0</span>,cs=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((S[<span class="string">&#x27;N&#x27;</span>]&amp;<span class="number">1</span>)||(S[<span class="string">&#x27;S&#x27;</span>]&amp;<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">max</span>(S[<span class="string">&#x27;S&#x27;</span>]<span class="number">-1</span>,S[<span class="string">&#x27;N&#x27;</span>]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">            cs++;</span><br><span class="line">            cn++;</span><br><span class="line">            f=<span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[<span class="string">&#x27;S&#x27;</span>]&gt;S[<span class="string">&#x27;N&#x27;</span>])&#123;</span><br><span class="line">                cs+=t;</span><br><span class="line">                cn+=S[<span class="string">&#x27;N&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S[<span class="string">&#x27;S&#x27;</span>]&lt;S[<span class="string">&#x27;N&#x27;</span>])&#123;</span><br><span class="line">                cn+=t;</span><br><span class="line">                cs+=S[<span class="string">&#x27;S&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cs+=S[<span class="string">&#x27;S&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((S[<span class="string">&#x27;N&#x27;</span>])||(S[<span class="string">&#x27;S&#x27;</span>]))&#123;</span><br><span class="line">        <span class="type">int</span> p1=S[<span class="string">&#x27;N&#x27;</span>]/<span class="number">2</span>,p2=S[<span class="string">&#x27;S&#x27;</span>]/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            cn+=p1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p1)&#123;</span><br><span class="line">            cn++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            cs+=p2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2)&#123;</span><br><span class="line">            cs++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((S[<span class="string">&#x27;E&#x27;</span>]&amp;<span class="number">1</span>)||(S[<span class="string">&#x27;W&#x27;</span>]&amp;<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">max</span>(S[<span class="string">&#x27;E&#x27;</span>]<span class="number">-1</span>,S[<span class="string">&#x27;W&#x27;</span>]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">                ce++;</span><br><span class="line">                cw++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[<span class="string">&#x27;E&#x27;</span>]&gt;S[<span class="string">&#x27;W&#x27;</span>])&#123;</span><br><span class="line">                ce+=t;</span><br><span class="line">                cw+=S[<span class="string">&#x27;W&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S[<span class="string">&#x27;E&#x27;</span>]&lt;S[<span class="string">&#x27;W&#x27;</span>])&#123;</span><br><span class="line">                cw+=t;</span><br><span class="line">                ce+=S[<span class="string">&#x27;E&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ce+=S[<span class="string">&#x27;E&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S[<span class="string">&#x27;E&#x27;</span>]||S[<span class="string">&#x27;W&#x27;</span>])&#123;</span><br><span class="line">        <span class="type">int</span> p1=S[<span class="string">&#x27;E&#x27;</span>]/<span class="number">2</span>,p2=S[<span class="string">&#x27;W&#x27;</span>]/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            ce+=p1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p1)&#123;</span><br><span class="line">            ce++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            cw+=p2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2)&#123;</span><br><span class="line">            cw++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;cn&lt;&lt;&#x27; &#x27;&lt;&lt;cw&lt;&lt;&#x27; &#x27;&lt;&lt;cs&lt;&lt;&#x27; &#x27;&lt;&lt;ce&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    string ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;S&#x27;</span>&amp;&amp;cs)cs--,ans+=<span class="string">&quot;R&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">&#x27;S&#x27;</span>&amp;&amp;!cs)ans+=<span class="string">&quot;H&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;W&#x27;</span>&amp;&amp;cw)cw--,ans+=<span class="string">&quot;R&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">&#x27;W&#x27;</span>&amp;&amp;!cw)ans+=<span class="string">&quot;H&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;E&#x27;</span>&amp;&amp;ce)ce--,ans+=<span class="string">&quot;R&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">&#x27;E&#x27;</span>&amp;&amp;!ce)ans+=<span class="string">&quot;H&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;N&#x27;</span>&amp;&amp;cn)cn--,ans+=<span class="string">&quot;R&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">&#x27;N&#x27;</span>&amp;&amp;!cn)ans+=<span class="string">&quot;H&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队内训练2</title>
    <url>/2025/02/15/%E9%98%9F%E5%86%85%E8%AE%AD%E7%BB%832/</url>
    <content><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ea0037oi.png" alt=""></p>
<p>题目来源：2024湖南省赛</p>
<h1 id="A-签到题"><a href="#A-签到题" class="headerlink" title="A 签到题"></a>A 签到题</h1><ul>
<li>模拟</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> t=x;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,k)&#123;</span><br><span class="line">            t%=n;</span><br><span class="line">            w[t]=<span class="number">1</span>;</span><br><span class="line">            t=t*x%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> t=x;</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,k)&#123;</span><br><span class="line">            t%=n;</span><br><span class="line">            <span class="keyword">if</span>(!w[t])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                f=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t*x%n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)<span class="keyword">continue</span>;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-签到题"><a href="#B-签到题" class="headerlink" title="B 签到题"></a>B 签到题</h1><ul>
<li>直接用 <code>log2</code> 更快，因为跟二次方幂有关。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        t+=<span class="built_in">log2</span>(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t=<span class="built_in">ceil</span>(<span class="number">1.</span>*t/<span class="built_in">log2</span>(<span class="number">2024</span>));</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>)t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-子集枚举dp"><a href="#C-子集枚举dp" class="headerlink" title="C 子集枚举dp"></a>C 子集枚举dp</h1><p><img src="https://img2024.cnblogs.com/blog/3495111/202410/3495111-20241018180916745-1648809.png" alt=""></p>
<ul>
<li><p>数很小，可以考虑状态压缩，然后这里是数很小，因此对每个数选和不选进行状态压缩。</p>
</li>
<li><p>此时注意到任意两个字符串相与为 $0$ 则可以合并。求 $1$ 的最多的合并后的串。可以先 $18n$ 枚举处理所有的 $01$ 串。然后 <code>dp</code> 转移拿到最大出现子集，那么 <code>f[x] + f[s^x]</code> 就是答案。其中 <code>f[i]</code> 表示状态为 $i$ 的 $01$ 串从出现的子集转移过来的 $1$ 的个数最多是多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;w[i],w[i]--;</span><br><span class="line">    <span class="comment">//枚举子集dp</span></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,i,<span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(n,i<span class="number">+17</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&amp;(<span class="number">1</span>&lt;&lt;w[j]))<span class="keyword">break</span>;</span><br><span class="line">            p|=(<span class="number">1</span>&lt;&lt;w[j]);</span><br><span class="line">            f[p]=__builtin_popcount(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">17</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[i^(<span class="number">1</span>&lt;&lt;j)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]+f[i^((<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="D-最短路"><a href="#D-最短路" class="headerlink" title="D 最短路"></a>D 最短路</h1><ul>
<li>因为有一个神奇的魔法，因此可以对这个魔法的是否使用搞一个最短路即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;PII&gt; g[N];</span><br><span class="line"><span class="type">int</span> dist[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,id,op;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> E&amp; t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d==t.d)<span class="keyword">return</span> op&gt;t.op;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        g[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;E&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        dist[i][<span class="number">0</span>]=dist[i][<span class="number">1</span>]=a[i];</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;dist[i][<span class="number">0</span>],i,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [d,u,op]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[u][op])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u][op]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,w]:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!op)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[j][<span class="number">0</span>]&gt;dist[u][<span class="number">0</span>]+w)&#123;</span><br><span class="line">                    dist[j][<span class="number">0</span>]=dist[u][<span class="number">0</span>]+w;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j][<span class="number">0</span>],j,<span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dist[j][<span class="number">1</span>]&gt;dist[u][<span class="number">0</span>])&#123;</span><br><span class="line">                    dist[j][<span class="number">1</span>]=dist[u][<span class="number">0</span>];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j][<span class="number">1</span>],j,<span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[j][<span class="number">1</span>]&gt;dist[u][<span class="number">1</span>]+w)&#123;</span><br><span class="line">                    dist[j][<span class="number">1</span>]=dist[u][<span class="number">1</span>]+w;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j][<span class="number">1</span>],j,<span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(dist[i][<span class="number">0</span>],dist[i][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-计算几何-建图-贪心"><a href="#E-计算几何-建图-贪心" class="headerlink" title="E 计算几何+建图+贪心"></a>E 计算几何+建图+贪心</h1><ul>
<li>核心思想就是：枚举任意两点形成的有向边，选择夹角不超过 $90$ 度的其他有向边得到一个有向无环图，图上最长路就是答案。（这样就能把所有情况考虑进去）</li>
<li>因为数很小，因此就可以暴力建图。$O(n^4)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m=<span class="number">1e3</span><span class="number">+10</span>,eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;w[N];</span><br><span class="line"><span class="type">int</span> f[N*N],din[N],ans;</span><br><span class="line"></span><br><span class="line">E <span class="keyword">operator</span>-(E a,E b)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_len</span><span class="params">(E a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(a.x*a.x+a.y*a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cross</span><span class="params">(E a,E b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(E a,E b,<span class="type">bool</span> flag)</span></span>&#123;<span class="comment">//选择夹角不超过90度的其他有向边得到一个有向无环图</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cross</span>(a,b)&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cross</span>(a,b)&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> t=(<span class="number">1.</span>*a.x*b.x<span class="number">+1.</span>*a.y*b.y)/(<span class="number">1.</span>*<span class="built_in">get_len</span>(a)*<span class="built_in">get_len</span>(b));</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">0</span>-eps||t<span class="number">-1.0</span>&gt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(E a,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)f[i]=<span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)din[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(w[i]-w[<span class="number">0</span>],a,flag))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">check</span>(w[j]-w[<span class="number">0</span>],a,flag))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(w[j]-w[i],a,flag))&#123;</span><br><span class="line">                    g[i].<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                    din[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[t])&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[t]<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">if</span>(--(din[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    w[<span class="number">0</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        w[i]=&#123;a,b&#125;;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)&#123;</span><br><span class="line">            f[<span class="number">0</span>]++;</span><br><span class="line">            i--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=f[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                <span class="built_in">get</span>(w[j]-w[i],<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">get</span>(w[j]-w[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-尺取法"><a href="#F-尺取法" class="headerlink" title="F 尺取法"></a>F 尺取法</h1><ul>
<li><p>发现所谓的 <code>beautiful sequence</code>就是长度为 $len$ 的连续数字，比如说长度为 $5$ 那么答案就是 <code>2 3 4 5 6</code>。</p>
</li>
<li><p>所以要解决找这个序列我们可以对值域双指针尺取法。</p>
</li>
<li><p>因为满足连续，那么假设长度为 $5$ 的序列满足，那么所有 $len&lt;5$ 的序列的子序列也是满足的,所以 $ans+=r-l+1$。</p>
</li>
<li><p>然后要判断两个串是否都出现，可以用树状数组来判断。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="type">int</span> posa[N],posb[N];</span><br><span class="line"><span class="type">int</span> tra[N],trb[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adda</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))tra[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addb</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))trb[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">querya</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tra[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryb</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=trb[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i],posa[a[i]]=i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,n)cin&gt;&gt;b[i],posb[b[i]]=i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>,l=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="built_in">adda</span>(posa[r],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addb</span>(posb[r],<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> q1=<span class="built_in">querya</span>(posa[r]);</span><br><span class="line">        <span class="type">int</span> q2=<span class="built_in">queryb</span>(posb[r]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;q1!=q2)&#123;</span><br><span class="line">            <span class="built_in">adda</span>(posa[l],<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">addb</span>(posb[l],<span class="number">-1</span>);</span><br><span class="line">            q1=<span class="built_in">querya</span>(posa[r]);</span><br><span class="line">            q2=<span class="built_in">queryb</span>(posb[r]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=r-l<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G-KMP-DP"><a href="#G-KMP-DP" class="headerlink" title="G KMP+DP"></a>G KMP+DP</h1><ul>
<li><p>因为数据规模不大，而且这道题很类似之前做的 KMP+dp 的题目，但之前那道题是求最长公共子序列不包括特定串的。</p>
</li>
<li><p>这道题是求方案数的并且包括 $\le k$ 的特定串的个数。</p>
</li>
<li><p>因此可以让 $f_{i,j,k}$ 表示当前填到了第 $i$ 个数，填了 $j$ 个特定串个数，当且匹配到了 $k$ 这个字符。</p>
</li>
<li><p>那么状态转移也是很容易的，只不过要先对特定串求 <code>next</code> 数组（也就是border）。这里还得注意的就是对于第 $i$ 个数填什么是得枚举的。</p>
</li>
<li><p>最后的答案就是在匹配的位置加起来。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10010</span>][<span class="number">12</span>][N];</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    m=s.sz;</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j<span class="number">+1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j<span class="number">+1</span>])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FOR</span>(j,<span class="number">0</span>,k)&#123;</span><br><span class="line">            <span class="built_in">FOR</span>(l,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;c&lt;=<span class="string">&#x27;z&#x27;</span>;c++)&#123;</span><br><span class="line">                    <span class="type">bool</span> pipei=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> p=l;pipei==<span class="number">0</span>;p=ne[p])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[p<span class="number">+1</span>]==c)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(p==m<span class="number">-1</span>)&#123;</span><br><span class="line">                                (f[i<span class="number">+1</span>][j<span class="number">+1</span>][<span class="number">0</span>]+=f[i][j][l])%=mod;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                (f[i<span class="number">+1</span>][j][p<span class="number">+1</span>]+=f[i][j][l])%=mod;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pipei=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!p)<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(pipei)<span class="keyword">continue</span>;</span><br><span class="line">                    (f[i<span class="number">+1</span>][j][<span class="number">0</span>]+=f[i][j][l])%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        (ans+=f[n][k][i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>日常训练</tag>
      </tags>
  </entry>
</search>
